<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>브루트포스 on Jxun-h Dev Log</title>
    <link>https://jxun-h.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/</link>
    <description>Recent content in 브루트포스 on Jxun-h Dev Log</description>
    <image>
      <title>Jxun-h Dev Log</title>
      <url>https://jxun-h.github.io/images/papermod-cover.png</url>
      <link>https://jxun-h.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 02 Feb 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://jxun-h.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[BOJ] 14500 테트로미노 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8-with-python/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8-with-python/</guid>
      <description>📌 BOJ 14500 테트로미노 💡 조건 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다. 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 해야한다. 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다. 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500) N개의 줄에 종이에 쓰여 있는 수가 주어진다.</description>
    </item>
    <item>
      <title>[BOJ] 14502 연구소 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-14502-%EC%97%B0%EA%B5%AC%EC%86%8C-with-python/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-14502-%EC%97%B0%EA%B5%AC%EC%86%8C-with-python/</guid>
      <description>📌 BOJ 14502 연구소 💡 조건 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8) 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.</description>
    </item>
    <item>
      <title>[BOJ] 14888 연산자 끼워넣기 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-14888-%EC%97%B0%EC%82%B0%EC%9E%90-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-with-python/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-14888-%EC%97%B0%EC%82%B0%EC%9E%90-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-with-python/</guid>
      <description>📌 BOJ 14888 연산자 끼워넣기 💡 조건 N개의 수로 이루어진 수열 A1, A2, &amp;hellip;, AN 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자
연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 수의 개수 N(2 ≤ N ≤ 11)
A1, A2, &amp;hellip;, AN이 주어진다. (1 ≤ Ai ≤ 100) 첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 6 0 0 1 0 실행결과 30 30 ⌨️ 문제 풀이 permutations 라이브러리 import 연산자를 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷) 순서대로 담은 gi 리스트 선언.</description>
    </item>
    <item>
      <title>[BOJ] 10819 차이를 최대로 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-10819-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%B5%9C%EB%8C%80%EB%A1%9C-with-python/</link>
      <pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-10819-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%B5%9C%EB%8C%80%EB%A1%9C-with-python/</guid>
      <description>📌 BOJ 10819 차이를 최대로 💡 조건 N개의 정수로 이루어진 배열 A N (3 ≤ N ≤ 8) 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다. 다음 식의 최댓값을 구하는 프로그램을 작성. |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]| 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 20 1 15 8 4 10 실행결과 62 ⌨️ 문제 풀이 최댓값을 저장할 res 정수 생성 itertools 의 permutaions 함수로 가능한 수를 모두 계산하여 v에 저장하고, res 갱신 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.</description>
    </item>
    <item>
      <title>[BOJ] 1535 안녕 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-1535-%EC%95%88%EB%85%95-with-python/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-1535-%EC%95%88%EB%85%95-with-python/</guid>
      <description>📌 BOJ 1535 안녕 💡 조건 첫째 줄에 사람의 수 N(≤ 20). 둘째 줄에 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 입력. 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 입력. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0. 세준이가 얻을 수 있는 최대 기쁨을 출력. 브루트포스 알고리즘, 배낭 알고리즘 유형 문제 🔖 예제 및 실행결과 예제 3 1 21 79 20 30 25 실행결과 50 ⌨️ 문제 풀이 브루트포스 알고리즘 혹은 냅색 알고리즘 으로 풀이할 수 있다.</description>
    </item>
    <item>
      <title>[BOJ] 18511 큰 수 구성하기 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-18511-%ED%81%B0-%EC%88%98-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-with-python/</link>
      <pubDate>Sat, 18 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-18511-%ED%81%B0-%EC%88%98-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-with-python/</guid>
      <description>📌 BOJ 18511 큰 수 구성하기 💡 조건 N보다 작거나 같은 자연수 중에서, 집합 K의 원소로만 구성된 가장 큰 수를 출력하는 프로그램을 작성.
(10 ≤ N ≤ 100,000,000, 1 ≤ K의 원소의 개수 ≤ 3) K의 모든 원소는 1부터 9까지의 자연수로만 구성된다. 첫째 줄에 N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수를 출력 브루트포스 알고리즘, 재귀함수 유형의 문제 🔖 예제 및 실행결과 예제 657 3 1 5 7 실행결과 577 ⌨️ 문제 풀이 n을 문자열로 바꾸었을 때의 길이를 le 라는 변수에 저장한다.</description>
    </item>
    <item>
      <title>[BOJ] 14620 꽃길 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-14620-%EA%BD%83%EA%B8%B8-with-python/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-14620-%EA%BD%83%EA%B8%B8-with-python/</guid>
      <description>📌 BOJ 14620 꽃길 💡 조건 꽃밭은 N * N 의 격자 모양이고, 씨앗을 (1, 1) ~ (N, N)의 지점 중 한곳에 심을 수 있다.
1년 후 상하좌우로 꽃잎이 펼쳐진다. 어떤 씨앗이 꽃이 핀 뒤, 다른 꽃잎 혹은 꽃술과 닿게 될 경우 꽃이 둘 다 죽어버린다. 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하려고 한다.
진아가 꽃을 심을 수 있는 최소비용을 구하는 문제이다. 한 변의 길이 N(6 ≤ N ≤ 10) 화단의 지점당 가격(0 ≤ G ≤ 200) 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 0 2 3 3 4 1 1 1 1 1 1 0 0 1 1 1 1 3 9 9 0 1 99 9 11 3 1 0 3 12 3 0 0 0 1 실행결과 12 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n = int(stdin.</description>
    </item>
    <item>
      <title>[BOJ] 1411 비슷한 단어 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-1411-%EB%B9%84%EC%8A%B7%ED%95%9C-%EB%8B%A8%EC%96%B4-with-python/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-1411-%EB%B9%84%EC%8A%B7%ED%95%9C-%EB%8B%A8%EC%96%B4-with-python/</guid>
      <description>📌 BOJ 1411 비슷한 단어 💡 조건 문자열 A를 숌스럽게 바꾸어 B로 만들었다면, 그 단어는 비슷한 단어라고한다. 숌스럽게 바꾼다는 것은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다. 단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 문제. 단어의 길이는 최대 50
N은 100보다 작거나 같은 자연수이다.
모든 단어의 길이는 같고, 중복되지 않는다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 12 cacccdaabc cdcccaddbc dcdddbccad bdbbbaddcb bdbcadbbdc abaadcbbda babcdabbac cacdbaccad dcddabccad cacccbaadb bbcdcbcbdd bcbadcbbca 실행결과 13 ⌨️ 문제 풀이 가능한 각 단어들의 쌍을 combinations 함수를 사용해 만들고 순차적으로 순회한다.</description>
    </item>
    <item>
      <title>[BOJ] 1515 수 이어 쓰기 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-1515-%EC%88%98-%EC%9D%B4%EC%96%B4-%EC%93%B0%EA%B8%B0-with-python/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-1515-%EC%88%98-%EC%9D%B4%EC%96%B4-%EC%93%B0%EA%B8%B0-with-python/</guid>
      <description>📌 BOJ 1515 수 이어 쓰기 💡 조건 1부터 N까지 모든 수를 차례대로 공백없이 한 줄에 다 썼다. 다솜이가 숫자의 일부를 지웠고, 지워지기 전의 숫자를 다시 쓰려고 하니 N이 기억나지 않는다. 남은 수를 이어 붙인 수가 주어질 경우, N의 최솟값을 구하는 문제. 일부 숫자를 지우고 남은 수를 이어붙인 수가 주어지며, 이 수는 최대 3000자리. 구현, 문자열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 00000000000000000000000000000000000000000000000000000000000000000000000 실행결과 400 ⌨️ 문제 풀이 1부터 수를 늘려가면서 완전탐색을 실행하면 된다.</description>
    </item>
    <item>
      <title>[BOJ] 2615 오목 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-2615-%EC%98%A4%EB%AA%A9-with-python/</link>
      <pubDate>Sun, 12 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-2615-%EC%98%A4%EB%AA%A9-with-python/</guid>
      <description>📌 BOJ 2615 오목 💡 조건 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있다. board의 크기는 19 * 19
검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시
가로, 세로 또는 대각선 방향 모두 포함해서 같은 색의 바둑돌이 5개 놓여져 있다면 승리한다.
5개 초과 또는 미만의 개수는 승리할 수 없다
검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성.
검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력</description>
    </item>
    <item>
      <title>[BOJ] 11497 통나무 건너뛰기 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-11497-%ED%86%B5%EB%82%98%EB%AC%B4-%EA%B1%B4%EB%84%88%EB%9B%B0%EA%B8%B0-with-python/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-11497-%ED%86%B5%EB%82%98%EB%AC%B4-%EA%B1%B4%EB%84%88%EB%9B%B0%EA%B8%B0-with-python/</guid>
      <description>📌 BOJ 11497 통나무 건너뛰기 💡 조건 첫 줄에 통나무의 개수를 나타내는 정수 (5 ≤ N ≤ 10,000)
둘째 줄에 각 통나무의 높이를 나타내는 정수 (1 ≤ Li ≤ 100,000) 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다.
가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 그리디 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 3 7 13 10 12 11 10 11 12 5 2 4 5 7 9 8 6 6 6 6 6 6 6 6 실행결과 1 4 0 ⌨️ 문제 풀이 단순히 정렬을 해도 되지만, 첫 통나무와 마지막 통나무가 인접해있다는 조건이 있다.</description>
    </item>
    <item>
      <title>[BOJ] 2304 창고 다각형 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-2304-%EC%B0%BD%EA%B3%A0-%EB%8B%A4%EA%B0%81%ED%98%95-with-python/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-2304-%EC%B0%BD%EA%B3%A0-%EB%8B%A4%EA%B0%81%ED%98%95-with-python/</guid>
      <description>📌 BOJ 2304 창고 다각형 💡 조건 기둥의 개수를 나타내는 정수 (1 &amp;lt;= N &amp;lt;= 1000)
각 기둥의 왼쪽 면의 위치를 나타내는 정수 (1 &amp;lt;= L &amp;lt;= 1000)
각 기둥의 높이를 나타내는 정수 (1 &amp;lt;= H &amp;lt;= 1000)
창고 다각형의 면적을 구하는 문제
모든 기둥이 들어가는 창고를 지으려고 할 때, 지붕이 될 수 있는 조건은 아래와 같다.
지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.</description>
    </item>
    <item>
      <title>[BOJ] 12100 2048(easy) with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-12100-2048easy-with-python/</link>
      <pubDate>Mon, 25 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-12100-2048easy-with-python/</guid>
      <description>📌 BOJ 12100 2048(easy) 💡 조건 보드의 크기는 N * N (1 ≤ N ≤ 20)
0 은 빈칸, 이외의 값은 블록의 값들을 나타낸다.
블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다.
블록은 적어도 하나 주어진다. 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 최대 다섯번 이동 시켜서 얻을 수 있는 가장 큰 블록의 값을 출력.</description>
    </item>
    <item>
      <title>[BOJ] 5568 카드 놓기 with Python</title>
      <link>https://jxun-h.github.io/posts/ps/boj-5568-%EC%B9%B4%EB%93%9C-%EB%86%93%EA%B8%B0-with-python/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/ps/boj-5568-%EC%B9%B4%EB%93%9C-%EB%86%93%EA%B8%B0-with-python/</guid>
      <description>📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 &amp;lt;= N &amp;lt;= 10 각 카드에 숫자가 적혀있다. 1 &amp;lt;= 숫자 &amp;lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions
permutations라는 순열 함수를 사용했다.
리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다.</description>
    </item>
  </channel>
</rss>
