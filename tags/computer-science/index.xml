<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Science on Jxun-h Dev Log</title>
    <link>https://jxun-h.github.io/tags/computer-science/</link>
    <description>Recent content in Computer Science on Jxun-h Dev Log</description>
    <image>
      <title>Jxun-h Dev Log</title>
      <url>https://jxun-h.github.io/images/papermod-cover.png</url>
      <link>https://jxun-h.github.io/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 09 Aug 2022 18:41:00 +0000</lastBuildDate>
    <atom:link href="https://jxun-h.github.io/tags/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[CS] 19.최소 비용 신장트리</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-19.%EC%B5%9C%EC%86%8C-%EB%B9%84%EC%9A%A9-%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC/</link>
      <pubDate>Tue, 09 Aug 2022 18:41:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-19.%EC%B5%9C%EC%86%8C-%EB%B9%84%EC%9A%A9-%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC/</guid>
      <description>📌최소 비용 신장트리 💡최소 비용 신장트리 정의
가중치가 부여된 무방향 그래프에서 신장 트리의 비용
가중치 : 두 vertex 사이의 거리 혹은 연결하는 비용
= 신장트리를 구성하는 에지들의 비용의 합 최소 비용 신장트리 : 가장 비용이 적은 신장 트리 응용 분야
도로 건설 : 도시를 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
ex) 통신, 배관 최소 비용 신장트리 알고리즘
최소 비용 신장트리 알고리즘 그래프 내에 존재하는 Edge들만 사용한다. 정점의 개수가 n일 때, n - 1개의 Edge들만 사용한다.</description>
    </item>
    <item>
      <title>[CS] 18.기초적인 그래프 연산들</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-18.%EA%B8%B0%EC%B4%88%EC%A0%81%EC%9D%B8-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%97%B0%EC%82%B0%EB%93%A4/</link>
      <pubDate>Tue, 09 Aug 2022 18:18:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-18.%EA%B8%B0%EC%B4%88%EC%A0%81%EC%9D%B8-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%97%B0%EC%82%B0%EB%93%A4/</guid>
      <description>📌 기초적인 그래프 연산들 💡깊이 우선 탐색(Depth First Search) DFS 알고리즘 출발 정점, v의 인접리스트부터 방문한다. v에 인접하면서 아직 방문하지 않은 정점 w를 선택한다. w를 시작점으로 하여 다시 DFS를 시작한다. 순환 알고리즘을 이용하여 구현한다.(재귀) 💡너비 우선 탐색(Breath First Search) BFS 알고리즘 출발 정점, v의 인접 리스트부터 방문한다. v에 인접한 모든 vertex부터 방문한다. 그 다음, v에 인접한 첫번째 vertex에 인접한 vertex 중에서
아직 방문하지 않은 vertex 들을 차례대로 다시 방문한다.</description>
    </item>
    <item>
      <title>[CS] 17.그래프의 개념과 표현</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-17.%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%91%9C%ED%98%84/</link>
      <pubDate>Sun, 17 Jul 2022 18:51:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-17.%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%91%9C%ED%98%84/</guid>
      <description>📌 그래프의 개념과 표현 💡 그래프 소개 그래프(Graph)란? 연결되어 있는 객체 간의 관계를 표현하는 자료구조 지하철 노선도, SNS 친구 관계, 컴퓨터 네트워크 💡 그래프 데이터 타입 그래프 G의 두가지 구성요소
V(G) : G에 포함된 Vertex(정점)들의 집합 E(G) : G에 포함된 Edge(간선)들의 집합 무방향성 그래프(Undirected Graph)
Vertex 의 쌍을 나타내는 Edge가 방향성이 없다. (u, v), (v, u) 는 동일한 Edge 를 표현하는 것이다.
EX) 지하철 노선도 방향성 그래프(Directed Graph)
각 Edge에 방향성이 존재하는 그래프 (u, v) : v -&amp;gt; v 인 Edge를 표현하는 것이다.</description>
    </item>
    <item>
      <title>[CS] 16.이진 검색 트리</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-16.%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89-%ED%8A%B8%EB%A6%AC/</link>
      <pubDate>Sun, 17 Jul 2022 16:46:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-16.%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89-%ED%8A%B8%EB%A6%AC/</guid>
      <description>📌 이진 검색 트리 💡 이진 검색 트리(Binary Search Trees) 히프의 문제점
임의의 데이터를 갖는 노드를 삭제할 경우의 시간 복잡도 : O(N) 트리에서 특정 데이터를 갖는 노드를 검색하는 시간 복잡도 : O(N) 이진 검색 트리란?
트리 내에서 특정 데이터(Key 값) 을 갖는 노드를 효율적으로 검색 O(Log N), 하지만 정렬된 상태를 유지해야한다. 이진 검색 트리의 정의
모든 노드는 유일한 키 값을 가지고 있다. 왼쪽 서브 트리에 저장된 키 값 &amp;lt; 루트 노드의 키 값 오른쪽 서브 트리에 저장된 키 값 &amp;gt; 루트 노드의 키 값 양쪽 서브 트리도 이진 검색 트리이다.</description>
    </item>
    <item>
      <title>[CS] 15.히프의 개념과 응용</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-15.%ED%9E%88%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9D%91%EC%9A%A9/</link>
      <pubDate>Sun, 17 Jul 2022 03:18:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-15.%ED%9E%88%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9D%91%EC%9A%A9/</guid>
      <description>📌 히프의 개념과 응용 💡 히프(Heap)의 정의 최대 트리와 최대 히프
최대 트리(Max Tree) 트리의 모든 노드에 대해서 노드의 데이터 값이 자식 노드의 데이터 값보다 크거나 같은 트리 최대 히프(Max Heap) 최대트리 이면서, 완전 이진트리. 최소 트리와 최소 히프
최소 트리(Min Tree) 트리의 모든 노드에 대해서 노드의 데이터 값이 자식 노드의 데이터 값다 작거나 같은 트리 최소 히프(Min Heap) 최소트리 이면서, 완전 이진트리. 최대 히프의 root 노드는 항상 모든 노드들보다 큰 값을 가지고 있다.</description>
    </item>
    <item>
      <title>[CS] 14.스레드 이진트리</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-14.%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/</link>
      <pubDate>Sun, 17 Jul 2022 02:41:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-14.%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/</guid>
      <description>📌 스레드 이진트리 💡 스레드 이진트리(Threaded Binary Tree) 스레드 이진트리의 기본 개념 n개의 노드를 갖는 이진 트리에는 2n 개의 링크가 존재한다. 2n 개의 링크 중에 n+1 개의 링크 값은 null이다. null 링크를 다른 노드에 대한 pointer 로 대체한다. (= Threads) 니는 루트를 제외한 모든 노드는 부모 노드가 있기 때문에 트리의 링크 수는 n-1 개이다. 스레드의 이용 ptr -&amp;gt; left_child = NULL 일 경우, ptr -&amp;gt; left_child 를 ptr의 중위행선자를 가리키도록 변경한다.</description>
    </item>
    <item>
      <title>[CS] 13.이진트리의 추가 연산</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-13.%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%B6%94%EA%B0%80-%EC%97%B0%EC%82%B0/</link>
      <pubDate>Fri, 15 Jul 2022 00:57:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-13.%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%B6%94%EA%B0%80-%EC%97%B0%EC%82%B0/</guid>
      <description>📌 이진트리의 추가 연산 💡 이진트리의 추가 연산 추가 연산의 종류
이진트리의 복사 이진트리가 동일한지 검사 이진트리의 노드 수 계산 이진트리의 단말 노드 수 계산 이진트리의 모든 노드들을 모두 한번씩 다 방문해야 한다.
트리의 모든 노드들을 방문할 필요성
이진트리의 순회 알고리즘 등을 응용한다. 💡 이진트리의 복사 문제 설명 입력 이진트리의 노드 구조와 동일한 새로운 이진트리를 생성하고 루트 노드의 주소 반환 후위순회 알고리즘을 사용한다. 💡 이진트리의 복사 알고리즘 struct node *copy(struct node *original){ # original 트리를 복사한 새로운 이진트리를 반환한다.</description>
    </item>
    <item>
      <title>[CS] 12.이진트리의 순회</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-12.%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8C/</link>
      <pubDate>Tue, 12 Jul 2022 14:37:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-12.%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8C/</guid>
      <description>📌 이진트리의 순회 💡 이진트리순회(Binary Tree Traversal) 문제 정의
이진 트리의 모든 노드를 한번씩 방문한다. 트리에 있는 노드의 순서를 결정한다. 순회방법
중위순회(L-V-R) 전위순회(V-L-R) 후위순회(L-R-V) 💡 중위순회 void inorder(struct link *ptr){ if(ptr){ inorder(ptr -&amp;gt; left_child); printf(&amp;#34;%d&amp;#34;, ptr -&amp;gt; data); inorder(ptr -&amp;gt; right_child); } } 💡 전위순회 void preorder(struct link *ptr){ if(ptr){ printf(&amp;#34;%d&amp;#34;, ptr -&amp;gt; data); preorder(ptr -&amp;gt; left_child); preorder(ptr -&amp;gt; right_child); } } 💡 후위순회 void postorder(struct link *ptr){ if(ptr){ postorder(ptr -&amp;gt; left_child); postorder(ptr -&amp;gt; right_child); printf(&amp;#34;%d&amp;#34;, prt -&amp;gt; data); } } 💡 이진트리 순회의 예 💡 이진트리 그리기 순회 순서를 이용하여 이진트리를 계산하여 그리기.</description>
    </item>
    <item>
      <title>[CS] 11. 트리와 이진트리의 개념</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-11.-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EA%B0%9C%EB%85%90/</link>
      <pubDate>Tue, 12 Jul 2022 14:21:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-11.-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EA%B0%9C%EB%85%90/</guid>
      <description>📌 트리와 이진트리의 개념 💡 트리의 개념 트리란?
계층적 구조의 자료를 표현할 때 사용 ex) 가계도, 회사의 조직도, 폴더 구조 등 트리의 정의
하나 이상의 노드로 이루어진 유한 집합 Root(루트) 라고 하는 노드가 하나 존재한다. 나머지 노드들은 n(n &amp;gt;= 0) 개의 집합 T[1], &amp;hellip; ,T[n]으로 분할 이처럼 분할된 트리를 루트의 서브트리라고 한다. 💡 트리에 관련된 용어들 Level 1 : 노드의 차수(Degree), 트리의 차(Degree) Level 2 : 단일노드(Leaf node or Terminal node) Level 3 : 부모노드, 자식노드, 형제노드 Level 4 : 조상노드, 자손노드, level, 트리의 높이 or 깊이 💡 이진트리의 개념 이진트리(Binary Tree)란?</description>
    </item>
    <item>
      <title>[CS] 10.이중 연결 리스트</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-10.%EC%9D%B4%EC%A4%91-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8/</link>
      <pubDate>Tue, 12 Jul 2022 13:50:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-10.%EC%9D%B4%EC%A4%91-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8/</guid>
      <description>📌 이중 연결 리스트 💡 이중 연결 리스트의 개념 이중 연결 리스트(Double Linked List)란?
한 노드에 두 개의 Link 가 저장 이중 연결 리스트는 양방향으로 이동가능 단일 연결 리스트의 경우, 한 방향으로만 이동이 가능. struct node{ struct node *llink; // 이전 노드 포인트 int data; struct node *rlink; // 다음 노드 포인트 💡 이중 연결 리스트의 종류 체인
처음 노드의 llink와 마지막 노드의 rlink는 NULL ptr = ptr -&amp;gt; llink -&amp;gt; rlink = ptr -&amp;gt; rlink -&amp;gt; llink 원형 이중 연결 리스트</description>
    </item>
    <item>
      <title>[CS] 9. 추가적인 리스트 연산</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-9.-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%97%B0%EC%82%B0/</link>
      <pubDate>Tue, 12 Jul 2022 13:31:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-9.-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%97%B0%EC%82%B0/</guid>
      <description>📌 추가적인 리스트 연산 💡 추가적인 리스트 연산들 단일 연결 리스트(Chain) 에 대한 연산
체인의 방향을 반대로 : invert() 두 개의 체인을 통합 : concatenate() 원형 리스트에 대한 연산
원형 연결리스트의 길이를 계산하는 연산 : length() 원형 연결리스트의 제일 앞에 새로운 노드 삽입 : insert_front() 💡 Invert 함수 포인터 3개를 사용해 가리키는 포인터를 변경해준다. lead, middle, tail 세 개의 포인터를 사용한다고 하면, return 값은 middle 이다. 💡 concatenate 함수 A 체인 혹은 B 체인이 NULL 일 경우, 나머지를 반환한다.</description>
    </item>
    <item>
      <title>[CS] 8. 원형 연결리스트</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-8.-%EC%9B%90%ED%98%95-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/</link>
      <pubDate>Sun, 10 Jul 2022 05:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-8.-%EC%9B%90%ED%98%95-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/</guid>
      <description>
📌 원형 연결리스트(Circular Linked List) 💡 원형 연결리스트의 개념 원형 연결리스트란? 마지막 노드의 link 가 처음 노드를 가리키는 연결리스트 chain : 마지막 노드의 link가 null 인 연결리스트 원형 연결리스트 체인 💡 헤드 노드 노드가 없는 원형 연결리스트 -&amp;gt; Head Node 💡 다항식 더하기 (원형 연결 리스트) 지수를 비교하여 덧셈을 한다. 지수항이 둘 모두 -1이 된다면 연산을 종료한다. </description>
    </item>
    <item>
      <title>[CS] 7. 연결리스트를 이용한 다항식의 구현</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-7.-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%95%AD%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84/</link>
      <pubDate>Sun, 10 Jul 2022 04:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-7.-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%95%AD%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84/</guid>
      <description>📌 연결리스트를 이용한 다항식의 구현 💡 다항식의 연결리스트 표현 다항식의 구조체 struct poly{ int coef; // 계수 int expon; // 지수 struct poly *link; // 링크 }*a, *b, *c 💡 다항식의 덧셈 알고리즘 d = a + b
각 다항식 최고차 항부터 차례대로 비교하며 연산 최고차 항의 지수가 동일할 경우</description>
    </item>
    <item>
      <title>[CS] 6. 연결리스트의 개념</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-6.-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EA%B0%9C%EB%85%90/</link>
      <pubDate>Sun, 10 Jul 2022 03:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-6.-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EA%B0%9C%EB%85%90/</guid>
      <description>📌 연결리스트의 개념 💡 자기참조 구조체 동일한 타입의 구조체에 대한 포인터를 속성으로 포함하는 구조체 Link Node 구조체에 대한 포인터 -&amp;gt; 메모리의 주소를 가리키는 자료형 여러 개의 Node 구조체를 연결하는 역할 💡 연결리스트 단순 연결리스트(Singly Linked List)
자기 참조 구조체(Node)들의 연결 천번째 노드에 대한 포인터만 유지 리스트의 이름 = 첫번째 노드의 수조 이후 노드들은 구조체의 Link 포인터를 통해 참조 마지막 노드의 Link 포인터는 NULL로 설정한다. 다른 연결리스트
이중 연결 리스트(Doubly Linked List) 앞 뒤의 노드들의 정보를 가지고 있다.</description>
    </item>
    <item>
      <title>[CS] 5. 배열을 이용한 희소행렬의 표현</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-5.-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC%EC%9D%98-%ED%91%9C%ED%98%84/</link>
      <pubDate>Sun, 10 Jul 2022 02:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-5.-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC%EC%9D%98-%ED%91%9C%ED%98%84/</guid>
      <description>📌 배열을 이용한 희소행렬의 표현 💡 희소행렬 행렬의 표현 2차원 배열 : Array[MaxRows][MaxCols] 0이 많이 포함된 경우, 희소행렬이라고 한다. 0이 아닌 데이터의 수 &amp;lt; 0인 데이터의 수 만약 1000 * 1000 행렬에서 0이 아닌 원소가 10개라면, 메모리 낭비일 수 있다. 💡 희소행렬의 표현 동기 : 공간 낭비를 줄이자. &amp;lt;Row, Column, Value&amp;gt; 의 쌍을 저장 빠른 전치를 위해서 Row 의 오름차순으로 저장 희소행렬 -&amp;gt; 배열 맨 처음에 행렬의 정보기록 = (행, 열, 0이 아닌 데이터의 수) 💡 행렬의 전치 전치연산 (Transposing a Matrix) row &amp;amp; column 을 교환 &amp;lt;j, i, value&amp;gt; 를 희소행렬 M의 어디에 저장하는가?</description>
    </item>
    <item>
      <title>[CS] 4. 배열을 이용한 다항식의 표현</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-4.-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%95%AD%EC%8B%9D%EC%9D%98-%ED%91%9C%ED%98%84/</link>
      <pubDate>Sun, 10 Jul 2022 01:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-4.-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%95%AD%EC%8B%9D%EC%9D%98-%ED%91%9C%ED%98%84/</guid>
      <description>📌 배열을 이용한 다항식의 표현 💡 순서리스트 (Orderd List) 데이터들의 순서가 유지되는 집합
집합이란, 원소들의 모임, 순서를 중요시 하지 않음. 한 주의 요일들 섞여진 카드들 미국의 2차 세계 대전 참전 연도 스위스의 2차 세계 대전 참전 연도 (원소가 없는 집합도 순서리스트에 포함된다.) 💡 순서리스트의 연산 순서리스트에 적용 가능한 연산들 리스트 길이 연산 리스트의 모든 데이터들을 왼쪽에서 오른쪽으로 읽기 리스트로부터 i번째 데이터를 검색 리스트로부터 i번째 데이터를 교체 리스트의 i번째 위치에 새로운 데이터 추가 (i번째 이후에 있던 데이터는 한 칸씩 밀림) 리스트의 i번째 위치에 있는 데이터를 삭제 (i번째 이후에 있던 데이터는 한 칸씩 당겨짐) 💡 다항식 소개 순서리스트를 구현하는 방법 배열 : i번째 데이터를 배열 i에 저장 연결리스트 💡 C 언어에서 다항식 구현 방법 1 : 모든 지수의 계수들을 내림차순으로 저장</description>
    </item>
    <item>
      <title>[CS] 3. 배열과 구조체의 정의</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-3.-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%9D%98-%EC%A0%95%EC%9D%98/</link>
      <pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-3.-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%9D%98-%EC%A0%95%EC%9D%98/</guid>
      <description>📌 배열과 구조체의 정의 💡 배열의 정의 배열이란? 동일한 데이터 타입의 데이터들을 묶는 구조 메모리의 연속된 위치에 차례대로 저장 (Index, Data) 쌍의 집합
배열에 적용 가능한 연산 인덱스 i 번째에 저장된 데이터를 출력 인덱스 i 번째에 데이터 d 를 저장 배열의 저장된 데이터의 수는 얼마인가? 💡 구조체 구조체의 정의
하나 이상의 기본 자료형을 기반으로 사용자 정의 자료형을 만들 수 있는 문법요소 다양한 자료형을 포함한다. 구조체 비교
구조체의 내용이 동일한지를 검사하는 방법은 모든 속성이 같은지 하나씩 비교하는 것이다.</description>
    </item>
    <item>
      <title>[CS] 2. 알고리즘의 복잡도 계산</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-2.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%84%EC%82%B0/</link>
      <pubDate>Wed, 06 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-2.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%84%EC%82%B0/</guid>
      <description>📌 알고리즘의 복잡도 계산 💡 성능분석 주어진 문제를 해결
정확성
문서화
얼마나 주석을 잘 달았는가? / 관련 문서가 얼마나 잘 작성되었는가? 모듈화
함수를 얼마나 체계적으로 잘 나누었는가? 가독성
변수 또는 함수의 이름이 얼마나 의미있게 쓰였는가? 공간 효율성
시간 효율성
필수적인 요소 - 1, 2 좋은 프로그래밍의 습관 - 3, 4, 5 성능과 관련 - 6, 7 💡 성능 분석 VS 성능 측정 성능 분석 시뮬레이션, 복잡도 성능 측정 실제로 실행시켜서 실행 시간을 측정 💡 복잡도의 정의 공간 복잡도 : 프로그램 실행에 사용되는 메모리 시간 복잡도 : 프로그램 실행에 걸리는 시간 💡 시간복잡도 실행에 걸리는 시간(T[p]) = 컴파일 시간 + 실행 시간 컴파일 시간은 고정 and 한번만 필요 T[p]는 컴퓨터 사양에 따라 변화한다.</description>
    </item>
    <item>
      <title></title>
      <link>https://jxun-h.github.io/posts/data-structure/temp/</link>
      <pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/temp/</guid>
      <description></description>
    </item>
    <item>
      <title>[CS] 1. 자료구조의 정의와 알고리즘의 정의 및 표현</title>
      <link>https://jxun-h.github.io/posts/data-structure/cs-1.-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%A0%95%EC%9D%98-%EB%B0%8F-%ED%91%9C%ED%98%84/</link>
      <pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://jxun-h.github.io/posts/data-structure/cs-1.-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%A0%95%EC%9D%98-%EB%B0%8F-%ED%91%9C%ED%98%84/</guid>
      <description>📌 자료구조 💡 정의 문제해결을 위해 데이터를 조직하여 표현하는 방법 전화번호부 - List, Linked List, Tree 수강신청, 대기열 - Queue 지하철 노선도 - Graph 💡 중요성 주어진 문제의 특성에 맞는 자료구조를 선택한다. 프로그램의 개발이 쉽고 성능이 향상한다. 💡 추상 데이터 타입 (Abstract Data Type) 자료구조를 기술할 때 사용하는 방법
데이터 객체 및 연산명세와 데이터 객체 내부 표현양식 / 연산의 구현 내용을 분리
사용자가 원하는 서비스를 표현하는 부분과 서비스를 내부적으로 구현하는 부분을 분리하겠다.</description>
    </item>
  </channel>
</rss>
