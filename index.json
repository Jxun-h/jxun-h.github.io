[{"content":"\n📌 BOJ 1789 수들의 합 💡 조건 서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까? 첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다. 첫째 줄에 자연수 N의 최댓값을 출력한다. 수학, 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 1 200 실행결과 1 19 ⌨️ 문제 풀이 계산하고 있는 계산값(A), 정답(B), 더할 수(C)를 각각 변수로 만든다. while를 이용해 반복적인 계산을 한다.\nA += C 후, C += 1, B += 1 (2)번의 반복문은 A가 입력 받은 S 보다 작을때만 반복한다. while 의 조건에 해당되지 않아 반복문이 종료되었으면 조건에 맞게 출력한다. 만약 A가 S와 값이 같다면 ans를, 그게 아니라면 ans -1 을 출력한다. 🖥 소스 코드 from sys import stdin s = int(stdin.readline()) ans, res, num = 0, 0, 1 while res \u0026lt; s: res += num num += 1 ans += 1 print(ans if res == s else ans - 1) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1789-%EC%88%98%EB%93%A4%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 1789 수들의 합 💡 조건 서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까? 첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다. 첫째 줄에 자연수 N의 최댓값을 출력한다. 수학, 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 1 200 실행결과 1 19 ⌨️ 문제 풀이 계산하고 있는 계산값(A), 정답(B), 더할 수(C)를 각각 변수로 만든다. while를 이용해 반복적인 계산을 한다.\nA += C 후, C += 1, B += 1 (2)번의 반복문은 A가 입력 받은 S 보다 작을때만 반복한다.","title":"[BOJ] 1789 수들의 합 with Python"},{"content":"\n📌 BOJ 10419 지각 💡 조건 교수님의 지각시간 0이상의 정수 t와 수업을 일찍 마쳐주는 시간 s 사이에는 s = t**2 의 관계가 있다. 창영이가 궁금한 경우의 수 T(1 ≤ T ≤ 100)가 첫 번째 줄에 주어지고, 이어서 T 개의 줄에 수업시간 d(1 ≤ d ≤ 10,000, d는 정수)가 차례대로 주어진다. 수업시간에 따른 교수님이 지각할 수 있는 최대 시간 t를 정수로 구해서 출력한다. 지각할 수 있는 최대의 시간을 알아보는 문제 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 1 5 1 2 5 6 7 실행결과 1 0 1 1 2 2 ⌨️ 문제 풀이 지각할 수 있는 최대시간을 구하려면, 수업시간 d의 최대값이 얼마인지 확인해봐야한다. 지각할 수 있는 최대시간은 100부터 -1씩 줄여나가 i * 1 ** 2의 값이 d보다 같거나 작아질 때를 찾으면 된다. 만약 d = 1 이라면 0이 출력되어야 하기 때문에 ans의 값은 0으로 초기화를 한 뒤 계산한다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): d = int(stdin.readline()) ans = 0 for i in range(100, 0, -1): if i + i ** 2 \u0026lt;= d: ans = i break print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10419-%EC%A7%80%EA%B0%81-with-python/","summary":"📌 BOJ 10419 지각 💡 조건 교수님의 지각시간 0이상의 정수 t와 수업을 일찍 마쳐주는 시간 s 사이에는 s = t**2 의 관계가 있다. 창영이가 궁금한 경우의 수 T(1 ≤ T ≤ 100)가 첫 번째 줄에 주어지고, 이어서 T 개의 줄에 수업시간 d(1 ≤ d ≤ 10,000, d는 정수)가 차례대로 주어진다. 수업시간에 따른 교수님이 지각할 수 있는 최대 시간 t를 정수로 구해서 출력한다. 지각할 수 있는 최대의 시간을 알아보는 문제 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 1 5 1 2 5 6 7 실행결과 1 0 1 1 2 2 ⌨️ 문제 풀이 지각할 수 있는 최대시간을 구하려면, 수업시간 d의 최대값이 얼마인지 확인해봐야한다.","title":"[BOJ] 10419 지각 with Python"},{"content":"\n📌 BOJ 5692 팩토리얼 진법 💡 조건 팩토리얼 진법에서는 i번 자리의 값을 ai×i!로 계산한다. 즉, 팩토리얼 진법에서 719는 10진법에서 53과 같다. 그 이유는 7×3! + 1×2! + 9×1! = 53이기 때문이다. 입력은 여러 개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 최대 5자리인 팩토리얼 진법 숫자가 주어진다.\n입력의 마지막 줄에는 0이 하나 주어진다. 각 테스트 케이스에 대해서, 입력으로 주어진 팩토리얼 진법 숫자를 10진법으로 읽은 값을 출력한다. 수학 유형의 문제 🔖 예제 및 실행결과 예제 1 719 1 15 110 102 0 실행결과 1 53 1 7 8 8 ⌨️ 문제 풀이 입력 받은 숫자를 문자열로 변경한 뒤, 길이(l)를 구한다. 숫자를 한자리씩 순회하면서(i) i * l! 를 계산해 ans 에 더해준다. 🖥 소스 코드 from sys import stdin from math import factorial as fa while 1: n = int(stdin.readline()) if n == 0: break l = len(str(n)) ans = 0 for i in str(n): ans += fa(l) * int(i) l -= 1 print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-5692-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-%EC%A7%84%EB%B2%95-with-python/","summary":"📌 BOJ 5692 팩토리얼 진법 💡 조건 팩토리얼 진법에서는 i번 자리의 값을 ai×i!로 계산한다. 즉, 팩토리얼 진법에서 719는 10진법에서 53과 같다. 그 이유는 7×3! + 1×2! + 9×1! = 53이기 때문이다. 입력은 여러 개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 최대 5자리인 팩토리얼 진법 숫자가 주어진다.\n입력의 마지막 줄에는 0이 하나 주어진다. 각 테스트 케이스에 대해서, 입력으로 주어진 팩토리얼 진법 숫자를 10진법으로 읽은 값을 출력한다.","title":"[BOJ] 5692 팩토리얼 진법 with Python"},{"content":"\n📌 BOJ 5988 홀수일까 짝수일까 💡 조건 N개의 정수가 주어지면 홀수인지 짝수인지를 출력하는 프로그램을 작성하는 문제. N(1 \u0026lt;= N \u0026lt;= 100) N+1번째 줄에 걸쳐 홀수인지 짝수인지 확인할 정수 K (1 \u0026lt;= K \u0026lt;= 10^60)가 주어진다. N개의 줄에 걸쳐 한 줄씩 정수 K가 홀수라면 \u0026lsquo;odd\u0026rsquo;를, 짝수라면 \u0026rsquo;even\u0026rsquo;을 출력한다. 수학 유형의 문제 🔖 예제 및 실행결과 예제 1 2 1024 5931 실행결과 1 even odd ⌨️ 문제 풀이 각 숫자를 2로 나누어 나온 나머지가 0이면 even, 아니면 odd를 출력한다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): if int(stdin.readline()) % 2 == 0: print(\u0026#39;even\u0026#39;) else: print(\u0026#39;odd\u0026#39;) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-5988-%ED%99%80%EC%88%98%EC%9D%BC%EA%B9%8C-%EC%A7%9D%EC%88%98%EC%9D%BC%EA%B9%8C-with-python/","summary":"📌 BOJ 5988 홀수일까 짝수일까 💡 조건 N개의 정수가 주어지면 홀수인지 짝수인지를 출력하는 프로그램을 작성하는 문제. N(1 \u0026lt;= N \u0026lt;= 100) N+1번째 줄에 걸쳐 홀수인지 짝수인지 확인할 정수 K (1 \u0026lt;= K \u0026lt;= 10^60)가 주어진다. N개의 줄에 걸쳐 한 줄씩 정수 K가 홀수라면 \u0026lsquo;odd\u0026rsquo;를, 짝수라면 \u0026rsquo;even\u0026rsquo;을 출력한다. 수학 유형의 문제 🔖 예제 및 실행결과 예제 1 2 1024 5931 실행결과 1 even odd ⌨️ 문제 풀이 각 숫자를 2로 나누어 나온 나머지가 0이면 even, 아니면 odd를 출력한다.","title":"[BOJ] 5988 홀수일까 짝수일까 with Python"},{"content":"\n📌 BOJ 1676 팩토리얼 0의 개수 💡 조건 N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하는 문제. 첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500) 수학 유형의 문제 🔖 예제 및 실행결과 예제 1 10 실행결과 1 2 예제 2 3 실행결과 2 0 ⌨️ 문제 풀이 리스트에 팩토리얼 계산 값을 미리 넣어놓으면 쉽게 해결할 수 있다. N에 해당하는 값을 꺼내 맨 우측부터 좌측 방향으로 이동하며 0이 아닌 수가 나올 때까지 0의 개수가 몇 개인지 세면 된다. 🖥 소스 코드 from sys import stdin arr = [1, 2, 6, 24, 120] n = int(stdin.readline()) if n \u0026lt; 5: print(0) else: for i in range(6, 501): arr.append(arr[-1] * i) ans = 0 s = str(arr[n-1]) for i in range(len(s)-1, -1, -1): if s[i] == \u0026#39;0\u0026#39;: ans += 1 else: print(ans) break ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1676-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-0%EC%9D%98-%EA%B0%9C%EC%88%98-with-python/","summary":"📌 BOJ 1676 팩토리얼 0의 개수 💡 조건 N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하는 문제. 첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500) 수학 유형의 문제 🔖 예제 및 실행결과 예제 1 10 실행결과 1 2 예제 2 3 실행결과 2 0 ⌨️ 문제 풀이 리스트에 팩토리얼 계산 값을 미리 넣어놓으면 쉽게 해결할 수 있다. N에 해당하는 값을 꺼내 맨 우측부터 좌측 방향으로 이동하며 0이 아닌 수가 나올 때까지 0의 개수가 몇 개인지 세면 된다.","title":"[BOJ] 1676 팩토리얼 0의 개수 with Python"},{"content":"\n📌 BOJ 14469 소가 길을 건너간 이유 3 💡 조건 N마리의 소가 이 농장에 방문하러 왔다. 소가 도착한 시간과 검문받는 데 걸리는 시간은 소마다 다르다. (물론 같을 수도 있다.)\n두 소가 동시에 검문을 받을 수는 없다. 예를 들어, 한 소가 5초에 도착했고 7초 동안 검문을 받으면,\n8초에 도착한 그 다음 소는 12초까지 줄을 서야 검문을 받을 수 있다.\n모든 소가 농장에 입장하려면 얼마나 걸리는지 구하는 문제.\n첫 줄에 100 이하의 양의 정수 N이 주어진다.\n다음 N줄에는 한 줄에 하나씩 소의 도착 시각과 검문 시간이 주어진다. 각각 1,000,000 이하의 양의 정수이다.\n정렬, 그리디 유형의 문제\n🔖 예제 및 실행결과 예제 1 3 2 1 8 3 5 7 실행결과 1 15 ⌨️ 문제 풀이 기본 아이디어는 정렬부터 시작을 했다. 모든 소가 입장하려면 얼마나 걸리는지, 최소시간을 출력하는 문제이다.\n소가 모두 입장하는데에 걸리는 최소 시간을 찾으려면, 입장하는 번호를 기준으로 정렬을 해야한다.\n소가 도착한 시간과 검문 받는데 걸리는 시간은 같을 수 있으므로, lambda 로 정렬 시켰다.\n기준은 (소가 도착한 시간, 검문 받는 시간) 을 각각 오름차순으로 정렬했다.\n정렬된 리스트를 순회하면서, 만약 현재 흐른 시간(ans)가 소가 도착한 시간(s) 보다 작거나 같다면 ans에 s를 넣어준다.\n그 후 ans에 검문시간을 더해준다.\n(4)번에 예외되는 조건이라면 그냥 ans에 c를 더해주고 출력한다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] for _ in range(n): a, b = map(int, stdin.readline().split()) arr.append((a, b)) arr.sort(key=lambda x: (x[0], x[1])) ans = 0 for i in range(n): s, c = arr[i][0], arr[i][1] if ans \u0026lt;= s: ans = s ans += c else: ans += c print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14469-%EC%86%8C%EA%B0%80-%EA%B8%B8%EC%9D%84-%EA%B1%B4%EB%84%88%EA%B0%84-%EC%9D%B4%EC%9C%A0-3-with-python/","summary":"📌 BOJ 14469 소가 길을 건너간 이유 3 💡 조건 N마리의 소가 이 농장에 방문하러 왔다. 소가 도착한 시간과 검문받는 데 걸리는 시간은 소마다 다르다. (물론 같을 수도 있다.)\n두 소가 동시에 검문을 받을 수는 없다. 예를 들어, 한 소가 5초에 도착했고 7초 동안 검문을 받으면,\n8초에 도착한 그 다음 소는 12초까지 줄을 서야 검문을 받을 수 있다.\n모든 소가 농장에 입장하려면 얼마나 걸리는지 구하는 문제.\n첫 줄에 100 이하의 양의 정수 N이 주어진다.","title":"[BOJ] 14469 소가 길을 건너간 이유 3 with Python"},{"content":"\n📌 BOJ 12760 ","permalink":"https://jxun-h.github.io/posts/temp/temp/","summary":"\n📌 BOJ 12760 ","title":"[BOJ] 12760 with Python"},{"content":"\n📌 BOJ 1992 쿼드트리 💡 조건 주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 \u0026ldquo;0\u0026quot;이 되고, 모두 1로만 되어 있으면 압축 결과는 \u0026ldquo;1\u0026quot;이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못한다.\n왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 된다.\n이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하는 문제. 분할정복, 재귀 유형의 문제. 🔖 예제 및 실행결과 예제 1 8 11110000 11110000 00011100 00011100 11110000 11110000 11110011 11110011 실행결과 1 ((110(0101))(0010)1(0001)) ⌨️ 문제 풀이 분할정복의 개념으로 해결을 할 수 있는 문제이다. n 을 2씩 나누어 재귀를 통해 큰 단위에서 작은 단위로 가는 방식으로 해결했다. check() 함수로 각 좌표를 기준으로 mode 만큼 떨어진 좌표까지 숫자가 같은지 탐색한다.\n만약 같지 않다면, 괄호를 넣고 재귀한다. 같다면 1혹은 0을 넣어준다. 좌표는 네 방향이다. 재귀를 할 때마다 mode는 두 배씩 줄어든다. 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) n = int(stdin.readline()) arr, ans = [], \u0026#39;\u0026#39; for i in range(n): arr.append(list(map(int, list(stdin.readline().rstrip())))) def check(x, y, mode): for i in range(x, x + mode): for j in range(y, y + mode): if arr[x][y] != arr[i][j]: return False return True def solve(x, y, mode): global ans if check(x, y, mode): if arr[x][y] == 1: ans += \u0026#39;1\u0026#39; else: ans += \u0026#39;0\u0026#39; else: ans += \u0026#39;(\u0026#39; solve(x, y, mode // 2) solve(x, y + mode // 2, mode // 2) solve(x + mode // 2, y, mode // 2) solve(x + mode // 2, y + mode // 2, mode // 2) ans += \u0026#39;)\u0026#39; solve(0, 0, n) print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1992-%EC%BF%BC%EB%93%9C%ED%8A%B8%EB%A6%AC-with-python/","summary":"📌 BOJ 1992 쿼드트리 💡 조건 주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 \u0026ldquo;0\u0026quot;이 되고, 모두 1로만 되어 있으면 압축 결과는 \u0026ldquo;1\u0026quot;이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못한다.\n왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 된다.\n이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다.","title":"[BOJ] 1992 쿼드트리 with Python"},{"content":"\n📌최소 비용 신장트리 💡최소 비용 신장트리 정의\n가중치가 부여된 무방향 그래프에서 신장 트리의 비용\n가중치 : 두 vertex 사이의 거리 혹은 연결하는 비용\n= 신장트리를 구성하는 에지들의 비용의 합 최소 비용 신장트리 : 가장 비용이 적은 신장 트리 응용 분야\n도로 건설 : 도시를 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제\nex) 통신, 배관 최소 비용 신장트리 알고리즘\n최소 비용 신장트리 알고리즘 그래프 내에 존재하는 Edge들만 사용한다. 정점의 개수가 n일 때, n - 1개의 Edge들만 사용한다. 사이클을 형성하는 edge는 사용불가하다. 최소 비용 신장트리를 구하기 위한 알고리즘들 크루스칼 프림 솔린 💡크루스칼 알고리즘(Kruskal Algorithm) E log E 의 시간 복잡도를 가진다.\nHeap 을 이용하여 구현하는 것이 필요하다. 알고리즘의 개요 Edge들을 비용의 오름차순으로 정렬한다. 가장 비용이 적은 Edge부터 하나씩 선택한다. 선택된 Edge는 기존에 선택된 Edge들과 사이클을 형성하지 않을 경우에만 신장트리 T에 포함된다. 그래프 G가 연결되어 있으며, N(\u0026gt; 0)개의 정점이 존재하는 경우, 정확히 N-1개의 Edge가 선택된다. 💡프림 알고리즘(Prim Algorithm) 이미 선택된 것에서 나머지로 가는 것만 체크한다.\nPrim 알고리즘에서는 사이클 검사가 따로 필요하지 않는다. 알고리즘의 개요 하나의 정점만 갖는 트리 T에서 시작한다. T에 포함된 정점과 포함되지 않는 정점을 연결하는 Edge들 중에서 비용이 최소인 Edge를 T에 추가한다. 추가된 Edge의 vertex를 T에 포함한다.\nO(n * n) 희소 그래프 = 크루스칼 = 정점이 몇 개 없다면 사용\n완전 그래프 = 프림 = 정점이 많다면 사용\n💡솔린(Sollin) 알고리즘 알고리즘의 개요 단계별로 T에 포함시킬 여러 Edge들을 동시에 선택한다. 각 단계에서 선택된 엣지들은 그래프의 \u0026ldquo;신장 숲(Spanning Forest)\u0026rdquo; 구성 초기에는 Edge가 없으므로, forest에 정점 수만큼의 트리가 존재한다. 각 단계에서 forest에 있는 각 트리에 대해 하나의 에지를 선택한다.\n선택 기준 = 최소비용 두 개의 트리에서 동일한 edge를 선택할 수 있으므로, 중복된 Edge를 제거하는 절차가 필요하다. 하나의 트리만 남거나 혹은 추가할 Edge가 없을 경우 종료한다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-19.%EC%B5%9C%EC%86%8C-%EB%B9%84%EC%9A%A9-%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC/","summary":"📌최소 비용 신장트리 💡최소 비용 신장트리 정의\n가중치가 부여된 무방향 그래프에서 신장 트리의 비용\n가중치 : 두 vertex 사이의 거리 혹은 연결하는 비용\n= 신장트리를 구성하는 에지들의 비용의 합 최소 비용 신장트리 : 가장 비용이 적은 신장 트리 응용 분야\n도로 건설 : 도시를 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제\nex) 통신, 배관 최소 비용 신장트리 알고리즘\n최소 비용 신장트리 알고리즘 그래프 내에 존재하는 Edge들만 사용한다. 정점의 개수가 n일 때, n - 1개의 Edge들만 사용한다.","title":"[CS] 19.최소 비용 신장트리"},{"content":"\n📌 기초적인 그래프 연산들 💡깊이 우선 탐색(Depth First Search) DFS 알고리즘 출발 정점, v의 인접리스트부터 방문한다. v에 인접하면서 아직 방문하지 않은 정점 w를 선택한다. w를 시작점으로 하여 다시 DFS를 시작한다. 순환 알고리즘을 이용하여 구현한다.(재귀) 💡너비 우선 탐색(Breath First Search) BFS 알고리즘 출발 정점, v의 인접 리스트부터 방문한다. v에 인접한 모든 vertex부터 방문한다. 그 다음, v에 인접한 첫번째 vertex에 인접한 vertex 중에서\n아직 방문하지 않은 vertex 들을 차례대로 다시 방문한다.\n-\u0026gt; Queue 자료구조를 사용하여 구현 💡연결요소(Connected Component) 무방향성 그래프가 연결되어 있는지 검사한다. DFS, BFS를 호출하여 방문하지 않은 정점이 있는지 검사한다. 💡신장트리(Spanning Tree) 신장트리 : 그래프 G에 포함된 예시들로 구성되며, G의 모든 정점을 포함한 트리이다.\n싸이클 제외, 정점 N개 -\u0026gt; 엣지 (N - 1)개 DFS or BFS로 신장트리를 구성한다.\nDFST(깊이 우선 신장 트리) BFST(너비 우선 신장 트리) 💡단절점(Articulation Points) 그래프 G의 정점 V에 연결된 Edge들을 모두 삭제할 경우,\nG가 두 개 이상의 연결요소로 분할되는 V 이중 연결 그래프(Biconnected Graph)\n단절점이 없는 Connectd Graph 이중 연결 요소(Biconnected component)\n연결 그래프 G에서 Maximal Biconnected Subgraph, H Maxiaml : 이중연결 되었으면서, H를 완전히 포함하는 부분 그래프가\nG에 존재하지 않는다. 어떤 노드를 연결했을 때, 단절점이 생길 수 있다.\n","permalink":"https://jxun-h.github.io/posts/data-structure/cs-18.%EA%B8%B0%EC%B4%88%EC%A0%81%EC%9D%B8-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%97%B0%EC%82%B0%EB%93%A4/","summary":"📌 기초적인 그래프 연산들 💡깊이 우선 탐색(Depth First Search) DFS 알고리즘 출발 정점, v의 인접리스트부터 방문한다. v에 인접하면서 아직 방문하지 않은 정점 w를 선택한다. w를 시작점으로 하여 다시 DFS를 시작한다. 순환 알고리즘을 이용하여 구현한다.(재귀) 💡너비 우선 탐색(Breath First Search) BFS 알고리즘 출발 정점, v의 인접 리스트부터 방문한다. v에 인접한 모든 vertex부터 방문한다. 그 다음, v에 인접한 첫번째 vertex에 인접한 vertex 중에서\n아직 방문하지 않은 vertex 들을 차례대로 다시 방문한다.","title":"[CS] 18.기초적인 그래프 연산들"},{"content":"\n📌 BOJ 1890 점프 💡 조건 N×N 게임판에 수가 적혀져 있다.\nN (4 ≤ N ≤ 100)\n이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.\n각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다.\n칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.\n반드시 오른쪽이나 아래쪽으로만 이동해야 한다.\n0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다.\n한 번 점프를 할 때, 방향을 바꾸면 안 된다.\n즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.\n가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 문제.\nDP 유형의 문제\n🔖 예제 및 실행결과 예제 4 2 3 3 1 1 2 1 3 1 2 3 1 3 1 1 0 실행결과 3 ⌨️ 문제 풀이 경로의 개수를 구하는 문제이다. 이 문제는 하나하나 경로를 살펴보기 위해서 dfs를 사용할 경우, 시간복잡도가 매우 크게 나온다.\n다이나믹프로그래밍 알고리즘을 이용하여 문제를 해결해야하는데, 우리는 문제에서 아래와 같은 조건에 주목을 해서 풀면 쉽게 생각해볼 수 있는 문제이다.\n칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.\n반드시 오른쪽이나 아래쪽으로만 이동해야 한다.\n0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다.\n(0, 0)에서 시작해 (n - 1, n - 1) 까지 가는 경우의 수를 DP 리스트에 저장해나가면서 반복문을 통해 문제를 해결한다면,\n시간복잡도는 약 O(N * N) 이 나온다. 최악의 경우를 고려하더라도 최대 약 10,000 정도밖에 안걸린다.\nDP 리스트는 n * n 크기의 리스트로 만들고, (0, 0)은 1로 초기화한다.\n2중 for 문을 사용하여, 만약 현재 위치한 곳이 (n - 1, n - 1) 이라면 dp[i][j]를 출력하면 된다.\n(4)번의 경우가 아니라면, (i, j)에 해당하는 arr의 값을 cur 라는 변수에 저장한다.\n현재 위치인 (i, j) 에서 우측으로 cur 만큼 이동을 할 수 있다면, dp[i][j + cur]에 dp[i][j]를 더해준다.\n현재 위치인 (i, j) 에서 하단으로 cur 만큼 이동을 할 수 있다면, dp[i + cur][j]에 dp[i][j]를 더해준다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if i == n - 1 and j == n - 1: print(dp[i][j]) break cur = arr[i][j] if j + cur \u0026lt; n: dp[i][j + cur] += dp[i][j] if i + cur \u0026lt; n: dp[i + cur][j] += dp[i][j] ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1890-%EC%A0%90%ED%94%84-with-python/","summary":"📌 BOJ 1890 점프 💡 조건 N×N 게임판에 수가 적혀져 있다.\nN (4 ≤ N ≤ 100)\n이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.\n각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다.\n칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.\n반드시 오른쪽이나 아래쪽으로만 이동해야 한다.\n0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다.","title":"[BOJ] 1890 점프 with Python"},{"content":"\n📌 BOJ 1722 순열의 순서 💡 조건 1부터 N까지의 수를 임의로 배열한 순열은 총 N! = N×(N-1)×…×2×1 가지가 있다.\n임의의 순열은 정렬을 할 수 있다.\n예를 들어 N=3인 경우 {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}의 순서로 생각할 수 있다.\nN이 주어지면, 아래의 두 소문제 중에 하나를 풀어야 한다.\nk가 주어지면 k번째 순열을 구하고, 임의의 순열이 주어지면 이 순열이 몇 번째 순열인지를 출력하는 문제\n첫째 줄에 N(1 ≤ N ≤ 20)이 주어진다.\n1인 경우 k(1 ≤ k ≤ N!)를 입력받고, 2인 경우 임의의 순열을 나타내는 N개의 수를 입력받는다.\nN개의 수에는 1부터 N까지의 정수가 한 번씩만 나타난다.\n수학, 조합론 유형의 문제\n🔖 예제 및 실행결과 예제 1 4 1 3 실행결과 1 1 3 2 4 예제 2 4 2 1 3 2 4 실행결과 2 3 ⌨️ 문제 풀이 N이 최대 20까지라면, 브루트포스로 풀이했을 때 시간복잡도가 최악의 경우 20! = 2,432,902,008,176,640,000 가지의 경우의 수가 나온다.\n무조건 시간초과가 날 수 밖에 없다.\n입력 순열이 만약 [3, 4, 1, 2]가 입력되었다고 가정해보자.\n1로 시작하는 [1, ?, ? ,?]와 같은 순열의 경우의 개수는 3!이다.\n2로 시작하는 [2, ?, ? ,?]와 같은 순열의 경우의 개수는 3!이다.\n입력을 받은 순열은 3으로 시작한다. 따라서\n[3, 1, ?, ?]로 시작하는 순열의 경우의 개수는 2!이다.\n[3, 2, ?, ?]로 시작하는 순열의 경우의 개수는 2!이며, 3도 마찬가지이다.\n이 후의 개수는 [3, 4, 1, ?] 1개.\n2번 부터 4번의 과정을 더하면 몇 번째 순열인지 알 수가 있다.\n이와 같은 과정을 반대로 진행하면 K번째 순열을 출력할 수 있다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) data = list(map(int, stdin.readline().split())) cache = {} def find_permutations(n): if n in cache: return cache[n] elif n \u0026lt;= 1: return 1 else: cache[n] = n * find_permutations(n - 1) return cache[n] if data[0] == 1: k = data[1] arr = [x for x in range(1, n + 1)] ans = [] for i in range(n): x = find_permutations(n - 1 - i) step = (k - 1) // x ans.append(arr[step]) arr.remove(arr[step]) k -= x * step print(*ans) else: input_permu = data[1:] sort_permu = sorted(data[1:]) ans = 1 for i in range(n): step = sort_permu.index(input_permu[i]) sort_permu.remove(input_permu[i]) x = find_permutations(n - 1 - i) ans += x * step print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1722-%EC%88%9C%EC%97%B4%EC%9D%98-%EC%88%9C%EC%84%9C-with-python/","summary":"📌 BOJ 1722 순열의 순서 💡 조건 1부터 N까지의 수를 임의로 배열한 순열은 총 N! = N×(N-1)×…×2×1 가지가 있다.\n임의의 순열은 정렬을 할 수 있다.\n예를 들어 N=3인 경우 {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}의 순서로 생각할 수 있다.\nN이 주어지면, 아래의 두 소문제 중에 하나를 풀어야 한다.\nk가 주어지면 k번째 순열을 구하고, 임의의 순열이 주어지면 이 순열이 몇 번째 순열인지를 출력하는 문제","title":"[BOJ] 1722 순열의 순서 with Python"},{"content":"\n📌 BOJ 1081 합 💡 조건 L보다 크거나 같고, U보다 작거나 같은 모든 정수의 각 자리의 합을 구하는 문제.\n0 ≤ L ≤ U ≤ 2,000,000,000\n수학 유형의 문제\n🔖 예제 및 실행결과 예제 24660 308357171 실행결과 11379854844 ⌨️ 문제 풀이 가장 먼저 문제를 보며 주목해야할 부분은 L과 U의 범위이다.\nL과 U의 범위는 최대 20억까지로, 일일히 검사했을 때 최악의 경우에는 0부터 20억까지의 모든 수를 검사해야하기 때문에\n문제에서 주어진 2초라는 시간 안에 절대 해결할 수가 없다.\n(1)번에서 정리한대로, 우리는 L과 U의 범위를 입력받아 일일히 숫자 하나씩 검사하는 방법을 피해 각 숫자의 자릿수를 더해 답을 출력해야 한다.\nL, U 를 입력받아 L보다 크거나 같고, U보다 작거나 같은 모든 정수의 각 자리의 합을 구하는 것은 어느 일정 구간에 대한 합을 구하는 것과 같다.\n구간합의 개념으로 생각을 해보자.\nL - 1 까지 등장한 0~9의 개수를 K, U까지 등장한 0-9 의 개수를 P 라고 했을 때,\n(P - K) 는 L 부터 U 의 범위에 해당하는 0-9의 개수라는 것을 의미한다.\nL = 1000, U = 1234 라고 가정했을 때, 접근 방법은 두가지가 있다.\n1의 자리에서부터 0~9까지의 등장 횟수를 count 할 것인가? 가장 높은 자리에서부터 0-9까지의 등장 횟수를 count 할 것인가?\n일단 본인의 풀이는 1의 자리에서부터 0~9까지의 숫자를 count 했다. 먼저, 1의 자리에 어떤 숫자가 몇 번 등장하는지에 대해서 살펴보자. 먼저 0부터 살펴보자.\n10 ~ 90 : 10\n100 ~ 190, 200 ~ 290, \u0026hellip; ,900~990 : 90\n1000 ~ 1090, 1100 ~ 1190 : 20\n1200 ~ 1230 : 4\n총 124 회\n1의 자리에서 5가 몇번 등장할까?\n15 ~ 95 : 10\n105 ~ 195, 205 ~ 295, \u0026hellip; ,905 ~ 995 : 90\n1005 ~ 1095, 1105 ~ 1195 : 20\n1205 ~ 1225 : 3\n총 123 회\n10의 자리에서 4는 몇 번 등장할까?\n40 ~ 49 : 10\n140 ~ 149, 240 ~ 249, \u0026hellip;, 940 ~ 949 : 90\n1040 ~ 1049, 1140 ~ 1149 : 20\n총 120 회.\n여기서 알 수 있는 것은, 우리는 이렇게 숫자의 자릿수 별로 각 숫자가 몇번씩 등장하는지 계산할 수 있다는 것이다.\n또한, 10의 자리에서 4가 몇 번 등장하는지를 셀 때에는 1234를 넘을 수 없기 때문에 1149까지 세어 120회가 나왔다.\n이제 소스코드 로직을 따라서 이해하면 쉽다.\nn_arr 은 입력받은 n - 1 까지 0 부터 9의 등장횟수를 저장한다.\nm_arr 은 입력받은 m까지 0 부터 9의 등장횟수를 저장한다.\n가장 먼저 1의 자리수에서 0~9까지의 등장횟수를 저장할 것이기 때문에 point 를 1로,\nn을 -1 해준뒤 n이 0이 아닐 때까지 while 반복을 한다.\nn % 10 이 9가 아닌 경우, n 의 각 자릿수의 숫자에 해당하는 n1081 합_arr 원소값에 point를 더해준다.\n예를 들면, 입력받은 n이 1234 부터 시작하여 1233, 1232, 1231, 1230 까지 각 자릿수에 해당하는 숫자를 point 만큼 올려준다.\nn \u0026lt; 10 인 경우는 오른쪽 끝 부터 확인하여 n //= 10 을 반복해 한자리수가 남았을 때 처리해주는 로직이다. 이 경우는 거의 마지막에 해당하는 로직이니 이후에 알아볼 것이다.\nn \u0026gt;= 10 인 경우는 만약 1234 라면 1의 자리를 볼 때, 4 이하는 124번이 등장하며, 5 이상은 123번이 등장한다. 이는 (n // 10 + 1) * point 로 표현할 수 있다.\n다시 n \u0026lt; 10 인 경우를 보자면, 0부터 n까지의 각 자리에 대해서 point 만큼씩 더해주고, 0인 경우는 point 를 빼준다. 다른 숫자는 약 130회 등장하는 경우, 0은 120회 등장한다. 직접 계산해보자.\n0부터 n - 1 까지 0~9까지의 등장횟수를 n1081 합_arr에 저장했다면, 이제 0부터 m까지 0~9 등장횟수를 m1081 합_arr 에 같은 로직으로 저장한다.\n이후는 각자리의 합을 더하는 작업이다.\nn1081 합_arr, m1081 합_arr 을 순회하면서 각 등장횟수 (m1081 합_arr1081 합[i1081 합] - n1081 합_arr1081 합[i1081 합]) 에 i 를 곱해 ans 에 더해준다.\n이는 각 자리수를 더해주는 것과 같다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) n_arr = [0 for _ in range(10)] m_arr = [0 for _ in range(10)] n -= 1 point = 1 while n != 0: while n % 10 != 9: for i in str(n): n_arr[int(i)] += point n -= 1 if n \u0026lt; 10: for i in range(n + 1): n_arr[i] += point n_arr[0] -= point break else: for i in range(10): n_arr[i] += (n // 10 + 1) * point n_arr[0] -= point point *= 10 n //= 10 point = 1 while m != 0: while m % 10 != 9: for i in str(m): m_arr[int(i)] += point m -= 1 if m \u0026lt; 10: for i in range(m + 1): m_arr[i] += point m_arr[0] -= point break else: for i in range(10): m_arr[i] += (m // 10 + 1) * point m_arr[0] -= point point *= 10 m //= 10 ans = 0 for i in range(10): ans += (m_arr[i] - n_arr[i]) * i print(ans) 💾 느낀점 수학적 사고능력이 필요한 문제였다. 스스로는 이해하기 어려워, 나에게 알고리즘 적으로 도움을 주는 스승이자 동생에게 도움을 받아 이해했다.\n각 자리수 별로 0~9의 숫자가 몇 번 등장하는지 계산하는 것은 매우 헷갈리는 작업이었다.\n0의 등장횟수는 반드시 다시한번 체크하고 계산해보아야한다. 그렇지 않으면 1019 번 문제를 틀리게 된다.\n","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1081-%ED%95%A9-with-python/","summary":"📌 BOJ 1081 합 💡 조건 L보다 크거나 같고, U보다 작거나 같은 모든 정수의 각 자리의 합을 구하는 문제.\n0 ≤ L ≤ U ≤ 2,000,000,000\n수학 유형의 문제\n🔖 예제 및 실행결과 예제 24660 308357171 실행결과 11379854844 ⌨️ 문제 풀이 가장 먼저 문제를 보며 주목해야할 부분은 L과 U의 범위이다.\nL과 U의 범위는 최대 20억까지로, 일일히 검사했을 때 최악의 경우에는 0부터 20억까지의 모든 수를 검사해야하기 때문에\n문제에서 주어진 2초라는 시간 안에 절대 해결할 수가 없다.","title":"[BOJ] 1081 합 with Python"},{"content":"\n📌 BOJ 1005 ACM Craft 💡 조건 서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.\n이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다.\n즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다.\n매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.\n프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다!\n최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다.\n매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다.\n백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 문제.\n첫째 줄에는 테스트케이스의 개수 T가 주어진다.\n첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다)\n둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, \u0026hellip;, DN이 공백을 사이로 주어진다.\n셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다)\n마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.\n2 ≤ N ≤ 1000\n1 ≤ K ≤ 100,000\n1 ≤ X, Y, W ≤ N\n0 ≤ Di ≤ 100,000, Di는 정수\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 2 4 4 10 1 100 10 1 2 1 3 2 4 3 4 4 8 8 10 20 1 5 8 7 1 43 1 2 1 3 2 4 2 5 3 6 5 7 6 7 7 8 7 실행결과 120 39 ⌨️ 문제 풀이 문제를 요약해보자면, 아래와 같다.\n각 테스트 케이스마다 건물을 지을 수 있는 순서는 다르다. 백준이가 이기기 위해서는 특정 건물을 지어야 승리가 가능하다. 특정 건물을 짓기 위해서는 선행되는 건물을 지을 필요가 있다. 간단하게 정리를 해보면 우리는 건설순서가 정해져 있는 건물을 차례로 건설하면서, W번 건물을 지을 때까지의 최소 시간을 구해야한다.\n이러한 문제에 사용할 수 있는 알고리즘은 위상정렬인데, 위상정렬의 개념고 위에 써놓은 것과 개념이 크게 다르지 않다.\n위상정렬이란, 순서가 정해져있는 작업을 차례로 수행해야할 때 그 순서를 결정해주기 위해서 사용하는 알고리즘이다.\n건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K 를 입력받아, 위상정렬 알고리즘에 필요한 indegree 리스트를 n + 1 개 만들어준다.\n또한 N + 1개의 노드를 가진 그래프도 생성한다.\n각 건물을 건설하는데에 필요한 시간을 입력받은 후, 건설순서를 입력받아 그래프에 입력한다.\n만약 a, b를 입력 받았다면, graph[a].append(b) 이며 indegree[b] += 1 이다.\nb 건물을 건설하기 위해서는 a 건물을 건설해야한다는 뜻이기 때문에 +1 이 되는 것이다.\n이후, W 를 입력받아 위상정렬 알고리즘의 로직이 있는 topology_sort() 함수에 W를 넘겨준다.\n위상정렬 알고리즘에서는, indegree 리스트에서의 값이 0인 것을 q에 먼저 넣고 처리를 한다.\nindegree 리스트에서의 값은 해당 건물이 지어지기 위해서는 먼저 지어져야할 건물이 있다는 것을 의미하기 때문이다.\n위상정렬 함수에서는 DP 리스트를 만들어 사용자가 어떤 건물을 지었을 때의 소요시간을 체크한다.\n큐에서 뺀 건물 번호(now) 를 기준으로 그래프를 따라 순회하면서, 순회하는 건물의 번호(node)에 해당하는 indegree의 값을 1씩 빼준다.\n그리고 DP[node] 에 해당하는 값을 DP[now] + 건설에 필요한 시간[node] 값과 비교해 가장 큰 값으로 갱신한다.\n이후, indegree[node] 의 값이 0 이라면 queue에 추가하고 반복한다.\nqueue 가 모두 빌 때까지 순회를 마쳤다면, DP[W] 의 값을 반환하고 출력한다.\nDP[W]의 값은 W 번 건물이 지어지는 최소 시간을 의미한다.\n🖥 소스 코드 from collections import deque from sys import stdin def topology_sort(w): q = deque() dp = [0 for _ in range(n + 1)] for i in range(1, n + 1): if indegree[i] == 0: q.append(i) dp[i] = arr[i] while q: now = q.popleft() for node in graph[now]: indegree[node] -= 1 dp[node] = max(dp[now] + arr[node], dp[node]) if indegree[node] == 0: q.append(node) return dp[w] for tc in range(int(stdin.readline())): n, m = map(int, stdin.readline().split()) indegree = [0] * (n + 1) graph = [[] for _ in range(n + 1)] arr = [0] + list(map(int, stdin.readline().split())) for _ in range(m): a, b = map(int, stdin.readline().split()) graph[a].append(b) indegree[b] += 1 w = int(stdin.readline()) print(topology_sort(w)) 💾 느낀점 위상정렬이란, 순서가 정해져있는 작업을 차례로 수행해야할 때 그 순서를 결정해주기 위해서 사용하는 알고리즘.\n이를 어떻게 사용하고, 응용해야할지 더 연습이 필요할 것 같다. 복잡해보이지만, 개념과 필요한 상황을 잘 이해한다면\n충분히 잘 사용할 수 있을 것 같은 느낌이다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1005-acm-craft-with-python/","summary":"📌 BOJ 1005 ACM Craft 💡 조건 서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.\n이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다.\n즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다.\n매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.","title":"[BOJ] 1005 ACM Craft with Python"},{"content":"\n📌 BOJ 17086 아기 상어 2 💡 조건 N×M 크기의 공간에 아기 상어 여러 마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 아기 상어가 최대 1마리 존재한다.\nN과 M(2 ≤ N, M ≤ 50)\n어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리이다.\n두 칸의 거리는 하나의 칸에서 다른 칸으로 가기 위해서 지나야 하는 칸의 수이고, 이동은 인접한 8방향(대각선 포함)이 가능하다.\n0은 빈 칸, 1은 아기 상어가 있는 칸이다.\n빈 칸과 상어의 수가 각각 한 개 이상인 입력만 주어진다.\n안전 거리가 가장 큰 칸을 구하는 문제.\nheapq, 우선순위 큐 유형의 문제\n🔖 예제 및 실행결과 예제 1 5 4 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 실행결과 1 2 예제 2 7 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 실행결과 2 2 ⌨️ 문제 풀이 문제에서 보면, N과 M이 각각 최대 50이기 때문에 최대 50 * 50 짜리 2차원 배열을 사용할 수 있다.\n1은 아기 상어이며, 0은 안전한 칸이다. 이 문제의 핵심은 우선순위 큐를 사용하는 것인데, 우선순위 큐란 무엇인가?\n우선순위 큐는 먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조이다.\n안전거리의 값을 우선순위로 두어 큐에 저장하면서 8 방향으로, 방문하지 않은 칸을 큐에 넣어준다.\n파이썬의 heapq 에서는 최소 힙(Min Heap)의 형태로 데이터를 저장한다.\n최소 힙의 루드 노드는 모든 노드보다 작은 값을 가지고 있다.\nans 의 값을 -1로 초기화하고, board를 한칸씩 순회하면서 0인 경우에 solve() 함수에 좌표값을 넘겨준다.\nsolve() 함수에서는 heapq 를 사용해 BFS를 수행하면서, 8 방향을 탐색한다.\n안전거리는 어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리 이다.\n(4)번처럼 탐색을 하면 가장 가까운 아기 상어의 칸을 탐색할 수 있으며, 힙 큐에서 뽑은 좌표의 값이 아기 상어일 경우, dist를 반환한다.\n반환된 dist를 ans와 비교해 더 큰 값으로 갱신한 후, board 를 모두 순회했다면 ans를 출력한다.\n🖥 소스 코드 from sys import stdin import heapq n, m = map(int, stdin.readline().split()) arr, shark = [], [] dx, dy = [1, 0, 0, -1, 1, -1, 1, -1], [0, 1, -1, 0, 1, -1, -1, 1] ans = -1 for i in range(n): data = list(map(int, stdin.readline().split())) arr.append(data) for j in range(m): if data[j] == 1: shark.append((i, j)) def solve(x, y): q = [] heapq.heappush(q, (0, x, y)) visited = set() visited.add((x, y)) while q: dist, x, y = heapq.heappop(q) if arr[x][y] == 1: return dist for i in range(8): nx, ny = dx[i] + x, dy[i] + y if 0 \u0026lt;= nx \u0026lt; n and 0 \u0026lt;= ny \u0026lt; m: if (nx, ny) not in visited: heapq.heappush(q, (dist + 1, nx, ny)) visited.add((nx, ny)) for i in range(n): for j in range(m): if arr[i][j] == 0: res = solve(i, j) if res \u0026gt; ans: ans = res print(ans) 💾 느낀점 BFS 알고리즘을 Heapq를 사용해 8방향으로 탐색하고 결과를 도출하는 것에 대해 좋은 경험을 쌓을 수 있는 문제였던 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-17086-%EC%95%84%EA%B8%B0-%EC%83%81%EC%96%B4-2-with-python/","summary":"📌 BOJ 17086 아기 상어 2 💡 조건 N×M 크기의 공간에 아기 상어 여러 마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 아기 상어가 최대 1마리 존재한다.\nN과 M(2 ≤ N, M ≤ 50)\n어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리이다.\n두 칸의 거리는 하나의 칸에서 다른 칸으로 가기 위해서 지나야 하는 칸의 수이고, 이동은 인접한 8방향(대각선 포함)이 가능하다.\n0은 빈 칸, 1은 아기 상어가 있는 칸이다.","title":"[BOJ] 17086 아기 상어 2 with Python"},{"content":"\n📌 그래프의 개념과 표현 💡 그래프 소개 그래프(Graph)란? 연결되어 있는 객체 간의 관계를 표현하는 자료구조 지하철 노선도, SNS 친구 관계, 컴퓨터 네트워크 💡 그래프 데이터 타입 그래프 G의 두가지 구성요소\nV(G) : G에 포함된 Vertex(정점)들의 집합 E(G) : G에 포함된 Edge(간선)들의 집합 무방향성 그래프(Undirected Graph)\nVertex 의 쌍을 나타내는 Edge가 방향성이 없다. (u, v), (v, u) 는 동일한 Edge 를 표현하는 것이다.\nEX) 지하철 노선도 방향성 그래프(Directed Graph)\n각 Edge에 방향성이 존재하는 그래프 (u, v) : v -\u0026gt; v 인 Edge를 표현하는 것이다.\nu : Tail\nv : Head 💡 그래프에서 사용되는 용어들 - 1 완전 그래프(Complete Graph)\nEdge의 수가 최대인 그래프 Vertex 의 개수가 N개 일 때, 최대 엣지 수는 N(N - 1)/2 개이다.\n각 정점마다 나머지 모든 노드들에 대해 방향성 엣지를 가질 수 있다. 부분 그래프(Sub Graph)\nV(G\u0026rsquo;) \u0026lt;= V(G) and E(G\u0026rsquo;) \u0026lt;= E(G) 일 경우,\nG\u0026rsquo; 은 G의 부분그래프이다. Vertex u 에서 v 까지의 경로(Path)\npath : Edge를 몇 개나 거쳐갔는가? 그래프의 Edge를 통해 두 정점을 연결하는 경로이다.\n1에서 3으로 가는 경로는 다음과 같다.\n(1,3), (1,0,3), (1,0,2,3) \u0026hellip; 경로의 길이는 경로 상에 있는 Edge의 수 와 같다.\n단순 경로(Simple Path)\n처음과 마지막을 제외한 Vertex가 다른 경로 사이클(Cycle)\n처음과 마지막이 동일한 단순경로 💡 그래프에서 사용되는 용어들 - 2 연결(Connected)\nVertex u 와 v 사이에 경로가 존재할 경우, u와 v는 연결되어 있다고 한다. 방향성 그래프로 연결되어 있다면, \u0026ldquo;Strongly Connected\u0026rdquo; 연결 요소(Connected Component)\nMaximal Connected Subgraph 방향성 그래프로 연결되어 있다면 \u0026ldquo;Strongly Connected Component\u0026rdquo; 트리(Tree) = Connected Acyclic Graph\n그래프 중, 싸이클이 없는 그래프를 말한다. Vertex v의 차수(Degree)\nv 에 연결된 Edge의 수 방향성 그래프 in-degree : v 가 head가 되는 edge의 수 out-degree : v 가 tail이 되는 edge의 수 💡 그래프의 표현 두가지의 표현이 있다. 인접 행렬(Adjacency Matrix) 인접 리스트(Adjacency List) 각 edge를 표현하는 방법에 따라서 구분된다. 💡 인접 행렬(Adjacency Matrix) 2차원 행렬로 그래프를 표현 정점이 N개일 경우 : A[N][N] (u, v)가 edge 목록에 있다면, A[u][v] = 1 (u, v)가 edge 목록에 없다면, A[u][v] = 0 무방향성 그래프 : A[][] 는 대칭 행렬\nA[n(n - 1)/2]로 구현가능 방향성 그래프 : A[][] 는 비대칭 행렬 💡 인접 리스트(Adjacency List) 인접 행렬의 N행들을 N개의 연결 리스트로 표현한다. 즉, 그래프 G의 각 Vertex에 대해 한 개의 연결 리스트가 존재하는 것이다. 💡 그래프 표현 방법들의 분석 G에 존재하는 Edge 의 수 혹은 G가 연결되었는지 검사한다.\n인접 행렬 : n(n-1)/2 개의 항을 조사한다.\nO(n^2) 인접 리스트 : O(N + E)\n전체 Vertex 수 : N\nEdge 수 : e Good if e \u0026laquo; n^2/2 (Sparse Graphs)\n희소 그래프 : Edge가 매우 적은 그래프 Digraph 에서 Vertex의 in-degree를 조사\n인접 행렬 : O(N) 인접 리스트 : O(N + E) 역인접 리스트(Inverse Adjacency List) 를 별도로 유지한다.\n역인접 리스트 : 들어오는 Edge에 대한 것만 표현한 리스트 ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-17.%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%ED%91%9C%ED%98%84/","summary":"📌 그래프의 개념과 표현 💡 그래프 소개 그래프(Graph)란? 연결되어 있는 객체 간의 관계를 표현하는 자료구조 지하철 노선도, SNS 친구 관계, 컴퓨터 네트워크 💡 그래프 데이터 타입 그래프 G의 두가지 구성요소\nV(G) : G에 포함된 Vertex(정점)들의 집합 E(G) : G에 포함된 Edge(간선)들의 집합 무방향성 그래프(Undirected Graph)\nVertex 의 쌍을 나타내는 Edge가 방향성이 없다. (u, v), (v, u) 는 동일한 Edge 를 표현하는 것이다.\nEX) 지하철 노선도 방향성 그래프(Directed Graph)\n각 Edge에 방향성이 존재하는 그래프 (u, v) : v -\u0026gt; v 인 Edge를 표현하는 것이다.","title":"[CS] 17.그래프의 개념과 표현"},{"content":"\n📌 이진 검색 트리 💡 이진 검색 트리(Binary Search Trees) 히프의 문제점\n임의의 데이터를 갖는 노드를 삭제할 경우의 시간 복잡도 : O(N) 트리에서 특정 데이터를 갖는 노드를 검색하는 시간 복잡도 : O(N) 이진 검색 트리란?\n트리 내에서 특정 데이터(Key 값) 을 갖는 노드를 효율적으로 검색 O(Log N), 하지만 정렬된 상태를 유지해야한다. 이진 검색 트리의 정의\n모든 노드는 유일한 키 값을 가지고 있다. 왼쪽 서브 트리에 저장된 키 값 \u0026lt; 루트 노드의 키 값 오른쪽 서브 트리에 저장된 키 값 \u0026gt; 루트 노드의 키 값 양쪽 서브 트리도 이진 검색 트리이다. 💡 검색 연산 기본 개념 if(key == root -\u0026gt; data) return if(key \u0026lt; root -\u0026gt; data) search(root -\u0026gt; left_child) if(key \u0026gt; root -\u0026gt; data) search(root -\u0026gt; right_child) 순환 알고리즘 혹은 반복문을 이용하여 구현한다. 시간 복잡도는 O(트리의 Depth) 💡 이진 검색 트리에 노드 추가 기본 개념\n추가할 키 값이 이미 트리에 존재하는지 확인한다.\n- 트리의 유일성을 보장한다. 검색 알고리즘 수행 후, 알고리즘이 종료되는 곳에 새로운 노드를 추가한다. modified_search(root, key)\nkey 가 존재할 경우, return NULL 검색 알고리즘에서 방문한 마지막 노드에 대한 Pointer return 검색 성능은 O(Log N) 이 보장되는 것이 장점이다. 💡 이진 검색트리에서 노드 삭제 중위 순회를 이용하면, 오름차순으로 출력이 가능하다. 리프 노드 삭제 parent -\u0026gt; left_child = NULL child 가 하나밖에 없는 노드의 삭제 삭제된 자리에 child node 를 위치하게 한다. 두개의 children 을 갖는 노드를 삭제 왼쪽 서브트리에서 가장 큰 노드\nor 오른쪽 서브트리에서 가장 작은 노드를 삭제된 자리에 위치 시킨다. 💡 이진 검색 트리의 깊이 데이터가 정렬된 순서로 입력 : O(N) 1,2,3,4 : 편향 이진 트리 데이터가 무작위 순서로 입력 : O(Log N) 균형 이진 검색 트리 : AVL Tree, Red-Black Tree 정렬된 데이터가 들어와도 O(Log N)을 보장한다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-16.%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89-%ED%8A%B8%EB%A6%AC/","summary":"📌 이진 검색 트리 💡 이진 검색 트리(Binary Search Trees) 히프의 문제점\n임의의 데이터를 갖는 노드를 삭제할 경우의 시간 복잡도 : O(N) 트리에서 특정 데이터를 갖는 노드를 검색하는 시간 복잡도 : O(N) 이진 검색 트리란?\n트리 내에서 특정 데이터(Key 값) 을 갖는 노드를 효율적으로 검색 O(Log N), 하지만 정렬된 상태를 유지해야한다. 이진 검색 트리의 정의\n모든 노드는 유일한 키 값을 가지고 있다. 왼쪽 서브 트리에 저장된 키 값 \u0026lt; 루트 노드의 키 값 오른쪽 서브 트리에 저장된 키 값 \u0026gt; 루트 노드의 키 값 양쪽 서브 트리도 이진 검색 트리이다.","title":"[CS] 16.이진 검색 트리"},{"content":"\n📌 히프의 개념과 응용 💡 히프(Heap)의 정의 최대 트리와 최대 히프\n최대 트리(Max Tree) 트리의 모든 노드에 대해서 노드의 데이터 값이 자식 노드의 데이터 값보다 크거나 같은 트리 최대 히프(Max Heap) 최대트리 이면서, 완전 이진트리. 최소 트리와 최소 히프\n최소 트리(Min Tree) 트리의 모든 노드에 대해서 노드의 데이터 값이 자식 노드의 데이터 값다 작거나 같은 트리 최소 히프(Min Heap) 최소트리 이면서, 완전 이진트리. 최대 히프의 root 노드는 항상 모든 노드들보다 큰 값을 가지고 있다. 최소 히프의 root 노드는 항상 모든 노드들보다 작은 값을 가지고 있다. 이는 가장 큰 값과 가장 작은 값을 찾기 쉬운 자료구조이다. 💡 우선 순위 큐(Priority Queue) 우선 순위 큐의 특징 일반적인 큐의 특징인 선입 선출 방식이 아닌, 우선 순위의 순서대로 처리되는 큐이다. 비행기 탑승 대기, OS의 작업스케쥴링 등 우선 순위 큐의 구현 방법 비교 💡 최대 히프에 노드를 추가 시간복잡도 : O(Log N)\n최대 히프를 배열로 구현하는 이유\n배열의 끝에 노드를 추가한다. 추가된 위치의 부모노드부터 루트노드까지 기존 노드들의 데이터와 비교하면서 최대 히프를 재구성한다. [i]에 저장된 노드의 부모노드의 위치 : i // 2 Depth 가 중요하게 된다. Depth 가 K 인 트리에서 노드 수는 2 ** K - 1개 이다. 💡 최대 히프에서 노드를 삭제 개념\n히프에서의 노드 삭제는 항상 루트 노드에서만 발생한다. 루트 노드를 삭제한 후, 히프를 재구성한다. 최소 히프를 재구성하는 방법\n루트 노드를 삭제한 후, 마지막 노드를 루트로 변경한다. 일단 루트로 올리고, 값을 비교하면서 그 값을 교체하는 방식. 마지막 노드의 값이 아닌 다른 값이 들어가면 이진트리가 아니게 되는 수가 있다. 루트 노드부터 아래로 순회하면서 노드의 값을 비교하며 히프를 재구성한다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-15.%ED%9E%88%ED%94%84%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%9D%91%EC%9A%A9/","summary":"📌 히프의 개념과 응용 💡 히프(Heap)의 정의 최대 트리와 최대 히프\n최대 트리(Max Tree) 트리의 모든 노드에 대해서 노드의 데이터 값이 자식 노드의 데이터 값보다 크거나 같은 트리 최대 히프(Max Heap) 최대트리 이면서, 완전 이진트리. 최소 트리와 최소 히프\n최소 트리(Min Tree) 트리의 모든 노드에 대해서 노드의 데이터 값이 자식 노드의 데이터 값다 작거나 같은 트리 최소 히프(Min Heap) 최소트리 이면서, 완전 이진트리. 최대 히프의 root 노드는 항상 모든 노드들보다 큰 값을 가지고 있다.","title":"[CS] 15.히프의 개념과 응용"},{"content":"\n📌 스레드 이진트리 💡 스레드 이진트리(Threaded Binary Tree) 스레드 이진트리의 기본 개념 n개의 노드를 갖는 이진 트리에는 2n 개의 링크가 존재한다. 2n 개의 링크 중에 n+1 개의 링크 값은 null이다. null 링크를 다른 노드에 대한 pointer 로 대체한다. (= Threads) 니는 루트를 제외한 모든 노드는 부모 노드가 있기 때문에 트리의 링크 수는 n-1 개이다. 스레드의 이용 ptr -\u0026gt; left_child = NULL 일 경우, ptr -\u0026gt; left_child 를 ptr의 중위행선자를 가리키도록 변경한다. 중위행선자(inorder predecessor) : 중위 순회에서 현재 노드 바로 앞에 나오는 노드 ptr -\u0026gt; right_child = NULL 일 경우, ptr -\u0026gt; right_child 를 ptr의 중위후속자를 가리키도록 변경한다. 중위후속자(inorder successor) : 중위 순회에서 현재 노드 바로 뒤에 나오는 노드 노드의 구조 struct thread_tree{ short int left_thread; # True or False struct thread_tree *left_child; # left_child = true : 스레드 # left_child = false : 왼쪽 자식 노드 char data; struct thread_tree *right_child; # right_thread 에 따라 결정된다. short int right_thread; # true or false } 💡 헤드노드(Head Node) 헤드노드의 역할 가장 왼쪽 노드의 Inorder predecessor 가장 오른쪽 노드의 Inorder successor 💡 스레드를 이용한 중위순회 ptr이 현재 노드를 가리킨다고 가정한다. # 중위순회에서 ptr 다음 노드 = ptr -\u0026gt; right_child if ptr -\u0026gt; right_thread == TRUE otherwise # ptr 의 right_child 로 이동한 후, left_child 를 따라 내려간다. # \u0026gt;\u0026gt; left_thread == TRUE 인 노드를 만날 때까지 내려간다. 중위 후속자 발견 알고리즘(insucc) struct thread_tree *insucc(struct thread_tree *ptr){ # 스레드 이진 트리에서 ptr이 가리키는 노드의 inorder success를 반환 struct thread_tree *temp = ptr -\u0026gt; right_child; # right_child 가 자식 노드 if (!ptr -\u0026gt; right_child){ # 왼쪽 끝에 도달할 때까지 반복한다. while(!temp -\u0026gt; left_child){ temp = temp -\u0026gt; left_child; } } return temp; } 💡 중위 순회 알고리즘(tinorder) void tinorder(struct thread_tree *tree){ // 스레드 이진트리를 중위순회, 헤드 노드부터 시작한다. struct thread_tree *temp = tree; for(;;){ temp = insucc(temp); if(temp==tree){ break; } printf(\u0026#34;%3c\u0026#34;, temp -\u0026gt; data); } } 💡 스레드 이진트리에서 노드를 추가 문제 정의 새로운 노드를 parent 노드의 right_child 로 추가한다. parent -\u0026gt; right_thread 의 값이 true 인 경우 parent -\u0026gt; right_thread 의 값이 false 인 경우 ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-14.%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC/","summary":"📌 스레드 이진트리 💡 스레드 이진트리(Threaded Binary Tree) 스레드 이진트리의 기본 개념 n개의 노드를 갖는 이진 트리에는 2n 개의 링크가 존재한다. 2n 개의 링크 중에 n+1 개의 링크 값은 null이다. null 링크를 다른 노드에 대한 pointer 로 대체한다. (= Threads) 니는 루트를 제외한 모든 노드는 부모 노드가 있기 때문에 트리의 링크 수는 n-1 개이다. 스레드의 이용 ptr -\u0026gt; left_child = NULL 일 경우, ptr -\u0026gt; left_child 를 ptr의 중위행선자를 가리키도록 변경한다.","title":"[CS] 14.스레드 이진트리"},{"content":"\n📌 BOJ 14495 피보나치 비스무리한 수열 💡 조건 피보나치 비스무리한 수열은 f(n) = f(n-1) + f(n-3)인 수열이다.\nf(1) = f(2) = f(3) = 1이며 피보나치 비스무리한 수열을 나열하면 다음과 같다.\n자연수 n을 입력받아 n번째 피보나치 비스무리한 수열을 구하는 문제.\n자연수 n의 범위는 (1 ≤ n ≤ 116) 이다.\nDP 유형의 문제\n🔖 예제 및 실행결과 예제 10 실행결과 19 ⌨️ 문제 풀이 문제에 점화식이 주어졌다. 🖥 소스 코드 from sys import stdin dp = [0 for _ in range(120)] dp[0:3] = [1, 1, 1, 2] for x in range(4, 117): dp[x] = (dp[x - 3] + dp[x - 1]) print(dp[int(stdin.readline()) - 1]) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14495-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EB%B9%84%EC%8A%A4%EB%AC%B4%EB%A6%AC%ED%95%9C-%EC%88%98%EC%97%B4-with-python/","summary":"📌 BOJ 14495 피보나치 비스무리한 수열 💡 조건 피보나치 비스무리한 수열은 f(n) = f(n-1) + f(n-3)인 수열이다.\nf(1) = f(2) = f(3) = 1이며 피보나치 비스무리한 수열을 나열하면 다음과 같다.\n자연수 n을 입력받아 n번째 피보나치 비스무리한 수열을 구하는 문제.\n자연수 n의 범위는 (1 ≤ n ≤ 116) 이다.\nDP 유형의 문제\n🔖 예제 및 실행결과 예제 10 실행결과 19 ⌨️ 문제 풀이 문제에 점화식이 주어졌다. 🖥 소스 코드 from sys import stdin dp = [0 for _ in range(120)] dp[0:3] = [1, 1, 1, 2] for x in range(4, 117): dp[x] = (dp[x - 3] + dp[x - 1]) print(dp[int(stdin.","title":"[BOJ] 14495 피보나치 비스무리한 수열 with Python"},{"content":"\n📌 BOJ 10159 저울 💡 조건 무게가 서로 다른 N 개의 물건이 있다. 각 물건은 1부터 N 까지 번호가 매겨져 있다.\n우리는 일부 물건 쌍에 대해서 양팔 저울로 어떤 것이 무거운 것인지를 측정한 결과표를 가지고 있다.\n이 결과표로부터 직접 측정하지 않은 물건 쌍의 비교 결과를 알아낼 수도 있고 알아내지 못할 수도 있다.\n예를 들어, 총 6개의 물건이 있고, 다음 5개의 비교 결과가 주어졌다고 가정하자. ([1]은 1번 물건의 무게를 의미한다.)\n[1]\u0026gt;[2], [2]\u0026gt;[3], [3]\u0026gt;[4], [5]\u0026gt;[4], [6]\u0026gt;[5]\n우리는 [2]\u0026gt;[3], [3]\u0026gt;[4]로부터 [2]\u0026gt;[4]라는 것을 알 수 있다.\n하지만, 물건 2와 물건 6을 비교하는 경우, 앞서의 결과만으로는 어느 것이 무거운지 알 수 없다.\n이와 같이, 물건 2는 물건 1, 3, 4와의 비교 결과는 알 수 있지만, 물건 5, 6과의 비교 결과는 알 수 없다.\n물건 4는 모든 다른 물건과의 비교 결과를 알 수 있다.\n비교 결과가 모순되는 입력은 없다고 가정한다. 위 예제의 기존 측정 결과에 [3]\u0026gt;[1]이 추가되었다고 가정하자.\n이 경우 [1]\u0026gt;[2], [2]\u0026gt;[3]이므로 우리는 [1]\u0026gt;[3]이라는 것을 예측할 수 있는데,\n이는 기존에 측정된 결과 [3]\u0026gt;[1]과 서로 모순이므로 이러한 입력은 가능하지 않다.\n첫 줄에는 물건의 개수 N 이 주어지고, 둘째 줄에는 미리 측정된 물건 쌍의 개수 M이 주어진다.\n단, 5 ≤ N ≤ 100 이고, 0 ≤ M ≤ 2,000이다. 다음 M개의 줄에 미리 측정된 비교 결과가 한 줄에 하나씩 주어진다.\n각 줄에는 측정된 물건 번호를 나타내는 두 개의 정수가 공백을 사이에 두고 주어지며, 앞의 물건이 뒤의 물건보다 더 무겁다.\n물건의 개수 N 과 일부 물건 쌍의 비교 결과가 주어졌을 때,\n각 물건에 대해서 그 물건과의 비교 결과를 알 수 없는 물건의 개수를 출력하는 문제\n플로이드 와샬 알고리즘 유형의 문제\n🔖 예제 및 실행결과 예제 9 11 2 1 3 1 2 8 2 9 7 8 4 5 6 7 6 3 1 7 6 2 1 9 실행결과 2 3 3 7 7 2 3 3 4 ⌨️ 문제 풀이 플로이드 와샬 알고리즘을 사용하여 푸는 문제이다. 문제를 참고해보면, N의 범위가 최대 100, M은 최대 2000 이다. (1) 번을 다른 말로 해보자면, 노드가 최대 100개, 간선의 개수가 최대 2000개 입력을 받을 수 있다는 것이다. 플로이드 와샬의 시간복잡도는 O(N^3) 이며, 이 문제에서는 최대 100 * 100 * 100 만큼의 연산이 필요하다는 것을 알 수 있다. 물건 쌍의 비교결과를 입력받아 그래프에 입력하고, 이를 플로이드 와샬 알고리즘을 통해 서로 비교결과를 알 수 없는 것들을 출력하면 된다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) m = int(stdin.readline()) arr = [[False] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) arr[a][b] = True for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if arr[i][k] and arr[k][j]: arr[i][j] = True for i in range(1, n + 1): cnt = 0 for j in range(1, n + 1): if not arr[i][j] and not arr[j][i]: cnt += 1 print(cnt - 1) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10159-%EC%A0%80%EC%9A%B8-with-python/","summary":"📌 BOJ 10159 저울 💡 조건 무게가 서로 다른 N 개의 물건이 있다. 각 물건은 1부터 N 까지 번호가 매겨져 있다.\n우리는 일부 물건 쌍에 대해서 양팔 저울로 어떤 것이 무거운 것인지를 측정한 결과표를 가지고 있다.\n이 결과표로부터 직접 측정하지 않은 물건 쌍의 비교 결과를 알아낼 수도 있고 알아내지 못할 수도 있다.\n예를 들어, 총 6개의 물건이 있고, 다음 5개의 비교 결과가 주어졌다고 가정하자. ([1]은 1번 물건의 무게를 의미한다.)","title":"[BOJ] 10159 저울 with Python"},{"content":"\n📌 이진트리의 추가 연산 💡 이진트리의 추가 연산 추가 연산의 종류\n이진트리의 복사 이진트리가 동일한지 검사 이진트리의 노드 수 계산 이진트리의 단말 노드 수 계산 이진트리의 모든 노드들을 모두 한번씩 다 방문해야 한다.\n트리의 모든 노드들을 방문할 필요성\n이진트리의 순회 알고리즘 등을 응용한다. 💡 이진트리의 복사 문제 설명 입력 이진트리의 노드 구조와 동일한 새로운 이진트리를 생성하고 루트 노드의 주소 반환 후위순회 알고리즘을 사용한다. 💡 이진트리의 복사 알고리즘 struct node *copy(struct node *original){ # original 트리를 복사한 새로운 이진트리를 반환한다. struct node *temp; if(original != NULL){ temp = (struct node *) malloc(sizeof(struct node)); temp -\u0026gt; left_child = copy(original -\u0026gt; left_child); temp -\u0026gt; right_child = copy(original -\u0026gt; right_child); temp -\u0026gt; data = original -\u0026gt; data; return temp; } return NULL; } 💡 이진 트리의 동일성 검사 문제 설명 두 개의 이진 트리가 동일한 데이터와 동일한 구조를 갖는지 검사한다. 여기서 구조란 부모-자식, 형제 노드 등을 말한다. 전위 순회 알고리즘을 응용한다. 💡 이진 트리의 동일성 검사 알고리즘 int queal(struct node *first, struct node *second){ # first 와 second 트리가 다를 경우 False, 트리가 동일할 경우 True 를 반환한다. return ( (!first \u0026amp;\u0026amp; !second) # 1 || (first \u0026amp;\u0026amp; second \u0026amp;\u0026amp; (first -\u0026gt; data == second -\u0026gt; first) # 2 \u0026amp;\u0026amp; equal(first -\u0026gt; left_child, second -\u0026gt; left_child) \u0026amp;\u0026amp; qeual(first -\u0026gt; right_child, second -\u0026gt; right_child))); # 3 } #1 : first 와 second가 둘 다 NULL 일 경우 True #2 : first 와 second가 둘 다 NULL 이 아니고, 각 노드의 데이터가 같다면? #3 : 노드의 왼쪽 자식, 오른쪽 자식이 같다면 재귀 호출 💡 이진트리의 노드 수 계산 접근 방법 루트 노드가 NULL dlaus 0 반환\nNULL 이 아니면 1 + 왼쪽 서브트리의 노드 수 + 오른쪽 서브트리의 노드 수 를 반환\n서브트리의 노드 수 는 순환 알고리즘으로 구할 수 있다. int get_node_cnt(struct node *ptr){ int cnt = 0; if(ptr != NULL){ cnt = 1 + get_node_cnt(ptr -\u0026gt; left_child) + get_node_cnt(ptr -\u0026gt; right_child); } return cnt } 💡 이진트리의 단말 노드 수 계산 접근 방법 루트 노드가 NULL 이면 0을 반환 단말 노드이면 1 반환 자식이 있을 경우, 왼쪽 서브트리의 단말 노드 수 + 오른쪽 서브트리의 단말 노드 수 를 반환한다. 서브트리의 단말 노드 수는 순환알고리즘으로 구할 수 있다. 💡 이진트리의 단말 노드 수 계산 알고리즘 int get_leaf_cnt(struct node *ptr){ int cnt = 0; if (ptr != NULL){ if(ptr -\u0026gt; left_child == NULL \u0026amp;\u0026amp; ptr -\u0026gt; right_child == NULL){ return 1; } } else{ cnt = get_leaf_cnt(ptr -\u0026gt; left_child) + get_leaf_cnt(ptr -\u0026gt; right_child); } return cnt; } ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-13.%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%B6%94%EA%B0%80-%EC%97%B0%EC%82%B0/","summary":"📌 이진트리의 추가 연산 💡 이진트리의 추가 연산 추가 연산의 종류\n이진트리의 복사 이진트리가 동일한지 검사 이진트리의 노드 수 계산 이진트리의 단말 노드 수 계산 이진트리의 모든 노드들을 모두 한번씩 다 방문해야 한다.\n트리의 모든 노드들을 방문할 필요성\n이진트리의 순회 알고리즘 등을 응용한다. 💡 이진트리의 복사 문제 설명 입력 이진트리의 노드 구조와 동일한 새로운 이진트리를 생성하고 루트 노드의 주소 반환 후위순회 알고리즘을 사용한다. 💡 이진트리의 복사 알고리즘 struct node *copy(struct node *original){ # original 트리를 복사한 새로운 이진트리를 반환한다.","title":"[CS] 13.이진트리의 추가 연산"},{"content":"\n📌 BOJ 14494 다이나믹이 뭐예요? 💡 조건 다이나믹 프로그래밍(동적 계획법),\n다이나믹은 이름이 엄청 거창하지만 사실 이름에 비해 개념은 간단하다.\n다이나믹의 기본 아이디어는 바로 이전에 계산한 값을 사용해서\n(= 이미 계산된 값을 사용해서, 어려운 말로 메모이제이션.)\n반복되는 똑같은 연산 횟수를 줄이는 것.\n다차원 배열로도 가능하다. 오른쪽, 아래쪽으로만 움직일 수 있을 때,\nD[1][1]에서 D[x][y]까지 도달하는 경우의 수를 구하는 문제는 일일히 모든 경우를 다 계산할 필요 없이,\nD[i][j] = (i, j)에 도달하는 누적 경우의 수 = D[i-1][j] + D[i][j-1]를 세워서 해결할 수도 있다.\n→, ↓, ↘의 세 방향만 사용해서 한 번에 한 칸씩 이동할 때,\n왼쪽 위 (1, 1)에서 출발하여 오른쪽 아래 (n, m)에 도착하는 경우의 수를 구하는 문제.\n(1 ≤ n, m ≤ 1,000)\n경우의 수가 엄청 커질 수 있으므로 경우의 수를 1,000,000,007(=109+7)로 나눈 나머지를 출력한다.\nDP 유형의 문제\n🔖 예제 및 실행결과 예제 4 5 실행결과 129 ⌨️ 문제 풀이 이번 문제는 다이나믹 프로그래밍의 기본형이라고 생각하고 풀이해보았다.\n문제에서 요구하는 것은 (1, 1)부터 (N, M)까지 도달하는 경우의 수를 구하는 것이다.\n(N * M) 크기의 2차원 배열을 DP 라고 한다면, 이 문제에서 바라는 값은 DP[N][M]에 있을 것이다.\n(3)번에서 구하려는 DP[N][M] 의 값은 각각 DP[N-1][M], DP[N][M-1], DP[N-1][M-1] 의 합으로 표현할 수 있다.\nDP[N-1][M] 또한 DP[N-2][M], DP[N-1][M-1], DP[N-2][M-2] 의 합으로 표현할 수 있다.\n이에 따라서 점화식은 DP[i][j] = (DP[i-1][j], DP[i][j-1], DP[i-1][j-1]) 이다.\n이를 int(1e9) + 7 로 나눈 나머지를 dp에 저장한다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) dp = [[0] * (m + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(1, n + 1): for j in range(1, m + 1): dp[i][j] = (dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]) % (int(1e9) + 7) print(dp[n][m]) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14494-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%EC%9D%B4-%EB%AD%90%EC%98%88%EC%9A%94-with-python/","summary":"📌 BOJ 14494 다이나믹이 뭐예요? 💡 조건 다이나믹 프로그래밍(동적 계획법),\n다이나믹은 이름이 엄청 거창하지만 사실 이름에 비해 개념은 간단하다.\n다이나믹의 기본 아이디어는 바로 이전에 계산한 값을 사용해서\n(= 이미 계산된 값을 사용해서, 어려운 말로 메모이제이션.)\n반복되는 똑같은 연산 횟수를 줄이는 것.\n다차원 배열로도 가능하다. 오른쪽, 아래쪽으로만 움직일 수 있을 때,\nD[1][1]에서 D[x][y]까지 도달하는 경우의 수를 구하는 문제는 일일히 모든 경우를 다 계산할 필요 없이,\nD[i][j] = (i, j)에 도달하는 누적 경우의 수 = D[i-1][j] + D[i][j-1]를 세워서 해결할 수도 있다.","title":"[BOJ] 14494 다이나믹이 뭐예요? with Python"},{"content":"\n📌 BOJ 3079 입국심사 💡 조건 상근이와 친구들은 오스트레일리아로 여행을 떠났다. 상근이와 친구들은 총 M명이고, 지금 공항에서 한 줄로 서서 입국심사를 기다리고 있다.\n(1 ≤ N ≤ 100,000, 1 ≤ M ≤ 1,000,000,000)\n입국심사대는 총 N개가 있다. 각 입국심사관이 심사를 하는데 걸리는 시간은 사람마다 모두 다르다.\nk번 심사대에 앉아있는 심사관이 한 명을 심사를 하는데 드는 시간은 Tk이다.\n(1 ≤ Tk ≤ 109)\n가장 처음에 모든 심사대는 비어있고, 심사를 할 준비를 모두 끝냈다. 근이와 친구들은 비행기 하나를 전세내고 놀러갔기 때문에,\n지금 심사를 기다리고 있는 사람은 모두 상근이와 친구들이다. 한 심사대에서는 한 번에 한 사람만 심사를 할 수 있다.\n상근이와 친구들은 모두 컴퓨터 공학과 학생이기 때문에, 어떻게 심사를 받으면 모든 사람이 심사를 받는데 걸리는 시간이 최소가 될지 궁금해졌다.\n상근이와 친구들이 심사를 받는데 걸리는 시간의 최솟값을 구하는 문제.\n이분탐색 유형의 문제\n🔖 예제 및 실행결과 예제 7 10 3 8 3 6 9 2 4 실행결과 8 ⌨️ 문제 풀이 그리디 혹은 브루트포스로 문제를 풀게되면, 인원 수 M 의 최대 크기가 10억이기 때문에 반드시 시간초과로 틀리게 된다.\n이분탐색으로 문제를 풀어야하는데, 심사대에서 한명이 심사를 받는 최소 시간을 l,\n심사대에서 m 명이 심사를 받는 최대 시간을 r 로 정한다.\n이에 따라 l = min(arr), r = max(arr) * m 이 된다.\n이분탐색을 위해 while 문을 사용하는데, 조건은 l 이 r보다 작거나 같을 때만 반복이다.\nm 명이 심사를 모두 받는 시간을 mid라고 했을 때, mid = (l + r) // 2 이다.\n이 mid 값을 사용하여 최소 시간을 구한다.\nn 개의 심사대의 정보가 있는 arr 리스트를 순회(i)하면서, mid 시간에 i 번 심사대에서 심사를 받을 수 있는 인원을 total 변수에 저장한다.\narr 리스트를 모두 순회했다면, total 값과 m의 값을 비교하여 모든 인원이 심사대에서 심사를 받았는지 확인한다.\n여기서 total 값이 m 보다 작다면 모든 인원이 심사를 받지 못한 것이므로, l 을 mid + 1 로 갱신한다.\n(5) 번의 조건에서 total 값이 m 보다 크다면 모든 인원이 심사를 받을 충분한 시간인 것이다.\nmid 값과 answer 값을 비교하여 더 작은 값을 answer 값으로 갱신한 뒤,\nr 을 mid - 1로 갱신하여 m 명이 모두 심사를 받는 더 작은 최소 시간이 있는지 검사한다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [int(stdin.readline()) for _ in range(n)] l, r = min(arr), max(arr) * m ans = r while l \u0026lt;= r: total = 0 mid = (l + r) // 2 for i in range(n): total += mid // arr[i] if total \u0026gt;= m: r = mid -1 ans = min(mid, ans) else: l = mid + 1 print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-3079-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC-with-python/","summary":"📌 BOJ 3079 입국심사 💡 조건 상근이와 친구들은 오스트레일리아로 여행을 떠났다. 상근이와 친구들은 총 M명이고, 지금 공항에서 한 줄로 서서 입국심사를 기다리고 있다.\n(1 ≤ N ≤ 100,000, 1 ≤ M ≤ 1,000,000,000)\n입국심사대는 총 N개가 있다. 각 입국심사관이 심사를 하는데 걸리는 시간은 사람마다 모두 다르다.\nk번 심사대에 앉아있는 심사관이 한 명을 심사를 하는데 드는 시간은 Tk이다.\n(1 ≤ Tk ≤ 109)\n가장 처음에 모든 심사대는 비어있고, 심사를 할 준비를 모두 끝냈다.","title":"[BOJ] 3079 입국심사 with Python"},{"content":"\n📌 BOJ 2548 대표 자연수 💡 조건 정보초등학교의 연아는 여러 개의 자연수가 주어졌을 때, 이를 대표할 수 있는 대표 자연수에 대하여 연구하였다.\n그 결과 어떤 자연수가 다음과 같은 성질을 가지면 대표 자연수로 적당할 것이라고 판단하였다.\n“대표 자연수는 주어진 모든 자연수들에 대하여 그 차이를 계산하여 그 차이들 전체의 합을 최소로 하는 자연수이다.”\n예를 들어 주어진 자연수들이 [4, 3, 2, 2, 9, 10]이라 하자.\n이때 대표 자연수는 3 혹은 4가 된다.\n왜냐하면 (4와 3의 차이) + (3과 3의 차이) + (2와 3의 차이) + (2와 3의 차이) + (9와 3의 차이) + (10과 3의 차이) = 16,\n(4와 4의 차이) + (3과 4의 차이) + (2와 4의 차이) + (2와 4의 차이) + (9와 4의 차이) + (10과 4의 차이) = 16으로 같다.\n첫째 줄에는 자연수의 개수 N이 입력된다. N은 1 이상 20,000 이하이다.\n둘째 줄에는 N개의 자연수가 빈칸을 사이에 두고 입력되며, 이 수들은 모두 1 이상 10,000 이하이다.\n이분탐색, 정렬 유형의 문제\n🔖 예제 및 실행결과 예제 6 4 3 2 2 9 10 실행결과 3 ⌨️ 문제 풀이 이 문제는 이분탐색 문제이다. N이 최대 20000 이고, 각 숫자의 차이를 일일히 구하면 반드시 TLE 이다.\n최솟값을 0으로, 최댓값을 int(1e9)로 둔 뒤, 이분탐색을 통해서 mid 값을 정해준다\n정해준 mid 값으로 입력받은 리스트의 각 원소값과의 차이를 더해 최소가 되는지 계산한다.\n계산한 대표 자연수가 기존의 대표 자연수보다 작다면 갱신해준다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() l, r = 0, n res = int(1e9) ans = max(arr) while l \u0026lt;= r: mid = (l + r) // 2 temp = sum([abs(x - arr[mid]) for x in arr]) if temp \u0026lt;= res: ans = min(ans, arr[mid]) res = temp r = mid - 1 else: l = mid + 1 print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2548-%EB%8C%80%ED%91%9C-%EC%9E%90%EC%97%B0%EC%88%98-with-python/","summary":"📌 BOJ 2548 대표 자연수 💡 조건 정보초등학교의 연아는 여러 개의 자연수가 주어졌을 때, 이를 대표할 수 있는 대표 자연수에 대하여 연구하였다.\n그 결과 어떤 자연수가 다음과 같은 성질을 가지면 대표 자연수로 적당할 것이라고 판단하였다.\n“대표 자연수는 주어진 모든 자연수들에 대하여 그 차이를 계산하여 그 차이들 전체의 합을 최소로 하는 자연수이다.”\n예를 들어 주어진 자연수들이 [4, 3, 2, 2, 9, 10]이라 하자.\n이때 대표 자연수는 3 혹은 4가 된다.","title":"[BOJ] 2548 대표 자연수 with Python"},{"content":"\n📌 BOJ 1939 중량제한 💡 조건 N(2 ≤ N ≤ 10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.\n영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다.\n물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다.\n그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다.\n만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.\n첫째 줄에 N, M(1 ≤ M ≤ 100,000)이 주어진다.\n다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1 ≤ A, B ≤ N), C(1 ≤ C ≤ 1,000,000,000)가 주어진다.\n이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다.\n서로 같은 두 섬 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다.\n마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다.\n공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.\nBFS, 이분탐색 유형의 문제\n🔖 예제 및 실행결과 예제 3 3 1 2 2 3 1 3 2 3 2 1 3 실행결과 3 ⌨️ 문제 풀이 지문을 통해 파악할 수 있는 것은 모든 섬을 연결하는 다리가 양방향이라는 것이다.\n양방향 그래프를 만들기 위해 graph 리스트를 생성하고, 섬과 섬 번호, 간선의 비용인 (a,b,c) 를 입력받아 양방향 그래프를 만들어준다.\n출발지점과 도착지점을 입력받아 start, end에 저장한 후 그래프 순회를 위한 BFS함수를 구현한다.\n이 때, 들고 갈 수 있는 최대 중량 값 mid 를 기준으로 조건문을 작성하여 방문처리 및 큐에 노드 번호를 추가해야한다.\n조건은 두가지다. 방문하지 않은 노드, mid 보다 cost가 크거나 같을 때 이다.\n최대 중량값을 1부터 1,000,000,000 까지 차례대로 순회를 돌면 시간초과가 나오기 때문에 여기서 이분탐색을 통해서 mid 값을 정해주어야한다.\nBFS에서 True 를 반환했다면, ans가 mid 보다 작을 경우 갱신한다.\n🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] for _ in range(m): a, b, c = map(int, stdin.readline().split()) graph[a].append((b, c)) graph[b].append((a, c)) start, end = map(int, stdin.readline().split()) l, r = 0, int(1e9) def solve(mid): q = deque() q.append(start) visited[start] = True while q: now = q.popleft() if now == end: return True for node, cost in graph[now]: if not visited[node] and mid \u0026lt;= cost: q.append(node) visited[node] = True return False ans = 0 while l \u0026lt;= r: mid = (l + r) // 2 visited = [False for _ in range(n + 1)] if solve(mid): ans = max(ans, mid) l = mid + 1 else: r = mid - 1 print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1939-%EC%A4%91%EB%9F%89%EC%A0%9C%ED%95%9C-with-python/","summary":"📌 BOJ 1939 중량제한 💡 조건 N(2 ≤ N ≤ 10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.\n영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다.\n물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다.\n그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다.\n만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.","title":"[BOJ] 1939 중량제한 with Python"},{"content":"\n📌 이진트리의 순회 💡 이진트리순회(Binary Tree Traversal) 문제 정의\n이진 트리의 모든 노드를 한번씩 방문한다. 트리에 있는 노드의 순서를 결정한다. 순회방법\n중위순회(L-V-R) 전위순회(V-L-R) 후위순회(L-R-V) 💡 중위순회 void inorder(struct link *ptr){ if(ptr){ inorder(ptr -\u0026gt; left_child); printf(\u0026#34;%d\u0026#34;, ptr -\u0026gt; data); inorder(ptr -\u0026gt; right_child); } } 💡 전위순회 void preorder(struct link *ptr){ if(ptr){ printf(\u0026#34;%d\u0026#34;, ptr -\u0026gt; data); preorder(ptr -\u0026gt; left_child); preorder(ptr -\u0026gt; right_child); } } 💡 후위순회 void postorder(struct link *ptr){ if(ptr){ postorder(ptr -\u0026gt; left_child); postorder(ptr -\u0026gt; right_child); printf(\u0026#34;%d\u0026#34;, prt -\u0026gt; data); } } 💡 이진트리 순회의 예 💡 이진트리 그리기 순회 순서를 이용하여 이진트리를 계산하여 그리기. 중위순회 + 전위(후위) 순회 결과를 이용하는 방법 중위 순회 : 왼쪽 및 오른쪽 자식을 구분 전위(후위) 순회 : 부모 자식을 구분 ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-12.%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8C/","summary":"📌 이진트리의 순회 💡 이진트리순회(Binary Tree Traversal) 문제 정의\n이진 트리의 모든 노드를 한번씩 방문한다. 트리에 있는 노드의 순서를 결정한다. 순회방법\n중위순회(L-V-R) 전위순회(V-L-R) 후위순회(L-R-V) 💡 중위순회 void inorder(struct link *ptr){ if(ptr){ inorder(ptr -\u0026gt; left_child); printf(\u0026#34;%d\u0026#34;, ptr -\u0026gt; data); inorder(ptr -\u0026gt; right_child); } } 💡 전위순회 void preorder(struct link *ptr){ if(ptr){ printf(\u0026#34;%d\u0026#34;, ptr -\u0026gt; data); preorder(ptr -\u0026gt; left_child); preorder(ptr -\u0026gt; right_child); } } 💡 후위순회 void postorder(struct link *ptr){ if(ptr){ postorder(ptr -\u0026gt; left_child); postorder(ptr -\u0026gt; right_child); printf(\u0026#34;%d\u0026#34;, prt -\u0026gt; data); } } 💡 이진트리 순회의 예 💡 이진트리 그리기 순회 순서를 이용하여 이진트리를 계산하여 그리기.","title":"[CS] 12.이진트리의 순회"},{"content":"\n📌 트리와 이진트리의 개념 💡 트리의 개념 트리란?\n계층적 구조의 자료를 표현할 때 사용 ex) 가계도, 회사의 조직도, 폴더 구조 등 트리의 정의\n하나 이상의 노드로 이루어진 유한 집합 Root(루트) 라고 하는 노드가 하나 존재한다. 나머지 노드들은 n(n \u0026gt;= 0) 개의 집합 T[1], \u0026hellip; ,T[n]으로 분할 이처럼 분할된 트리를 루트의 서브트리라고 한다. 💡 트리에 관련된 용어들 Level 1 : 노드의 차수(Degree), 트리의 차(Degree) Level 2 : 단일노드(Leaf node or Terminal node) Level 3 : 부모노드, 자식노드, 형제노드 Level 4 : 조상노드, 자손노드, level, 트리의 높이 or 깊이 💡 이진트리의 개념 이진트리(Binary Tree)란? 모든 노드의 차수가 2를 넘지 않는 트리 = 일반 트리에 비해 구현이 쉽다. 왼쪽 서브트리와 오른쪽 서브트리가 구분된다. 이진트리의 정의\n유한한 개수의 노드들이 집합으로서 노드 수는 0이 될 수 있다. 하나의 루트노드와 왼쪽 서브트리, 그리고 오른쪽 서브트리로 구성되어있다. 각 서브트리는 다시 이진트리이다. 트리를 이진트리로 변환하는 방법\nLeft child - Right sibling 표현 노드 A의 제일 왼쪽 노드 : A의 왼쪽 자식 노드 A의 나머지 자식 노드들 : 자식 노드의 오른쪽 노드 💡 이진트리의 성질 최대 노드 수 이진 트리의 레벨 i 에서 최대 노드 수는 2^(i-1) (i \u0026gt; 0) 깊이가 k인 이진트리가 가질 수 있는 최대 노드 수 단말 노드 수와 차수가 2인 노드 수\nN[0] : 단말 노드수 N[2] : 차수가 2인 노드의 수 = N[0] = N[2] + 1 정의 : 깊이가 K인 포화 이진트리(Full Binary Tree)\n깊이가 K 이고, 노드 수가 2 ** (k \u0026gt;= 0) 인 이진트리 💡 완전이진트리(Complete Binary Tree) 완전이진트리란? 깊이가 K이고 노드 수가 N 인 이진트리의 각 노드들이 깊이가 K인 포화이진트리에서 1부터 N까지의 번호를 붙인 노드들과 1대1로 일치하는 이진트리. 마지막 레벨을 제외하고 포화이진트리이며, 마지막 레벨에서 왼쪽부터 빠짐없이 노드가 채워진 형태로 트리가 구성된 경우를 말한다. 💡 이진트리의 표현 배열 표현법 - 1차원 배열에 저장 (완전이진트리 저장에 적합)\n루트 노드는 [1] 에 저장한다. 부모 노드가 [i] 에 저장될 경우 왼쪽 자식 노드는 [i * 2]에 저장한다. 오른쪽 자식 노드는 [i * 2 + 1]에 저장한다. 이 때, i 번째 노드의 부모 인덱스는 i // 2 이다. 만약 2의 제곱수에 해당하는 인덱스에만 데이터가 들어가있다면, 그 트리는 편향 이진트리이다. 링크 표현법\n노드를 구조체로 표현 코드 stuct node{ char data; struct node *left_child; struct node *right_child; }; 노드의 수가 N 일 경우, 링크의 수 = 2N NULL 인 link 의 수는 N + 1 ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-11.-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EA%B0%9C%EB%85%90/","summary":"📌 트리와 이진트리의 개념 💡 트리의 개념 트리란?\n계층적 구조의 자료를 표현할 때 사용 ex) 가계도, 회사의 조직도, 폴더 구조 등 트리의 정의\n하나 이상의 노드로 이루어진 유한 집합 Root(루트) 라고 하는 노드가 하나 존재한다. 나머지 노드들은 n(n \u0026gt;= 0) 개의 집합 T[1], \u0026hellip; ,T[n]으로 분할 이처럼 분할된 트리를 루트의 서브트리라고 한다. 💡 트리에 관련된 용어들 Level 1 : 노드의 차수(Degree), 트리의 차(Degree) Level 2 : 단일노드(Leaf node or Terminal node) Level 3 : 부모노드, 자식노드, 형제노드 Level 4 : 조상노드, 자손노드, level, 트리의 높이 or 깊이 💡 이진트리의 개념 이진트리(Binary Tree)란?","title":"[CS] 11. 트리와 이진트리의 개념"},{"content":"\n📌 이중 연결 리스트 💡 이중 연결 리스트의 개념 이중 연결 리스트(Double Linked List)란?\n한 노드에 두 개의 Link 가 저장 이중 연결 리스트는 양방향으로 이동가능 단일 연결 리스트의 경우, 한 방향으로만 이동이 가능. struct node{ struct node *llink; // 이전 노드 포인트 int data; struct node *rlink; // 다음 노드 포인트 💡 이중 연결 리스트의 종류 체인\n처음 노드의 llink와 마지막 노드의 rlink는 NULL ptr = ptr -\u0026gt; llink -\u0026gt; rlink = ptr -\u0026gt; rlink -\u0026gt; llink 원형 이중 연결 리스트\n원형 이중 연결리스트에 노드를 추가하는 방법\n새로 추가되는 링크의 노드를 먼저 바꾸는 것이 좋다. void dinsert(struct node *node, struct node *newnode){ # newnode를 node의 오른쪽에 추가 newnode -\u0026gt; llink = node; newnode -\u0026gt; rlink = node -\u0026gt; rlink; node -\u0026gt; rlink -\u0026gt; llink = newnode; node -\u0026gt; rlink = newnode; } 원형 이중 연결 리스트에서 노드 삭제\nvoid ddelete(struct node *deleted){ deleted -\u0026gt; llink -\u0026gt; rlink = delete -\u0026gt; rlink; deleted -\u0026gt; rlink -\u0026gt; llink = delete -\u0026gt; llink; free(delete); } ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-10.%EC%9D%B4%EC%A4%91-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8/","summary":"📌 이중 연결 리스트 💡 이중 연결 리스트의 개념 이중 연결 리스트(Double Linked List)란?\n한 노드에 두 개의 Link 가 저장 이중 연결 리스트는 양방향으로 이동가능 단일 연결 리스트의 경우, 한 방향으로만 이동이 가능. struct node{ struct node *llink; // 이전 노드 포인트 int data; struct node *rlink; // 다음 노드 포인트 💡 이중 연결 리스트의 종류 체인\n처음 노드의 llink와 마지막 노드의 rlink는 NULL ptr = ptr -\u0026gt; llink -\u0026gt; rlink = ptr -\u0026gt; rlink -\u0026gt; llink 원형 이중 연결 리스트","title":"[CS] 10.이중 연결 리스트"},{"content":"\n📌 추가적인 리스트 연산 💡 추가적인 리스트 연산들 단일 연결 리스트(Chain) 에 대한 연산\n체인의 방향을 반대로 : invert() 두 개의 체인을 통합 : concatenate() 원형 리스트에 대한 연산\n원형 연결리스트의 길이를 계산하는 연산 : length() 원형 연결리스트의 제일 앞에 새로운 노드 삽입 : insert_front() 💡 Invert 함수 포인터 3개를 사용해 가리키는 포인터를 변경해준다. lead, middle, tail 세 개의 포인터를 사용한다고 하면, return 값은 middle 이다. 💡 concatenate 함수 A 체인 혹은 B 체인이 NULL 일 경우, 나머지를 반환한다. A를 순회하면서 접근하고, A 마지막 노드의 포인터를 B로 가리켜준다. 💡 원형 연결리스트의 순회 처음 데이터는 별도로 처리해주고, 무한루프를 방지할 수 있게 코드를 작성한다. # 체인 연결리스트의 순회 struct node *ptr; for (ptr A -\u0026gt; link; ptr != null; ptr = ptr -\u0026gt; link) sum += ptr -\u0026gt; data; # 원형 연결리스트의 순회 struct node *ptr = A; sum += ptr -\u0026gt; data; for (ptr A -\u0026gt; link; ptr != A; ptr = ptr -\u0026gt; link) sum += ptr -\u0026gt; data; 💡 원형 연결리스트의 이름 첫번째 Node 를 Pointing 마지막 Node 를 pointing 마지막 노드를 가리킬 경우, 다음 연산의 복잡성은 O(1) 리스트의 첫번째 위치에 노드 추가/삭제 리스트의 마지막 위치에 노드 추가 ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-9.-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%97%B0%EC%82%B0/","summary":"📌 추가적인 리스트 연산 💡 추가적인 리스트 연산들 단일 연결 리스트(Chain) 에 대한 연산\n체인의 방향을 반대로 : invert() 두 개의 체인을 통합 : concatenate() 원형 리스트에 대한 연산\n원형 연결리스트의 길이를 계산하는 연산 : length() 원형 연결리스트의 제일 앞에 새로운 노드 삽입 : insert_front() 💡 Invert 함수 포인터 3개를 사용해 가리키는 포인터를 변경해준다. lead, middle, tail 세 개의 포인터를 사용한다고 하면, return 값은 middle 이다. 💡 concatenate 함수 A 체인 혹은 B 체인이 NULL 일 경우, 나머지를 반환한다.","title":"[CS] 9. 추가적인 리스트 연산"},{"content":"\n📌 원형 연결리스트(Circular Linked List) 💡 원형 연결리스트의 개념 원형 연결리스트란? 마지막 노드의 link 가 처음 노드를 가리키는 연결리스트 chain : 마지막 노드의 link가 null 인 연결리스트 원형 연결리스트 체인 💡 헤드 노드 노드가 없는 원형 연결리스트 -\u0026gt; Head Node 💡 다항식 더하기 (원형 연결 리스트) 지수를 비교하여 덧셈을 한다. 지수항이 둘 모두 -1이 된다면 연산을 종료한다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-8.-%EC%9B%90%ED%98%95-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8/","summary":"\n📌 원형 연결리스트(Circular Linked List) 💡 원형 연결리스트의 개념 원형 연결리스트란? 마지막 노드의 link 가 처음 노드를 가리키는 연결리스트 chain : 마지막 노드의 link가 null 인 연결리스트 원형 연결리스트 체인 💡 헤드 노드 노드가 없는 원형 연결리스트 -\u0026gt; Head Node 💡 다항식 더하기 (원형 연결 리스트) 지수를 비교하여 덧셈을 한다. 지수항이 둘 모두 -1이 된다면 연산을 종료한다. ","title":"[CS] 8. 원형 연결리스트"},{"content":"\n📌 연결리스트를 이용한 다항식의 구현 💡 다항식의 연결리스트 표현 다항식의 구조체 struct poly{ int coef; // 계수 int expon; // 지수 struct poly *link; // 링크 }*a, *b, *c 💡 다항식의 덧셈 알고리즘 d = a + b\n각 다항식 최고차 항부터 차례대로 비교하며 연산 최고차 항의 지수가 동일할 경우\n","permalink":"https://jxun-h.github.io/posts/data-structure/cs-7.-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%95%AD%EC%8B%9D%EC%9D%98-%EA%B5%AC%ED%98%84/","summary":"📌 연결리스트를 이용한 다항식의 구현 💡 다항식의 연결리스트 표현 다항식의 구조체 struct poly{ int coef; // 계수 int expon; // 지수 struct poly *link; // 링크 }*a, *b, *c 💡 다항식의 덧셈 알고리즘 d = a + b\n각 다항식 최고차 항부터 차례대로 비교하며 연산 최고차 항의 지수가 동일할 경우","title":"[CS] 7. 연결리스트를 이용한 다항식의 구현"},{"content":"\n📌 연결리스트의 개념 💡 자기참조 구조체 동일한 타입의 구조체에 대한 포인터를 속성으로 포함하는 구조체 Link Node 구조체에 대한 포인터 -\u0026gt; 메모리의 주소를 가리키는 자료형 여러 개의 Node 구조체를 연결하는 역할 💡 연결리스트 단순 연결리스트(Singly Linked List)\n자기 참조 구조체(Node)들의 연결 천번째 노드에 대한 포인터만 유지 리스트의 이름 = 첫번째 노드의 수조 이후 노드들은 구조체의 Link 포인터를 통해 참조 마지막 노드의 Link 포인터는 NULL로 설정한다. 다른 연결리스트\n이중 연결 리스트(Doubly Linked List) 앞 뒤의 노드들의 정보를 가지고 있다. 원형 연결 리스트(Circular Linked List) 마지막 노트와 첫노드를 연결 연결리스트 연산 - 순회\n연결리스트의 길이 계산 각각의 노드를 정확히 한번만, 체계적인 방법으로 방문하는 과정 삽입 및 삭제를 하더라도 노드의 위치는 달라지지 않는다. 💡 배열과 연결 리스트의 비교 저장 방식의 차이 -\u0026gt; 메모리의 인접한 곳에 저장한다.\n배열 : int Array[4]; 다음 데이터에 대한 주소를 알 필요가 없다. 연결리스트 : struct node에 대한 네 번의 malloc\n각 노드들은 메모리의 여러 곳에 나누어 저장한다. Link를 이용하여 다음 노드의 주소를 유지한다 메모리 사용 측면\n저장될 데이터의 수를 안다면 배열이 효과적이다. 데이터의 수를 모를 경우, 연결리스트가 유리하다. 새로 데이터가 입력될 때마다, malloc 실행 후 연결 정렬된 데이터의 순서 유지\n배열 데이터가 추가될 때 기존 데이터의 위치 변경이 가능하다. 이진 검색이 가능하다. 연결리스트\n기존 데이터의 위치 변경은 발생하지 않는다. 이진 검색이 불가능하다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-6.-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EA%B0%9C%EB%85%90/","summary":"📌 연결리스트의 개념 💡 자기참조 구조체 동일한 타입의 구조체에 대한 포인터를 속성으로 포함하는 구조체 Link Node 구조체에 대한 포인터 -\u0026gt; 메모리의 주소를 가리키는 자료형 여러 개의 Node 구조체를 연결하는 역할 💡 연결리스트 단순 연결리스트(Singly Linked List)\n자기 참조 구조체(Node)들의 연결 천번째 노드에 대한 포인터만 유지 리스트의 이름 = 첫번째 노드의 수조 이후 노드들은 구조체의 Link 포인터를 통해 참조 마지막 노드의 Link 포인터는 NULL로 설정한다. 다른 연결리스트\n이중 연결 리스트(Doubly Linked List) 앞 뒤의 노드들의 정보를 가지고 있다.","title":"[CS] 6. 연결리스트의 개념"},{"content":"\n📌 배열을 이용한 희소행렬의 표현 💡 희소행렬 행렬의 표현 2차원 배열 : Array[MaxRows][MaxCols] 0이 많이 포함된 경우, 희소행렬이라고 한다. 0이 아닌 데이터의 수 \u0026lt; 0인 데이터의 수 만약 1000 * 1000 행렬에서 0이 아닌 원소가 10개라면, 메모리 낭비일 수 있다. 💡 희소행렬의 표현 동기 : 공간 낭비를 줄이자. \u0026lt;Row, Column, Value\u0026gt; 의 쌍을 저장 빠른 전치를 위해서 Row 의 오름차순으로 저장 희소행렬 -\u0026gt; 배열 맨 처음에 행렬의 정보기록 = (행, 열, 0이 아닌 데이터의 수) 💡 행렬의 전치 전치연산 (Transposing a Matrix) row \u0026amp; column 을 교환 \u0026lt;j, i, value\u0026gt; 를 희소행렬 M의 어디에 저장하는가? \u0026lt;0, 0, 15\u0026gt; -\u0026gt; \u0026lt;0, 0, 15\u0026gt; \u0026lt;0, 3, 22\u0026gt; -\u0026gt; \u0026lt;3, 0, 22\u0026gt; \u0026lt;0, 5, 15\u0026gt; -\u0026gt; \u0026lt;5, 0, 15\u0026gt; 전치연산을 위한 연속적인 삽입으로 인해 기존에 저장된 항목들의 이동이 불가피 -\u0026gt; row 정렬이 깨져버림 💡 전치 연산의 구현 : Transpose Column을 기준으로 순회하면서 뒤집어 저장한다. 성능분석 O(Columns * Elements) ~ O(Columns^2 * Rows) 복잡도 : O(Rows * Columns) 💡 전치연산의 구현 각 Column 이 저장될 곳을 미리 파악 -\u0026gt; Column index 각 Column index 저장을 위한 추가적인 공간을 사용한다. row_terms = 2 1 2 2 0 1 starting_pos = 1 3 4 6 8 8 복잡도 : O(columns + Elements) Elements = columns * row 일 때, Element 의 시간복잡도는 O(Columns * Row * Columns) ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-5.-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC%EC%9D%98-%ED%91%9C%ED%98%84/","summary":"📌 배열을 이용한 희소행렬의 표현 💡 희소행렬 행렬의 표현 2차원 배열 : Array[MaxRows][MaxCols] 0이 많이 포함된 경우, 희소행렬이라고 한다. 0이 아닌 데이터의 수 \u0026lt; 0인 데이터의 수 만약 1000 * 1000 행렬에서 0이 아닌 원소가 10개라면, 메모리 낭비일 수 있다. 💡 희소행렬의 표현 동기 : 공간 낭비를 줄이자. \u0026lt;Row, Column, Value\u0026gt; 의 쌍을 저장 빠른 전치를 위해서 Row 의 오름차순으로 저장 희소행렬 -\u0026gt; 배열 맨 처음에 행렬의 정보기록 = (행, 열, 0이 아닌 데이터의 수) 💡 행렬의 전치 전치연산 (Transposing a Matrix) row \u0026amp; column 을 교환 \u0026lt;j, i, value\u0026gt; 를 희소행렬 M의 어디에 저장하는가?","title":"[CS] 5. 배열을 이용한 희소행렬의 표현"},{"content":"\n📌 배열을 이용한 다항식의 표현 💡 순서리스트 (Orderd List) 데이터들의 순서가 유지되는 집합\n집합이란, 원소들의 모임, 순서를 중요시 하지 않음. 한 주의 요일들 섞여진 카드들 미국의 2차 세계 대전 참전 연도 스위스의 2차 세계 대전 참전 연도 (원소가 없는 집합도 순서리스트에 포함된다.) 💡 순서리스트의 연산 순서리스트에 적용 가능한 연산들 리스트 길이 연산 리스트의 모든 데이터들을 왼쪽에서 오른쪽으로 읽기 리스트로부터 i번째 데이터를 검색 리스트로부터 i번째 데이터를 교체 리스트의 i번째 위치에 새로운 데이터 추가 (i번째 이후에 있던 데이터는 한 칸씩 밀림) 리스트의 i번째 위치에 있는 데이터를 삭제 (i번째 이후에 있던 데이터는 한 칸씩 당겨짐) 💡 다항식 소개 순서리스트를 구현하는 방법 배열 : i번째 데이터를 배열 i에 저장 연결리스트 💡 C 언어에서 다항식 구현 방법 1 : 모든 지수의 계수들을 내림차순으로 저장\n2x^3 + x^2 - 1 == [3, (2, 1, 0, -1)] 만약 x^100 + 1 일 경우 [100, (1, 0, 0, \u0026hellip; , 1)]로, 메모리 낭비가 심해진다. 방법 2 : 지수와 계수를 모두 저장하는 방법\nx^100 + 1 == [(1, 100), (1, 0)] 위와 같은 방법은 모든 항에 대해서 지수까지 표현해야하기 때문에 메모리 낭비가 심할 경우가 있다. 각 다항식은 (start, end)의 쌍으로 표현한다. 모든 다항식을 저장하기 위한 전역변수 terms 배열을 사용한다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-4.-%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8B%A4%ED%95%AD%EC%8B%9D%EC%9D%98-%ED%91%9C%ED%98%84/","summary":"📌 배열을 이용한 다항식의 표현 💡 순서리스트 (Orderd List) 데이터들의 순서가 유지되는 집합\n집합이란, 원소들의 모임, 순서를 중요시 하지 않음. 한 주의 요일들 섞여진 카드들 미국의 2차 세계 대전 참전 연도 스위스의 2차 세계 대전 참전 연도 (원소가 없는 집합도 순서리스트에 포함된다.) 💡 순서리스트의 연산 순서리스트에 적용 가능한 연산들 리스트 길이 연산 리스트의 모든 데이터들을 왼쪽에서 오른쪽으로 읽기 리스트로부터 i번째 데이터를 검색 리스트로부터 i번째 데이터를 교체 리스트의 i번째 위치에 새로운 데이터 추가 (i번째 이후에 있던 데이터는 한 칸씩 밀림) 리스트의 i번째 위치에 있는 데이터를 삭제 (i번째 이후에 있던 데이터는 한 칸씩 당겨짐) 💡 다항식 소개 순서리스트를 구현하는 방법 배열 : i번째 데이터를 배열 i에 저장 연결리스트 💡 C 언어에서 다항식 구현 방법 1 : 모든 지수의 계수들을 내림차순으로 저장","title":"[CS] 4. 배열을 이용한 다항식의 표현"},{"content":"\n📌 배열과 구조체의 정의 💡 배열의 정의 배열이란? 동일한 데이터 타입의 데이터들을 묶는 구조 메모리의 연속된 위치에 차례대로 저장 (Index, Data) 쌍의 집합\n배열에 적용 가능한 연산 인덱스 i 번째에 저장된 데이터를 출력 인덱스 i 번째에 데이터 d 를 저장 배열의 저장된 데이터의 수는 얼마인가? 💡 구조체 구조체의 정의\n하나 이상의 기본 자료형을 기반으로 사용자 정의 자료형을 만들 수 있는 문법요소 다양한 자료형을 포함한다. 구조체 비교\n구조체의 내용이 동일한지를 검사하는 방법은 모든 속성이 같은지 하나씩 비교하는 것이다. 💡 자기 참조 구조체 정의 : 자기 자신을 가리키는 포인터를 속성으로 갖는 구조체 연결리스트에 많이 사용된다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-3.-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%9D%98-%EC%A0%95%EC%9D%98/","summary":"📌 배열과 구조체의 정의 💡 배열의 정의 배열이란? 동일한 데이터 타입의 데이터들을 묶는 구조 메모리의 연속된 위치에 차례대로 저장 (Index, Data) 쌍의 집합\n배열에 적용 가능한 연산 인덱스 i 번째에 저장된 데이터를 출력 인덱스 i 번째에 데이터 d 를 저장 배열의 저장된 데이터의 수는 얼마인가? 💡 구조체 구조체의 정의\n하나 이상의 기본 자료형을 기반으로 사용자 정의 자료형을 만들 수 있는 문법요소 다양한 자료형을 포함한다. 구조체 비교\n구조체의 내용이 동일한지를 검사하는 방법은 모든 속성이 같은지 하나씩 비교하는 것이다.","title":"[CS] 3. 배열과 구조체의 정의"},{"content":"\n📌 BOJ 1068 트리 💡 조건 트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.\n트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 문제.\n노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.\n다음과 같은 트리가 있다고 하자.\n현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다.\n검정색으로 색칠된 노드가 트리에서 제거된 노드이다.\n이제 리프 노드의 개수는 1개이다.\n첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.\n둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다.\n만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 5 -1 0 0 1 1 2 실행결과 2 ⌨️ 문제 풀이 n개의 노드를 가진 edge 리스트를 만들어 -1 로 초기화해 부모노드가 없는 상태로 초기화 한다.\n0부터 n까지 순회하면서(i), 0번 노드부터 N-1번 노드까지 각 노드의 부모의 값이 0보다 같거나 크고, 삭제할 노드의 번호와 같지 않다면\n그래프에 i를 추가한다.\n만약 (2)번 조건에 해당하지 않는다면 root 리스트에 i를 추가한다.\n그 후, edge[k]를 -1 로 변경해 삭제처리를 해준다.\nroot 리스트가 빌 때까지 while 문을 반복한다.\nroot 에서 pop() 한 노드번호를 방문한 적이 없다면 방문처리를 해주고, edge[n]의 길이가 1일 경우 ans += 1 해준다.\n(5)번 조건에 해당하지 않는다면 sub = edge[n]이며, sub의 가장 왼쪽에서 데이터를 pop 한 뒤, sub 를 순회하면서 root에 i 를 추가한다.\n🖥 소스 코드 import sys n = int(sys.stdin.readline()) stack = list(map(int, sys.stdin.readline().split())) edge = [[-1] for _ in range(n)] k = int(sys.stdin.readline()) root = [] for i in range(n): if stack[i] \u0026gt;= 0 and i != k: edge[stack[i]].append(i) elif stack[i] == -1 and i != k: root.append(i) edge[k] = [-1] ans = 0 visited = [0]*n while root: n = root.pop() if visited[n] == 0: visited[n] = 1 if len(edge[n]) == 1: ans += 1 else: sub = edge[n] sub.pop(0) for i in sub: root.append(i) print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1068-%ED%8A%B8%EB%A6%AC-with-python/","summary":"📌 BOJ 1068 트리 💡 조건 트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.\n트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 문제.\n노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.\n다음과 같은 트리가 있다고 하자.\n현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다.\n검정색으로 색칠된 노드가 트리에서 제거된 노드이다.\n이제 리프 노드의 개수는 1개이다.","title":"[BOJ] 1068 트리 with Python"},{"content":"\n📌 알고리즘의 복잡도 계산 💡 성능분석 주어진 문제를 해결\n정확성\n문서화\n얼마나 주석을 잘 달았는가? / 관련 문서가 얼마나 잘 작성되었는가? 모듈화\n함수를 얼마나 체계적으로 잘 나누었는가? 가독성\n변수 또는 함수의 이름이 얼마나 의미있게 쓰였는가? 공간 효율성\n시간 효율성\n필수적인 요소 - 1, 2 좋은 프로그래밍의 습관 - 3, 4, 5 성능과 관련 - 6, 7 💡 성능 분석 VS 성능 측정 성능 분석 시뮬레이션, 복잡도 성능 측정 실제로 실행시켜서 실행 시간을 측정 💡 복잡도의 정의 공간 복잡도 : 프로그램 실행에 사용되는 메모리 시간 복잡도 : 프로그램 실행에 걸리는 시간 💡 시간복잡도 실행에 걸리는 시간(T[p]) = 컴파일 시간 + 실행 시간 컴파일 시간은 고정 and 한번만 필요 T[p]는 컴퓨터 사양에 따라 변화한다. 프로그램 단계수 (Program Step) 정의 : 실행시간이 프로그램의 특성과는 무관한 프로그램의 문법적인 혹은 논리적인 단위 프로그램 단계 수의 계산 프로그램에 CNT를 증가시키는 문장을 추가 테이블 방식을 활용 ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-2.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EA%B3%84%EC%82%B0/","summary":"📌 알고리즘의 복잡도 계산 💡 성능분석 주어진 문제를 해결\n정확성\n문서화\n얼마나 주석을 잘 달았는가? / 관련 문서가 얼마나 잘 작성되었는가? 모듈화\n함수를 얼마나 체계적으로 잘 나누었는가? 가독성\n변수 또는 함수의 이름이 얼마나 의미있게 쓰였는가? 공간 효율성\n시간 효율성\n필수적인 요소 - 1, 2 좋은 프로그래밍의 습관 - 3, 4, 5 성능과 관련 - 6, 7 💡 성능 분석 VS 성능 측정 성능 분석 시뮬레이션, 복잡도 성능 측정 실제로 실행시켜서 실행 시간을 측정 💡 복잡도의 정의 공간 복잡도 : 프로그램 실행에 사용되는 메모리 시간 복잡도 : 프로그램 실행에 걸리는 시간 💡 시간복잡도 실행에 걸리는 시간(T[p]) = 컴파일 시간 + 실행 시간 컴파일 시간은 고정 and 한번만 필요 T[p]는 컴퓨터 사양에 따라 변화한다.","title":"[CS] 2. 알고리즘의 복잡도 계산"},{"content":"\n","permalink":"https://jxun-h.github.io/posts/data-structure/temp/","summary":"","title":""},{"content":"\n📌 자료구조 💡 정의 문제해결을 위해 데이터를 조직하여 표현하는 방법 전화번호부 - List, Linked List, Tree 수강신청, 대기열 - Queue 지하철 노선도 - Graph 💡 중요성 주어진 문제의 특성에 맞는 자료구조를 선택한다. 프로그램의 개발이 쉽고 성능이 향상한다. 💡 추상 데이터 타입 (Abstract Data Type) 자료구조를 기술할 때 사용하는 방법\n데이터 객체 및 연산명세와 데이터 객체 내부 표현양식 / 연산의 구현 내용을 분리\n사용자가 원하는 서비스를 표현하는 부분과 서비스를 내부적으로 구현하는 부분을 분리하겠다. Ada Package, C++ Class ADT에서 연산의 명세\n구성요소 : 함수 이름, 인자들의 타입 함수의 호출 방법 및 결과물이 무엇인지를 설명 함수의 내부 동작과정 및 구현방법은 은폐 Information hiding 서비스에 대한 유지보스나 내용이 바뀔 때, 그 서비스를 사용하는 유저에 대한 영향을 최소화 시킬 수 있다. 💡 알고리즘의 정의 문제 해결을 위해 특정한 일을 수행하는 명령어들의 집합 💡 알고리즘이 만족해야할 조건 입력(Input) : 0 혹은 그 이상의 입력이 존재해야한다. 출력(Output) : 적어도 하나 이상의 결과물이 출력되어야한다. 명확성(Defineteness) : 알고리즘을 구성하는 명령어들의 의미는 명확해야하며, 애매모호해서는 안된다. 유한성(Finiteness) : 알고리즘은 한정된 수의 명령어들을 실행한 후 종료해야한다. 유효성/실행 가능성(Effectiveness) : 모든 명령어들은 실행가능해야한다. 코끼리 냉장고에 넣기 (명확성) 냉장고 문열기 코끼리 넣기 (실행가능성 X) 문 닫기위의 세가지는 유한성을 만족한다. ","permalink":"https://jxun-h.github.io/posts/data-structure/cs-1.-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%A0%95%EC%9D%98-%EB%B0%8F-%ED%91%9C%ED%98%84/","summary":"📌 자료구조 💡 정의 문제해결을 위해 데이터를 조직하여 표현하는 방법 전화번호부 - List, Linked List, Tree 수강신청, 대기열 - Queue 지하철 노선도 - Graph 💡 중요성 주어진 문제의 특성에 맞는 자료구조를 선택한다. 프로그램의 개발이 쉽고 성능이 향상한다. 💡 추상 데이터 타입 (Abstract Data Type) 자료구조를 기술할 때 사용하는 방법\n데이터 객체 및 연산명세와 데이터 객체 내부 표현양식 / 연산의 구현 내용을 분리\n사용자가 원하는 서비스를 표현하는 부분과 서비스를 내부적으로 구현하는 부분을 분리하겠다.","title":"[CS] 1. 자료구조의 정의와 알고리즘의 정의 및 표현"},{"content":"\n📌 BOJ 16956 늑대와 양 💡 조건 크기가 R×C인 목장이 있고, 목장은 1×1 크기의 칸으로 나누어져 있다.\n각각의 칸에는 비어있거나, 양 또는 늑대가 있다. 양은 이동하지 않고 위치를 지키고 있고, 늑대는 인접한 칸을 자유롭게 이동할 수 있다.\n두 칸이 인접하다는 것은 두 칸이 변을 공유하는 경우이다.\n목장에 울타리를 설치해 늑대가 양이 있는 칸으로 갈 수 없게 하려고 한다.\n늑대는 울타리가 있는 칸으로는 이동할 수 없다. 울타리를 설치해보자.\n목장의 크기 R, C가 주어진다.\nR개의 줄에 목장의 상태가 주어진다. \u0026lsquo;.\u0026lsquo;는 빈 칸, \u0026lsquo;S\u0026rsquo;는 양, \u0026lsquo;W\u0026rsquo;는 늑대이다.\n1 ≤ R, C ≤ 500\n늑대가 양이 있는 칸으로 갈 수 없게 할 수 있다면 첫째 줄에 1을 출력하고, 둘째 줄부터 R개의 줄에 목장의 상태를 출력한다.\n울타리는 \u0026lsquo;D\u0026rsquo;로 출력한다. 울타리를 어떻게 설치해도 늑대가 양이 있는 칸으로 갈 수 있다면 첫째 줄에 0을 출력한다.\n이 문제는 설치해야 하는 울타리의 최소 개수를 구하는 문제가 아니다.\n애드 혹, 구성적, 그래프 이론 유형의 문제\n🔖 예제 및 실행결과 예제 1 5 5 .S... ...S. S.... ...S. .S... 실행결과 1 1 .S... ...S. S.D.. ...S. .S... 예제 2 1 2 SW 실행결과 2 0 ⌨️ 문제 풀이 이 문제는 노트에 적혀있듯, 설치해야하는 최소 울타리 개수를 구하는 문제가 아니다.\n울타리를 설치해서 늑대가 양에게 접근할 수 있는지에 대해서 알아보면 되는 문제이다.\n그렇기 때문에, 늑대가 양에게 접근할 수 있다면 0, 없다면 1을 출력하고\n최소 몇 개의 울타리를 설치해야하는지 알아보는 것이 아니기 때문에, 울타리를 설치할 수 있는 모든 공간을 울타리로 바꿔준다.\n맵 정보를 입력받아 board에 입력할 때, 한 줄마다 문자 W 를 검색해 늑대의 좌표를 wolf 리스트에 저장해둔다.\nwolf 리스트를 순회하면서 해당 wolf 좌표에서 양에게 접근을 할 수 있으면 retrun False를 해주고 0을 출력해준 뒤, exit().\nreturn True 라면 1을 출력 후 board 상태를 출력해주면 된다.\n🖥 소스 코드 from collections import deque from sys import stdin r, c = map(int, stdin.readline().split()) board = [] wolf = [] dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] for i in range(r): data = list(stdin.readline().rstrip().replace(\u0026#39;.\u0026#39;, \u0026#39;D\u0026#39;)) board.append(data) for j in range(c): if data[j] == \u0026#39;W\u0026#39;: wolf.append((i, j)) def bfs(x, y): q = deque() q.append((x, y)) visited = set() visited.add((x, y)) while q: x, y = q.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if 0 \u0026lt;= nx \u0026lt; r and 0 \u0026lt;= ny \u0026lt; c: if (nx, ny) not in visited and board[nx][ny] != \u0026#39;D\u0026#39; and board[nx][ny] != \u0026#39;W\u0026#39;: if board[nx][ny] == \u0026#39;S\u0026#39;: return False else: visited.add((nx, ny)) q.append((nx, ny)) return True for x, y in wolf: if not bfs(x, y): print(0) exit() print(1) for i in board: print(*i, sep=\u0026#39;\u0026#39;) 💾 느낀점 가장 중요한 포인트는 최소 몇 개의 울타리를 설치해야하는지 알아보는 것이 아니다 라는 것에 중점을 두고 풀이해서 쉽게 풀 수 있었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-16956-%EB%8A%91%EB%8C%80%EC%99%80-%EC%96%91-with-python/","summary":"📌 BOJ 16956 늑대와 양 💡 조건 크기가 R×C인 목장이 있고, 목장은 1×1 크기의 칸으로 나누어져 있다.\n각각의 칸에는 비어있거나, 양 또는 늑대가 있다. 양은 이동하지 않고 위치를 지키고 있고, 늑대는 인접한 칸을 자유롭게 이동할 수 있다.\n두 칸이 인접하다는 것은 두 칸이 변을 공유하는 경우이다.\n목장에 울타리를 설치해 늑대가 양이 있는 칸으로 갈 수 없게 하려고 한다.\n늑대는 울타리가 있는 칸으로는 이동할 수 없다. 울타리를 설치해보자.\n목장의 크기 R, C가 주어진다.","title":"[BOJ] 16956 늑대와 양 with Python"},{"content":"\n📌 BOJ 12920 평범한 배낭 2 💡 조건 민호는 BOJ 캠프에 가기 위해 가방을 싸려고 한다. 가방에 어떠한 물건들을 넣냐에 따라 민호의 만족도가 달라진다.\n집에 있는 모든 물건들을 넣으면 민호가 느낄 수 있는 만족도는 최대가 될 것이다.\n하지만 민호가 들 수 있는 가방의 무게는 정해져 있어 이를 초과해 물건을 넣을수가 없다.\n민호가 만족도를 최대로 느낄 수 있는 경우를 찾아보자.\n단, 집에 동일한 물건들이 여러개가 있을 수 있기 때문에 한 물건을 두개 이상 챙기는 것도 가능하다.\n첫 번째 줄에 N, M (1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000) 이 빈칸을 구분으로 주어진다.\nN은 민호의 집에 있는 물건의 종류의 수이고 M은 민호가 들 수 있는 가방의 최대 무게다.\n두 번째 줄부터 N개의 줄에 걸쳐 민호의 집에 있는 물건의 정보가 주어진다.\n각의 줄은 V, C, K (1 ≤ V ≤ M, 1 ≤ C, K ≤ 10,000, 1 ≤ V * K ≤ 10,000) 으로 이루어져 있다.\nV는 물건의 무게, C는 물건을 가방에 넣었을 때 올라가는 민호의 만족도, K는 물건의 개수이다.\n최대 무게를 넘기지 않게 물건을 담았을 때 민호가 느낄 수 있는 최대 만족도를 출력한다.\n냅색 알고리즘, 비트마스킹 유형의 문제\n🔖 예제 및 실행결과 예제 2 3 2 7 1 1 9 3 실행결과 27 ⌨️ 문제 풀이 평범한 배낭 문제 시리즈이다.\n평범한 배낭 1 문제는 냅색, DP 문제이다.\n물품의 수 N, 버틸 수 있는 무게 K 라고 한다면 시간복잡도 O(NK)로 풀이할 수 있다.\n하지만 이 문제는 물건의 개수가 여러개이다. 즉, 물건이 중복으로 들어갈 수 있다는 것이다.\n물건이 중복으로 들어갈 수 있으며, V = 1, M = 10000, K = 10000 이라고 하면 while 반복문이 약 1억번 가까이 돌게 된다.\n이러면 무조건 TLE. 또한 일반 냅색에서는 2차원 배열을 이용했지만, 이 문제에서는 1차원 배열로 계산할 수 있다.\nO(NM * logK)로 해결할 수 있는 알고리즘을 생각해봐야한다.\n다른 분들의 풀이를 확인하니, 비트마스킹 아이디어를 통해서 수를 표현하는 것을 알 수 있었다.\n이 아이디어의 핵심은 모든 수는 2의 제곱수들의 합으로 표현할 수 있다는 것이다.\n만약 같은 물건이 약 15개라고 한다면 이를 2의 제곱수들의 합으로 표현했을 때, 1 + 2 + 4 + 8 로 표현할 수 있다.\n그렇다면 DP 테이블에 1개, 2개, 4개, 8개 추가한 경우를 갱신시켜주면 된다.\nDP 테이블을 M + 1 개 만들어주고, 무게와 만족도를 저장할 리스트를 생성한다.\n반복문을 N번 순회하면서 물건의 무게(V), 만족도(C), 물건의 개수(K)를 입력받는다.\n입력받은 물건을 한개 넣었을 경우부터 2 를 곱하면서 넣을 수 있는 개수를 계산하면서 만족도와 무게를 계산한다.\n계산한 각 값을 weight, satisfaction 리스트에 넣어준다. idx는 2를 곱해 2의 제곱수로 만들어준다.\n이미 계산한 2의 제곱수는 제외할 수 있도록 K에서 tmp를 빼준다.\n이후의 풀이는 냅색알고리즘과 같다.\nweight 리스트의 길이만큼 for 문을 순회(i)하고, 들 수 있는 최대 무게(M)부터 1까지 -1씩 내려가면서 순회(j)한다.\n이 때, j만큼 무게를 들 수 있을 때, weight 리스트의 i번째에 해당하는 물건을 넣을 수 있다면 dp[j]를 아래와 같이 갱신한다.\ndp[j] = max(dp[j], dp[j-weight[i]] + satisfaction[i]) dp[j] 째의 값과 (dp[현재 들 수 있는 최대무게 - i번째 물건의 무게] + i번째 물건의 만족도) 를 비교하여 갱신한다.\n🖥 소스 코드 N, M = map(int, input().split()) dp = [0 for _ in range(M+1)] weight, satisfaction = [], [] for _ in range(N): V, C, K = map(int, input().split()) idx = 1 while K \u0026gt; 0: tmp = min(idx, K) weight.append(V * tmp) satisfaction.append(C * tmp) idx *= 2 K -= tmp for i in range(len(weight)): for j in range(M, 0, -1): if j \u0026gt;= weight[i]: dp[j] = max(dp[j], dp[j-weight[i]] + satisfaction[i]) print(dp[M]) 💾 느낀점 안그래도 어려운 냅색에서 비트마스크의 개념이 들어가니 매우 어려웠다.\n냅색도 냅색이지만, 모든 자연수가 2의 거듭제곱 수로 나타낼 수 있다는 아이디어는 생각치도 못했다.\n(2)번의 아이디어를 기억하고 나중에 꼭 이러한 유형의 문제에서 적용할 수 있어야겠다.\n","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12920-%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD-2-with-python/","summary":"📌 BOJ 12920 평범한 배낭 2 💡 조건 민호는 BOJ 캠프에 가기 위해 가방을 싸려고 한다. 가방에 어떠한 물건들을 넣냐에 따라 민호의 만족도가 달라진다.\n집에 있는 모든 물건들을 넣으면 민호가 느낄 수 있는 만족도는 최대가 될 것이다.\n하지만 민호가 들 수 있는 가방의 무게는 정해져 있어 이를 초과해 물건을 넣을수가 없다.\n민호가 만족도를 최대로 느낄 수 있는 경우를 찾아보자.\n단, 집에 동일한 물건들이 여러개가 있을 수 있기 때문에 한 물건을 두개 이상 챙기는 것도 가능하다.","title":"[BOJ] 12920 평범한 배낭 2 with Python"},{"content":"\n📌 BOJ 14890 경사로 💡 조건 크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.\n오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다.\n길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.\n길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다.\n또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다.\n경사로는 높이가 항상 1이며, 길이는 L이다.\n또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다. 1.경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다. 2.낮은 칸과 높은 칸의 높이 차이는 1이어야 한다. 3.경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.\n아래와 같은 경우에는 경사로를 놓을 수 없다. 1.경사로를 놓은 곳에 또 경사로를 놓는 경우 2.낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우 3.낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우 4.경사로를 놓다가 범위를 벗어나는 경우\n지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 문제\n첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다.\n둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.\n구현 유형의 문제\n🔖 예제 및 실행결과 예제 6 2 3 2 1 1 2 3 3 2 2 1 2 3 3 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 2 2 3 3 3 3 2 2 실행결과 7 ⌨️ 문제 풀이 가로, 세로축을 검사해서 내리막길을 설치해서 이동이 가능한 길인지 살펴보는 문제이다.\n문제를 풀이할 때 가장 중요한 것은 경사로를 설치해서 이동이 가능한지를 알아보는 것이다.\n이를 알아보기 위해서 check 라는 함수를 통해 판별한다.\n경사로를 설치할 수 있는 조건은 문제에 제시되어 있지만 아래와 같이 다시 정리할 수 있다.\n경사로는 입력받은 L개의 연속된 공간에 설치할 수 있다. 낮은 칸과 높은 칸의 높이 차이는 1이어야 경사로를 설치할 수 있다. 같은 높이의 L개의 연속된 칸에 경사로를 설치할 수 있다. 경사로를 놓은 곳에는 다시 경사로를 놓을 수 없다. 경사로를 놓는 곳이 범위를 벗어날 수 없다. (2)번에 기재된 요약된 다섯가지의 조건 중 네번째를 보면 우리는 경사로를 설치한 곳을 표시하여 관리할 배열이 필요하다는 것을 알 수 있다.\n이를 소스코드에서 check 함수 내부에 sw 라는 리스트로 n 개만큼 False 로 초기화하여 만들어두었다.\n각 높이를 입력받은 arr을 행기준으로 한줄씩 순회하면서 check 함수를 통해 지나갈 수 있는 길인지 확인한다.\narr 리스트의 i 번째 리스트를 순회하면서 현재 순회하고 있는 높이(li[i])가\n그 다음 블럭의 높이(li[i + 1])와 같다면 continue를 해준다.\n만약 arr 리스트의 i 번째 리스트를 순회하면서 현재 순회하고 있는 높이 (li[i])와\n그 다음 블럭의 높이(li[i + 1])의 차이가 1보다 크다면 return False\n(2)번 의 2번 조건에 위배\n(6)번에서도 무사히 False를 return 하지 않았다면, 경사로를 설치한다.\n여기서 현재 순회하고 있는 i 번째 블럭이 i + 1 번째 블럭보다 크다면 i + 1 번째 블럭부터 i + 1 + L 번째 블럭까지 검사해야한다.\n이때 (2)번의 3번 조건에 위배되는지, (2)번의 4번 조건에 위배되는지 검사한다.\n또는 현재 순회하고 있는 i 번째 블럭이 i + 1 번째 블럭보다 작다면 i 번째 블럭부터 i - L 번째 블럭까지 검사해야한다.\n이때 (2)번의 3번 조건에 위배되는지, (2)번의 4번 조건에 위배되는지 검사한다.\n(7)번 혹은 (8)번에서 각각 조건에 위배된다면, return False\n위배되지 않는다면 sw 리스트에 True를 기재하여 경사로 설치 유무를 저장한다.\ncheck 함수로부터 반환받은 True or False 값에 따라 cnt 를 1씩 늘려준다.\n세로 검사는 따로 temp 리스트를 만들어 각 열을 순회하여 저장한 후, check 함수에 넘겨주고 검사하면 된다.\n🖥 소스 코드 from sys import stdin n, l = map(int, stdin.readline().split()) arr = [] for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) cnt = 0 def check(li): sw = [False for _ in range(n)] for i in range(n - 1): if li[i] == li[i + 1]: continue if abs(li[i] - li[i + 1]) \u0026gt; 1: return False if li[i] \u0026gt; li[i + 1]: temp = li[i + 1] for j in range(i + 1, i + 1 + l): if 0 \u0026lt;= j \u0026lt; n: if li[j] != temp: return False if sw[j]: return False sw[j] = True else: return False else: temp = li[i] for j in range(i, i - l, -1): if 0 \u0026lt;= j \u0026lt; n: if li[j] != temp: return False if sw[j]: return False sw[j] = True else: return False return True for i in arr: if check(i): cnt += 1 for i in range(n): temp = [] for j in range(n): temp.append(arr[j][i]) if check(temp): cnt += 1 print(cnt) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14890-%EA%B2%BD%EC%82%AC%EB%A1%9C-with-python/","summary":"📌 BOJ 14890 경사로 💡 조건 크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.\n오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다.\n길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.\n길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다.\n또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다.\n경사로는 높이가 항상 1이며, 길이는 L이다.","title":"[BOJ] 14890 경사로 with Python"},{"content":"\n📌 BOJ 9996 한국이 그리울 땐 서버에 접속하지 💡 조건 선영이는 한국에 두고온 서버에 접속해서 디렉토리 안에 들어있는 파일 이름을 보면서 그리움을 잊기로 했다.\n매일 밤, 파일 이름을 보면서 파일 하나하나에 얽힌 사연을 기억하면서 한국을 생각하고 있었다.\n한국에 있는 서버가 망가졌고, 그 결과 특정 패턴과 일치하는 파일 이름을 적절히 출력하지 못하는 버그가 생겼다.\n패턴은 알파벳 소문자 여러 개와 별표(*) 하나로 이루어진 문자열이다.\n파일 이름이 패턴에 일치하려면, 패턴에 있는 별표를 알파벳 소문자로 이루어진 임의의 문자열로 변환해 파일 이름과 같게 만들 수 있어야 한다.\n별표는 빈 문자열로 바꿀 수도 있다.\n예를 들어, \u0026ldquo;abcd\u0026rdquo;, \u0026ldquo;ad\u0026rdquo;, \u0026ldquo;anestonestod\u0026quot;는 모두 패턴 \u0026ldquo;a*d\u0026quot;와 일치한다. 하지만, \u0026ldquo;bcd\u0026quot;는 일치하지 않는다.\n패턴과 파일 이름이 모두 주어졌을 때, 각각의 파일 이름이 패턴과 일치하는지 아닌지를 구하는 문제\n첫째 줄에 파일의 개수 N이 주어진다. (1 ≤ N ≤ 100)\n문자열의 길이는 100을 넘지 않으며, 별표는 문자열의 시작과 끝에 있지 않다.\n다음 N개 줄에는 파일 이름이 주어진다.\n총 N개의 줄에 걸쳐서, 입력으로 주어진 i번째 파일 이름이 패턴과 일치하면 \u0026ldquo;DA\u0026rdquo;, 일치하지 않으면 \u0026ldquo;NE\u0026quot;를 출력한다.\n구현, 문자열, 브루트포스 유형의 문제\n🔖 예제 및 실행결과 예제 6 h*n huhovdjestvarnomozedocisvastan honijezakon atila je bio hun 실행결과 DA DA NE NE NE DA ⌨️ 문제 풀이 문제에서 보면 패턴은 알파벳 소문자와 별표 한 개로 이루어져있다는 정보가 있다.\n패턴은 *를 기준으로해서 split 해주고, 패턴 시작과 패턴 끝으로 구분한다.\n나눈 패턴의 시작과 끝을 비교하여 아래에 해당되는지 확인한다.\n1.입력받은 문자열을 시작 패턴의 길이만큼 잘라서 시작 패턴과 같은지 확인한다. 2.입력받은 문자열을 끝 패턴까지 잘라서 나눈 끝 패턴과 같은지 확인한다. 3.패턴을 의미하는 *을 제외한 문자열의 길이가 입력 받은 문자열의 길이보다 작거나 같은지 확인한다. 위 세가지 조건에 해당되지 않는 경우, match_tf 함수에서 False 를 return 한다.\nmatch_tf 가 False 일 경우, \u0026lsquo;DA\u0026rsquo; 출력\nmatch_tf 가 Ture 일 경우, \u0026lsquo;NE\u0026rsquo; 출력\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) pattern = stdin.readline().rstrip() def match_tf(p, s): p = p.split(\u0026#39;*\u0026#39;) start_m, end_m = p[0], p[1] if s[:len(start_m)] == start_m and s[-len(end_m):] == end_m and len(\u0026#39;\u0026#39;.join(p)) \u0026lt;= len(s): return True return False for _ in range(n): string = stdin.readline().rstrip() if match_tf(pattern, string): print(\u0026#39;DA\u0026#39;) else: print(\u0026#39;NE\u0026#39;) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9996-%ED%95%9C%EA%B5%AD%EC%9D%B4-%EA%B7%B8%EB%A6%AC%EC%9A%B8-%EB%95%90-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%91%EC%86%8D%ED%95%98%EC%A7%80-with-python/","summary":"📌 BOJ 9996 한국이 그리울 땐 서버에 접속하지 💡 조건 선영이는 한국에 두고온 서버에 접속해서 디렉토리 안에 들어있는 파일 이름을 보면서 그리움을 잊기로 했다.\n매일 밤, 파일 이름을 보면서 파일 하나하나에 얽힌 사연을 기억하면서 한국을 생각하고 있었다.\n한국에 있는 서버가 망가졌고, 그 결과 특정 패턴과 일치하는 파일 이름을 적절히 출력하지 못하는 버그가 생겼다.\n패턴은 알파벳 소문자 여러 개와 별표(*) 하나로 이루어진 문자열이다.\n파일 이름이 패턴에 일치하려면, 패턴에 있는 별표를 알파벳 소문자로 이루어진 임의의 문자열로 변환해 파일 이름과 같게 만들 수 있어야 한다.","title":"[BOJ] 9996 한국이 그리울 땐 서버에 접속하지 with Python"},{"content":"\n📌 BOJ 2225 합분해 💡 조건 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우).\n또한 한 개의 수를 여러 번 쓸 수도 있다.\n첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.\n첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.\n0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 문제\nDP, 다이나믹프로그래밍 유형의 문제\n🔖 예제 및 실행결과 예제 20 2 실행결과 21 ⌨️ 문제 풀이 0부터 N까지의 정수 K개를 이용해 N을 만드는 방법은 0부터 N개까지 k-1를 만드는 개수의 합과 같다.\n(1) 번을 점화식으로 표현하면 아래와 같다.\ndp[k][n] = dp[k - 1][n - l] (0 \u0026lt;= l \u0026lt;= n)\n(2)점화식에 따라서 n = 3, k = 3 일 경우는 아래와 같이 표현할 수 있습니다.\n이 점화식을 구현했을 때 시간복잡도는 O(n * k) 로 표현할 수 있습니다. 🖥 소스 코드 n, k = map(int, input().split()) mod = 1000000000 dp = [[0] * (n + 1) for _ in range(k + 1)] dp[0][0] = 1 for i in range(1, k + 1): for j in range(n + 1): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] dp[i][j] %= mod print(dp[k][n]) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2225-%ED%95%A9%EB%B6%84%ED%95%B4-with-python/","summary":"📌 BOJ 2225 합분해 💡 조건 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우).\n또한 한 개의 수를 여러 번 쓸 수도 있다.\n첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.\n첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.\n0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 문제\nDP, 다이나믹프로그래밍 유형의 문제\n🔖 예제 및 실행결과 예제 20 2 실행결과 21 ⌨️ 문제 풀이 0부터 N까지의 정수 K개를 이용해 N을 만드는 방법은 0부터 N개까지 k-1를 만드는 개수의 합과 같다.","title":"[BOJ] 2225 합분해 with Python"},{"content":"\n📌 BOJ 6236 용돈 관리 💡 조건 현우는 앞으로 N일 동안 자신이 사용할 금액을 계산하였고, 돈을 펑펑 쓰지 않기 위해 정확히 M번만 통장에서 돈을 빼서 쓰기로 하였다.\n현우는 통장에서 K원을 인출하며, 통장에서 뺀 돈으로 하루를 보낼 수 있으면 그대로 사용하고,\n모자라게 되면 남은 금액은 통장에 집어넣고 다시 K원을 인출한다.\n다만 현우는 M이라는 숫자를 좋아하기 때문에, 정확히 M번을 맞추기 위해서 남은 금액이 그날 사용할 금액보다\n많더라도 남은 금액은 통장에 집어넣고 다시 K원을 인출할 수 있다.\n현우는 돈을 아끼기 위해 인출 금액 K를 최소화하기로 하였다. 현우가 필요한 최소 금액 K를 계산하는 문제.\n1번째 줄에는 N과 M이 공백으로 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ N)\n2번째 줄부터 총 N개의 줄에는 현우가 i번째 날에 이용할 금액이 주어진다. (1 ≤ 금액 ≤ 10000)\n첫 번째 줄에 현우가 통장에서 인출해야 할 최소 금액 K를 출력한다.\n이분탐색 유형의 문제\n🔖 예제 및 실행결과 예제 7 5 100 400 300 100 500 101 400 실행결과 500 ⌨️ 문제 풀이 i번째 날에 이용할 금액을 리스트에 저장해주고 가장 작은 값을 start, 가장 큰 값을 end로 설정해준다.\n구할 인출금액을 mid = (start + end) // 2로 정해주고, 인출한 횟수 cnt를 1로 설정한다.\n리스트를 순회하면서(x : 현재 순회하는 리스트의 인덱스에 해당하는 금액) 최소 인출금액 - x 의 값이 0보다 작으면\n인출금액 money를 mid 로 저장한다.\n만약 이 조건에 해당하지 않는다면 money - i 값으로 money를 갱신한다.\narr 리스트를 모두 순회한 후, 출금 횟수가 m 을 넘어선 경우 혹은 mid 값이 arr의 값보다 작은 경우는\nstart 를 mid + 1 값으로 갱신한다.\n(4)번의 조건에 해당하지 않는다면, end 값을 end - 1 로 갱신한다.\n또한 ans의 값을 mid 로 갱신한다.\n이분탐색이 끝나면 ans 의 값을 출력한다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [] for _ in range(n): arr.append(int(stdin.readline())) start = min(arr) end = sum(arr) while start \u0026lt;= end: mid = (start + end) // 2 money = mid cnt = 1 for i in arr: if money - i \u0026lt; 0: money = mid cnt += 1 money -= i if cnt \u0026gt; m or mid \u0026lt; max(arr): start = mid + 1 else: end = mid - 1 ans = mid print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-6236-%EC%9A%A9%EB%8F%88-%EA%B4%80%EB%A6%AC-with-python/","summary":"📌 BOJ 6236 용돈 관리 💡 조건 현우는 앞으로 N일 동안 자신이 사용할 금액을 계산하였고, 돈을 펑펑 쓰지 않기 위해 정확히 M번만 통장에서 돈을 빼서 쓰기로 하였다.\n현우는 통장에서 K원을 인출하며, 통장에서 뺀 돈으로 하루를 보낼 수 있으면 그대로 사용하고,\n모자라게 되면 남은 금액은 통장에 집어넣고 다시 K원을 인출한다.\n다만 현우는 M이라는 숫자를 좋아하기 때문에, 정확히 M번을 맞추기 위해서 남은 금액이 그날 사용할 금액보다\n많더라도 남은 금액은 통장에 집어넣고 다시 K원을 인출할 수 있다.","title":"[BOJ] 6236 용돈 관리 with Python"},{"content":"\n📌 BOJ 1700 멀티탭 스케줄링 💡 조건 기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다.\n준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을\n사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다.\n준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고,\n이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.\n3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면,\n1.키보드 2.헤어드라이기 3.핸드폰 충전기 4.디지털 카메라 충전기 5.키보드 6.헤어드라이기 키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음\n디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다.\n첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 100)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 100)가 정수로 주어진다.\n두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다.\n그리디 알고리즘 유형의 문제\n🔖 예제 및 실행결과 예제 2 7 2 3 2 3 1 2 7 실행결과 2 ⌨️ 문제 풀이 사용하는 전기용품을 리스트에 저장하고, 다음에 사용할 전기용품 번호를 검사하면서 최소 횟수를 출력하는 문제이다.\n전기용품은 사용할 순서가 정해져 있다.\n플러그 리스트에는 n개만큼 전기용품 번호가 들어가게 되는데, 모든 플러그가 사용중이지 않거나\n다음에 사용할 전기용품의 번호가 플러그에 있다면 continue.\n사용할 전기용품의 번호가 플러그 리스트에 없고, 모든 플러그가 사용중이라면 index를 저장할 인덱스 리스트를 생성한다.\n만약 다음 사용순서가 없다면 총 사용횟수의 최댓값이 100 이기 때문에 101로 저장하여 다음에 사용할 일이 없다는 것을 표시해준다.\nplug_out 을 인덱스 리스트의 가장 큰 인덱스로 정하는데, 그 이유는 다음 사용 순서가 없거나 가장 멀리 있기 때문에 플러그에서 삭제한다.\n플러그에 사용할 전기용품의 번호를 추가하고, 플러그에서 전기용품을 빼는 횟수에 1을 더한다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) electronics = list(map(int, stdin.readline().split())) plug, ans = [], 0 for i in range(m): if electronics[i] in plug: continue if len(plug) \u0026lt; n: plug.append(electronics[i]) continue indexs = [] for j in range(n): try: idx = electronics[i:].index(plug[j]) except: idx = 101 indexs.append(idx) pull_out = indexs.index(max(indexs)) del plug[pull_out] plug.append(electronics[i]) ans += 1 print(ans) 💾 느낀점 그리디를 풀기 위한 풀이를 떠올릴 때의 흐름이 잘 되지않는 것이 매우 힘든 일인 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1700-%EB%A9%80%ED%8B%B0%ED%83%AD-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-with-python/","summary":"📌 BOJ 1700 멀티탭 스케줄링 💡 조건 기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다.\n준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을\n사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다.\n준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고,\n이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.\n3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면,","title":"[BOJ] 1700 멀티탭 스케줄링 with Python"},{"content":"\n📌 BOJ 10451 순열 사이클 💡 조건 1부터 N까지 정수 N개로 이루어진 순열을 나타내는 방법은 여러 가지가 있다.\n순열 그래프 (3, 2, 7, 8, 1, 4, 5, 6) 에는 총 3개의 사이클이 있다. 이러한 사이클을 \u0026ldquo;순열 사이클\u0026rdquo; 이라고 한다.\nN개의 정수로 이루어진 순열이 주어졌을 때, 순열 사이클의 개수를 구하는 프로그램을 작성하시오.\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.\n각 테스트 케이스의 첫째 줄에는 순열의 크기 N (2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 순열이 주어지며, 각 정수는 공백으로 구분되어 있다.\n각 테스트 케이스마다, 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력한다.\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 2 8 3 2 7 8 1 4 5 6 10 2 1 3 4 5 6 7 9 10 8 실행결과 3 7 ⌨️ 문제 풀이 테스트 케이스 수만큼 입력된 데이터를 문제에 제시된 방법철머 그래프로 만들어서 사이클을 세어주는 문제이다.\n그래프를 순회하면서 visited 변수를 set()으로 만들어 주고 방문처리를 해준다.\n사이클을 세어준 뒤, 개수를 출력해주면 된다.\n🖥 소스 코드 from collections import deque from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) def get_cnt(x, graph, visited): q = deque() q.append(x) visited.add(x) while q: now = q.popleft() for y in list(graph[now]): if y not in visited: q.append(y) visited.add(y) return 1 def solve(temp): global ans res = 0 graph = [[] for _ in range(n + 1)] for i in range(n): graph[temp[i]].append(arr[i]) visited = set() for i in range(1, n + 1): if i not in visited: res += get_cnt(i, graph, visited) ans = max(res, ans) for _ in range(int(stdin.readline())): n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) ans = 0 solve([x for x in range(1, n + 1)]) print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10451-%EC%88%9C%EC%97%B4-%EC%82%AC%EC%9D%B4%ED%81%B4-with-python/","summary":"📌 BOJ 10451 순열 사이클 💡 조건 1부터 N까지 정수 N개로 이루어진 순열을 나타내는 방법은 여러 가지가 있다.\n순열 그래프 (3, 2, 7, 8, 1, 4, 5, 6) 에는 총 3개의 사이클이 있다. 이러한 사이클을 \u0026ldquo;순열 사이클\u0026rdquo; 이라고 한다.\nN개의 정수로 이루어진 순열이 주어졌을 때, 순열 사이클의 개수를 구하는 프로그램을 작성하시오.\n첫째 줄에 테스트 케이스의 개수 T가 주어진다.\n각 테스트 케이스의 첫째 줄에는 순열의 크기 N (2 ≤ N ≤ 1,000)이 주어진다.","title":"[BOJ] 10451 순열 사이클 with Python"},{"content":"\n📌 BOJ 14499 주사위 굴리기 💡 조건 크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다.\n이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다.\n지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. 주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며,\n놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.\n지도의 각 칸에는 정수가 하나씩 쓰여져 있다.\n주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다.\n0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.\n주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.\n주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.\n첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20),\n주사위를 놓은 곳의 좌표 x, y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.\n둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다.\n주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10 미만의 자연수 또는 0이다.\n마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.\n구현, 시뮬레이션 유형의 문제\n🔖 예제 및 실행결과 예제 3 3 0 0 16 0 1 2 3 4 5 6 7 8 4 4 1 1 3 3 2 2 4 4 1 1 3 3 2 2 실행결과 0 0 0 6 0 8 0 2 0 8 0 2 0 8 0 2 ⌨️ 문제 풀이 문제에서 요구한 대로 풀면 되는 구현문제이다. 🖥 소스 코드 from sys import stdin n, m, x, y, command_nums = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) command = list(map(int, stdin.readline().split())) dice = [0 for _ in range(6)] dice[0] = board[x][y] dx, dy = [0, 0, -1, 1], [1, -1, 0, 0] for c in command: nx, ny = x + dx[c - 1], y + dy[c - 1] if 0 \u0026lt;= nx \u0026lt; n and 0 \u0026lt;= ny \u0026lt; m: if c == 1: dice[4], dice[5], dice[2], dice[0] = dice[0], dice[4], dice[5], dice[2] elif c == 2: dice[2], dice[5], dice[4], dice[0] = dice[0], dice[2], dice[5], dice[4] elif c == 3: dice[1], dice[5], dice[3], dice[0] = dice[0], dice[1], dice[5], dice[3] elif c == 4: dice[3], dice[5], dice[1], dice[0] = dice[0], dice[3], dice[5], dice[1] if board[nx][ny] == 0: board[nx][ny] = dice[0] else: dice[0] = board[nx][ny] board[nx][ny] = 0 x, y = nx, ny print(dice[5]) 💾 느낀점 더러워.. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14499-%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B5%B4%EB%A6%AC%EA%B8%B0-with-python/","summary":"📌 BOJ 14499 주사위 굴리기 💡 조건 크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다.\n이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다.\n지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. 주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며,\n놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.","title":"[BOJ] 14499 주사위 굴리기 with Python"},{"content":"\n📌 BOJ 1525 퍼즐 💡 조건 3×3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.\n1 2 3 4 5 6 7 8 9 어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다.\n물론 표 바깥으로 나가는 경우는 불가능하다.\n우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.\n1 3 9 4 2 5 7 8 6 1 2 3 4 5 9 7 8 6 1 2 3 4 5 9 7 8 6 1 2 3 4 5 6 7 8 9 가장 윗 상태에서 세 번의 이동을 통해 정리된 상태를 만들 수 있다. 이와 같이 최소 이동 횟수를 구하는 프로그램을 작성하시오.\n세 줄에 걸쳐서 표에 채워져 있는 아홉 개의 수가 주어진다. 한 줄에 세 개의 수가 주어지며, 빈 칸은 0으로 나타낸다.\n첫째 줄에 최소의 이동 횟수를 출력한다. 이동이 불가능한 경우 -1을 출력한다.\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 1 0 3 4 2 5 7 8 6 실행결과 3 ⌨️ 문제 풀이 퍼즐의 숫자를 옮기면서 상태를 저장하고, 정렬된 상태가 확인되었으면 cnt를 리턴해준다.\n최소 이동 횟수를 출력해주려고 했으나, 이동을 하지 못하는 경우에는 -1를 출력한다.\n🖥 소스 코드 from collections import deque from sys import stdin arr = [] c = [1, 2, 3, 4, 5, 6, 7, 8, 0] x, y = 0, 0 for i in range(3): data = list(map(int, stdin.readline().split())) arr.append(data) for j in range(3): if data[j] == 0: x, y = i, j dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] def swap(a, b): return b, a def solve(x, y): q = deque() temp = [] for p in arr: temp.extend(p) q.append((0, x, y, temp)) visited = set() while q: cnt, x, y, check_list = q.popleft() # visited.discard(tuple(check_list)) if check_list == c: return cnt else: temp = [check_list[idx:idx + 3] for idx in range(0, 7, 3)] for i in range(4): nx, ny = x + dx[i], y + dy[i] if 0 \u0026lt;= nx \u0026lt; 3 and 0 \u0026lt;= ny \u0026lt; 3: temp[x][y], temp[nx][ny] = swap(temp[x][y], temp[nx][ny]) concat_list = [] for i in temp: concat_list.extend(i) if tuple(concat_list) not in visited: visited.add(tuple(concat_list)) q.append((cnt + 1, nx, ny, concat_list)) temp[x][y], temp[nx][ny] = swap(temp[x][y], temp[nx][ny]) return -1 print(solve(x, y)) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1525-%ED%8D%BC%EC%A6%90-with-python/","summary":"📌 BOJ 1525 퍼즐 💡 조건 3×3 표에 다음과 같이 수가 채워져 있다. 오른쪽 아래 가장 끝 칸은 비어 있는 칸이다.\n1 2 3 4 5 6 7 8 9 어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수가 있다.\n물론 표 바깥으로 나가는 경우는 불가능하다.\n우리의 목표는 초기 상태가 주어졌을 때, 최소의 이동으로 위와 같은 정리된 상태를 만드는 것이다. 다음의 예를 보자.","title":"[BOJ] 1525 퍼즐 with Python"},{"content":"\n📌 BOJ 1915 가장 큰 정사각형 💡 조건 아래와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다. 첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다.\n다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.\nn×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 문제.\nDP, 다이나믹프로그래밍 유형의 문제\n🔖 예제 및 실행결과 예제 4 4 0100 0111 1110 0010 실행결과 4 ⌨️ 문제 풀이 가장 큰 정사각형의 넓이를 구해야하는데, 정사각형이 되는 상태를 dp 배열에 저장하면서 가장 큰 변의 길이를 구하면 된다.\n한 칸도 정사각형이 될 수 있기에, 최소 넓이의 값은 1이다.\n현재 순회하고 있는 좌표 x, y 를 기준으로 x-1, y-1 이 1일 때\ndp 리스트의 현재 순회하는 좌표 x, y를 기준으로 왼쪽, 위, 왼쪽 대각선을 살펴보고 가장 작은 값 + 1을 구해\ndp[x][y]에 저장하고, 이 값을 ans 값과 비교하여 가장 큰 값으로 갱신한다.\n리스트를 모두 순회했다면, 저장된 ans 값을 제곱하여 넓이를 구하고 출력한다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [] for _ in range(n): arr.append(list(map(int, list(stdin.readline().rstrip())))) ans = 0 dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if arr[i - 1][j - 1] == 1: dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1 ans = max(ans, dp[i][j]) print(ans ** 2) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1915-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-with-python/","summary":"📌 BOJ 1915 가장 큰 정사각형 💡 조건 아래와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다. 첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다.\n다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.\nn×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 문제.\nDP, 다이나믹프로그래밍 유형의 문제\n🔖 예제 및 실행결과 예제 4 4 0100 0111 1110 0010 실행결과 4 ⌨️ 문제 풀이 가장 큰 정사각형의 넓이를 구해야하는데, 정사각형이 되는 상태를 dp 배열에 저장하면서 가장 큰 변의 길이를 구하면 된다.","title":"[BOJ] 1915 가장 큰 정사각형 with Python"},{"content":"\n📌 BOJ 2644 촌수계산 💡 조건 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다.\n아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.\n여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.\n사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다.\n입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다.\n셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다.\n넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.\n각 사람의 부모는 최대 한 명만 주어진다.\n입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다.\n어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 9 8 6 7 1 2 1 3 2 7 2 8 2 9 4 5 4 6 실행결과 -1 ⌨️ 문제 풀이 촌수를 계산하여 몇 촌인지 출력하려고 하는 문제이기 때문에 그래프 탐색으로 풀이할 수 있다.\n요구한 두 사람의 촌수를 구해야하기 때문에 양방향 그래프를 만들어 BFS를 사용해 촌수를 구하고 출력하면 된다.\nBFS 알고리즘을 통해 나온 값이 False 라면 -1을 출력하고 아니라면 결과값을 출력하면 된다.\n🖥 소스 코드 from sys import stdin from collections import deque n = int(stdin.readline()) a, b = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] for _ in range(int(stdin.readline())): k, p = map(int, stdin.readline().split()) graph[k].append(p) graph[p].append(k) def solve(x): q = deque() q.append((x, 0)) visited = set() visited.add(x) while q: now, c = q.popleft() if now == b: return c for i in graph[now]: if i not in visited: q.append((i, c + 1)) visited.add(i) return False ans = solve(a) print(ans) if ans else print(-1) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2644-%EC%B4%8C%EC%88%98%EA%B3%84%EC%82%B0-with-python/","summary":"📌 BOJ 2644 촌수계산 💡 조건 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다.\n아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.\n여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.\n사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다.\n입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다.","title":"[BOJ] 2644 촌수계산 with Python"},{"content":"\n📌 BOJ 1520 내리막 길 💡 조건 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다.\n한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.\n현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다.\n그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다.\n위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.\n지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지\n항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.\n첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다.\n이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다.\nM과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.\n첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.\nDFS, DP 유형의 문제\n🔖 예제 및 실행결과 예제 4 5 50 45 37 32 30 35 50 40 20 25 30 30 25 17 28 27 24 22 15 10 실행결과 3 ⌨️ 문제 풀이 제일 오른쪽 아래지점은 DP[N][M] 에서, DP[N - 1][M] + DP[N][M - 1] 이다.\n(0, 0)부터 시작하여 DFS로 진행을 하면서 갈 수 있는 경로에 대해서 계산한다.\nDP에는 경우의 수를 저장하면서 진행하면 되는데, 문제에서 나왔듯이, 입력받은 board 에서 현재 위치한 위치의 값보다\n적어야 움직일 수 있기 때문에 DFS 함수를 코딩할 때 조건문이 필요하다.\n만약 방문이 되지 않은 곳이라면 DP 리스트에 -1로 표현될 수 있게 DP 리스트를 -1 로 모두 채워서 구현한다.\n현재 방문한 좌표가 방문을 이미 했던 곳이라면 바로 현재 좌표의 DP 리스트를 return 한다.\n🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) n, m = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) dp = [[-1] * m for _ in range(n)] dx, dy = [1, 0, 0, -1], [0, -1, 1, 0] def solve(x, y): global ans if (x, y) == (n - 1, m - 1): return 1 if dp[x][y] != -1: return dp[x][y] dp[x][y] = 0 for i in range(4): nx, ny = x + dx[i], y + dy[i] if 0 \u0026lt;= nx \u0026lt; n and 0 \u0026lt;= ny \u0026lt; m: if board[x][y] \u0026gt; board[nx][ny]: dp[x][y] += solve(nx, ny) return dp[x][y] print(solve(0, 0)) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1520-%EB%82%B4%EB%A6%AC%EB%A7%89-%EA%B8%B8-with-python/","summary":"📌 BOJ 1520 내리막 길 💡 조건 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다.\n한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.\n현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다.\n그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다.","title":"[BOJ] 1520 내리막 길 with Python"},{"content":"\n📌 BOJ 2512 예산 💡 조건 국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다.\n국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다.\n그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다.\n모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다. 여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 문제.\n첫째 줄에는 지방의 수를 의미하는 정수 N이 주어진다. N은 3 이상 10,000 이하이다.\n다음 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 값들은 모두 1 이상 100,000 이하이다.\n그 다음 줄에는 총 예산을 나타내는 정수 M이 주어진다. M은 N 이상 1,000,000,000 이하이다.\n이분탐색 유형의 문제\n🔖 예제 및 실행결과 예제 4 120 110 140 150 485 실행결과 127 ⌨️ 문제 풀이 총 예산을 나타내는 M이 N 이상 1,000,000,000 이하이다.\n이 큰 값을 N부터 탐색하면 시간초과가 걸리기 때문에 이분탐색을 사용해 총예산에서 상한액을 찾아주면 된다.\n요청한 예산들을 담은 arr 리스트의 max 값을 r, 0을 l로 두고 이분탐색을 진행한다.\n(l + r) // 2 값을 mid 로 두고 arr 리스트를 순회하면서 mid 값과 순회하는 값을 비교해 작은 값을 total 에 넣어준다.\ntotal 이 m 값보다 클 때는 r을 mid로 땡겨주고, 그 외의 상황일 때는 ans의 값과 비교해서 큰 값을 ans 에 저장한다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) m = int(stdin.readline()) start, end = 0, max(arr) ans = -int(1e9) while start \u0026lt;= end: mid = (start + end) // 2 total = 0 for i in arr: total += min(i, mid) if total \u0026gt; m: end = mid - 1 else: start = mid + 1 ans = max(ans, mid) print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2512-%EC%98%88%EC%82%B0-with-python/","summary":"📌 BOJ 2512 예산 💡 조건 국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다.\n국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다.\n그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다.\n모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다.","title":"[BOJ] 2512 예산 with Python"},{"content":"\n📌 BOJ 1238 파티 💡 조건 N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.\nN명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다.\n이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다.\n각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다.\n하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다.\n이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다.\nN명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생은 누구일지 구하여라.\nN(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), X가 공백으로 구분되어 입력된다.\n시작점과 끝점이 같은 도로는 없으며, 시작점과 한 도시 A에서 다른 도시 B로 가는 도로의 개수는 최대 1개이다.\n모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.\n그래프탐색, 다익스트라 유형의 문제\n🔖 예제 및 실행결과 예제 4 8 2 1 2 4 1 3 2 1 4 7 2 1 1 2 3 5 3 1 2 3 4 4 4 2 3 실행결과 10 ⌨️ 문제 풀이 \u0026ldquo;최단 시간에 오고 가기를 원한다.\u0026rdquo; 라는 대목에서 다익스트라를 생각해볼 수 있다.\n또한 문제에서 M개의 단방향 도로들이 있다는 정보가 있다.\n(1)번의 정보를 통해 단방향 그래프에서 최단거리를 찾으면 된다는 결론이 나온다.\n🖥 소스 코드 from sys import stdin import heapq n, m, x = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] ans = [0 for _ in range(n)] for _ in range(m): a, b, c = map(int, stdin.readline().split()) graph[a].append((c, b)) def solve(start): q = [] heapq.heappush(q, (0, start)) dist = [int(1e9) for _ in range(n + 1)] dist[start] = 0 while q: cost, now = heapq.heappop(q) for d, next_pos in graph[now]: if dist[next_pos] \u0026gt; cost + d: dist[next_pos] = cost + d heapq.heappush(q, (cost + d, next_pos)) return dist r = -1 for i in range(1, n + 1): if i != x: go = solve(i)[x] goal = solve(x)[i] r = max(r, go + goal) print(r) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1238-%ED%8C%8C%ED%8B%B0-with-python/","summary":"📌 BOJ 1238 파티 💡 조건 N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.\nN명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다.\n이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다.\n각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다.\n하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다.\n이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다.","title":"[BOJ] 1238 파티 with Python"},{"content":"\n📌 BOJ 1309 동물원 💡 조건 어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.\n이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다.\n동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성하는 문제.\n사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.\n첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.\n첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하자.\nDP, 다이나믹 프로그래밍 유형의 문제\n🔖 예제 및 실행결과 예제 4 실행결과 41 ⌨️ 문제 풀이 n의 크기가 최대 10만이며, 2 * N 배열에 사자를 배치할 수 있는 경우를 구해야하며, 사자를 배치하는 경우의 수를 9901로 나누어야한다.\n이러한 문제는 N의 크기가 크고, 경우의 수를 구해야하기 때문에 브루트포스 같은 알고리즘으로 해결하려고 하면 시간초과가 발생한다.\n그렇기 때문에 우리가 생각할 수 있는 알고리즘은 다이나믹 프로그래밍이 있겠다.\nn 이 1일 때는 1 * n = 2. 세가지의 경우가 있다.\nn 이 2일 때에는 7가지, n 이 3일 때에는 17가지가 된다.\n이를 통해서 dp[i] = (dp[i-1] * 2 + dp[i-2]) % 9901 라고 할 수 있다.\n이를 통해서 dp list 를 채워 입력으로 받은 n에 해당하는 경우의 수를 출력하며 된다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) dp = [0 for _ in range(100001)] dp[1], dp[2], dp[3] = 3, 7, 17 for i in range(4, 100001): dp[i] = (dp[i - 1] * 2 + dp[i - 2]) % 9901 print(dp[n]) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1309-%EB%8F%99%EB%AC%BC%EC%9B%90-with-python/","summary":"📌 BOJ 1309 동물원 💡 조건 어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.\n이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다.\n동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성하는 문제.\n사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.\n첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.\n첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하자.","title":"[BOJ] 1309 동물원 with Python"},{"content":"\n📌 BOJ 1057 토너먼트 💡 조건 N명의 참가자는 번호가 1번부터 N번까지 배정받는다.\n그러고 난 후에 서로 인접한 번호끼리 스타를 한다. 이긴 사람은 다음 라운드에 진출하고, 진 사람은 그 라운드에서 떨어진다.\n그 라운드의 참가자가 홀수명이라면, 마지막 번호를 가진 참가자는 다음 라운드로 자동 진출한다. 다음 라운드에선 다시 참가자의 번호를 1번부터 매긴다.\n번호를 매기는 순서는 처음 번호의 순서를 유지하면서 1번부터 매긴다.\n이 말은 1번과 2번이 스타를 해서 1번이 진출하고, 3번과 4번이 스타를 해서 4번이 진출했다면, 4번은 다음 라운드에서 번호 2번을 배정받는다.\n번호를 다시 배정받은 후에 한 명만 남을 때까지 라운드를 계속 한다.\n일단 김지민과 임한수는 서로 대결하기 전까지 항상 이긴다고 가정한다.\n1 라운드에서 김지민의 번호와 임한수의 번호가 주어질 때, 과연 김지민과 임한수가 몇 라운드에서 대결하는지 출력하는 문제\n참가자의 수 N과 1 라운드에서 김지민의 번호와 임한수의 번호가 순서대로 주어진다.\nN은 2보다 크거나 같고, 100,000보다 작거나 같은 자연수이고, 김지민의 번호와 임한수의 번호는 N보다 작거나 같은 자연수이고, 서로 다르다.\n첫째 줄에 김지민과 임한수가 대결하는 라운드 번호를 출력한다. 만약 서로 대결하지 않을 때는 -1을 출력한다.\n브루트포스 알고리즘 유형의 문제\n🔖 예제 및 실행결과 예제 65536 1000 35000 실행결과 16 ⌨️ 문제 풀이 총 참가자의 수만큼 team list 를 만든다. 이 리스트에 김지민과 임한수의 번호를 표시한다.\nsolve 함수에서 김지민과 임한수일 때 temp 리스트에 1을 추가하고 아닌 경우, 0을 추가한다.\n부전승인 경우, 맨 마지막 인원을 temp에 추가한다.\n점점 반으로 줄어드는 팀을 재귀로 구현해서 순회한다.\nteam 리스트의 값이 둘 다 1 이면 라운드를 return한다.\n🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) data = list(map(int, stdin.readline().split())) team = [0 for _ in range(1, data[0] + 1)] for i in data[1:]: team[i - 1] = 1 def solve(round, length): global team temp = [] for i in range(0, length // 2 * 2, 2): t1, t2 = i, i + 1 if team[t1] and team[t2]: return round elif team[t1] or team[t2]: temp.append(1) else: temp.append(0) if length % 2 != 0: temp.append(team[-1]) team = temp[:] if length % 2 != 0: return solve(round + 1, length // 2 + 1) else: return solve(round + 1, length // 2) print(solve(1, data[0])) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1057-%ED%86%A0%EB%84%88%EB%A8%BC%ED%8A%B8-with-python/","summary":"📌 BOJ 1057 토너먼트 💡 조건 N명의 참가자는 번호가 1번부터 N번까지 배정받는다.\n그러고 난 후에 서로 인접한 번호끼리 스타를 한다. 이긴 사람은 다음 라운드에 진출하고, 진 사람은 그 라운드에서 떨어진다.\n그 라운드의 참가자가 홀수명이라면, 마지막 번호를 가진 참가자는 다음 라운드로 자동 진출한다. 다음 라운드에선 다시 참가자의 번호를 1번부터 매긴다.\n번호를 매기는 순서는 처음 번호의 순서를 유지하면서 1번부터 매긴다.\n이 말은 1번과 2번이 스타를 해서 1번이 진출하고, 3번과 4번이 스타를 해서 4번이 진출했다면, 4번은 다음 라운드에서 번호 2번을 배정받는다.","title":"[BOJ] 1057 토너먼트 with Python"},{"content":"\n📌 BOJ 20438 출석체크 💡 조건 학생들은 접속 순서대로 3번부터 N + 2번까지 입장 번호를 받게 된다.\n지환이가 한 학생에게 출석 코드를 보내게 되면, 해당 학생은 본인의 입장 번호의 배수인 학생들에게 출석 코드를 보내어\n해당 강의의 출석을 할 수 있게끔 한다. 하지만, K명의 졸고 있는 학생들은 출석 코드를 제출하지 않고, 다른 학생들에게 보내지 않는다.\n지환이는 무작위로 한 명의 학생에게 출석 코드를 보내는 행위를 Q번 반복한 뒤,\n출석부 정리를 위해 특정 구간의 입장 번호를 받은 학생들 중에서 출석이 되지 않은 학생들의 수를 구하고 싶다.\n1번째 줄에 학생의 수 N, 졸고 있는 학생의 수 K, 지환이가 출석 코드를 보낼 학생의 수 Q, 주어질 구간의 수 M이 주어진다.\n(1 ≤ K, Q ≤ N ≤ 5,000, 1 ≤ M ≤ 50,000)\n2번째 줄과 3번째 줄에 각각 K명의 졸고 있는 학생의 입장 번호들과 Q명의 출석 코드를 받을 학생의 입장 번호들이 주어진다.\n4번째 줄부터 M개의 줄 동안 구간의 범위 S, E가 공백을 사이에 두고 주어진다. (3 ≤ S \u0026lt; E ≤ N + 2)\n누적합, 구현 유형의 문제\n🔖 예제 및 실행결과 예제 50 4 5 1 24 15 27 43 3 4 6 20 25 3 52 실행결과 25 ⌨️ 문제 풀이 자는 인원을 먼저 sleep 리스트에 표시해준다.\n그 후, 해당 구간에 대해 출석체크를 정상적으로 한 인원에 대해서 구간합을 구해준다.\n문제에서 요구하는 구간에 대해서 구간의 합을 구해서 출력한다.\n🖥 소스 코드 from sys import stdin n, k, q, m = map(int, stdin.readline().split()) sleep = [0 for _ in range(n + 3)] check = [0 for _ in range(n + 3)] for i in map(int, stdin.readline().split()): sleep[i] = 1 for i in map(int, stdin.readline().split()): if sleep[i]: continue for j in range(i, n + 3, i): if not sleep[j]: check[j] = 1 pre = [check[0]] for i in range(1, n + 3): pre.append(pre[-1] + check[i]) for _ in range(m): s, e = map(int, stdin.readline().split()) print(e - s + 1 - pre[e] - pre[s - 1]) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20438-%EC%B6%9C%EC%84%9D%EC%B2%B4%ED%81%AC-with-python/","summary":"📌 BOJ 20438 출석체크 💡 조건 학생들은 접속 순서대로 3번부터 N + 2번까지 입장 번호를 받게 된다.\n지환이가 한 학생에게 출석 코드를 보내게 되면, 해당 학생은 본인의 입장 번호의 배수인 학생들에게 출석 코드를 보내어\n해당 강의의 출석을 할 수 있게끔 한다. 하지만, K명의 졸고 있는 학생들은 출석 코드를 제출하지 않고, 다른 학생들에게 보내지 않는다.\n지환이는 무작위로 한 명의 학생에게 출석 코드를 보내는 행위를 Q번 반복한 뒤,\n출석부 정리를 위해 특정 구간의 입장 번호를 받은 학생들 중에서 출석이 되지 않은 학생들의 수를 구하고 싶다.","title":"[BOJ] 20438 출석체크 with Python"},{"content":"\n📌 BOJ 17485 진우의 달 여행 (Large) 💡 조건 지구와 우주사이는 N X M 행렬로 나타낼 수 있으며 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료의 양이다.\nN, M (2 ≤ N, M ≤ 1000), 각 행렬의 원소값은 100 이하의 자연수이다. 지구 -\u0026gt; 달로 가는 경우 우주선이 움직일 수 있는 방향은 아래와 같다. 우주선은 전에 움직인 방향으로 움직일 수 없다. 즉, 같은 방향으로 두번 연속으로 움직일 수 없다.\n진우의 목표는 연료를 최대한 아끼며 지구의 어느위치에서든 출발하여 달의 어느위치든 착륙하는 것이다.\n최대한 돈을 아끼고 살아서 달에 도착하고 싶은 진우를 위해 달에 도달하기 위해 필요한 연료의 최소값을 계산하는 문제\n다이나믹 프로그래밍, 완전탐색 유형의 문제\n🔖 예제 및 실행결과 예제 6 4 5 8 5 1 3 5 8 4 9 77 65 5 2 1 5 2 5 98 1 5 4 95 67 58 실행결과 29 ⌨️ 문제 풀이 완전 탐색과 다이나믹프로그래밍 알고리즘을 이용하여 문제를 해결한다.\n탐색한 경로를 다시 탐색하지 않는다는 아이디어를 위해서 메모이제이션을 사용한다.\n각 공간을 지날 때 최솟값을 기록하고 이전의 값을 사용하는 방식을 사용하면 된다.\n재귀 함수를 사용하여 풀이한다면 점화식을 만들어볼 수 있다.\ndp[r][c][cur_dir] = min(dp[r][c][cur_dir], recursive_find(next_r, next_c), next_dir) + board[r][c]) (3)번에서 도출한 점화식을 통해서 최솟값을 반영해 불필요한 탐색을 막을 수 있다.\nPyPy3 로 제출해야 시간초과가 걸리지 않는다.\nsetrecursionlimit 을 사용해야 런타임 에러 발생을 방지한다.\n🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(2000) def visit_tf(pos, cur_direction, next_direction): x, y = pos return cur_direction != next_direction and 0 \u0026lt;= y \u0026lt; m def solve(pos, cur_pos): x, y = pos if x == n: return 0 if dp[x][y][cur_pos] != int(1e9): return dp[x][y][cur_pos] for next_pos, dy in enumerate(direction): npx, npy = x + 1, y + dy if visit_tf((npx, npy), cur_pos, next_pos): data = solve((npx, npy), next_pos) + arr[x][y] dp[x][y][cur_pos] = min(data, dp[x][y][cur_pos]) return dp[x][y][cur_pos] if __name__ == \u0026#39;__main__\u0026#39;: n, m = map(int, stdin.readline().split()) arr = [] answer = int(1e9) dp = [[[answer] * 3 for i in range(m)] for _ in range(n)] direction = [-1, 0, 1] for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) for i in range(m): for j in range(3): answer = min(answer, solve((0, i), j)) print(answer) 💾 느낀점 스스로 풀이하지 못해 블로그 글을 참고하여 풀이했다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-17485-%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-large-with-python/","summary":"📌 BOJ 17485 진우의 달 여행 (Large) 💡 조건 지구와 우주사이는 N X M 행렬로 나타낼 수 있으며 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료의 양이다.\nN, M (2 ≤ N, M ≤ 1000), 각 행렬의 원소값은 100 이하의 자연수이다. 지구 -\u0026gt; 달로 가는 경우 우주선이 움직일 수 있는 방향은 아래와 같다. 우주선은 전에 움직인 방향으로 움직일 수 없다. 즉, 같은 방향으로 두번 연속으로 움직일 수 없다.","title":"[BOJ] 17485 진우의 달 여행 (Large) with Python"},{"content":"\n📌 BOJ 20166 문자열 지옥에 빠진 호석 💡 조건 정신을 차려보니 바닥에는 격자 모양의 타일이 가득한 세상이었고, 각 타일마다 알파벳 소문자가 하나씩 써있다더라.\n두려움에 가득해 미친듯이 앞만 보고 달려 끝을 찾아 헤맸지만 이 세상은 끝이 없었고,\n달리다 지쳐 바닥에 드러누우니 하늘에 이런 문구가 핏빛 구름으로 떠다니고 있었다.\n이 세상은 N행 M열의 격자로 생겼으며, 각 칸에 알파벳이 써있고 환형으로 이어진다. 왼쪽 위를 (1, 1), 오른쪽 아래를 (N, M)이라고 하자.\n너는 아무 곳에서나 시작해서 상하좌우나 대각선 방향의 칸으로 한 칸씩 이동할 수 있다. 이 때, 이미 지나 왔던 칸들을 다시 방문하는 것은 허용한다.\n시작하는 격자의 알파벳을 시작으로, 이동할 때마다 각 칸에 써진 알파벳을 이어 붙여서 문자열을 만들 수 있다.\n이 곳의 신인 내가 좋아하는 문자열을 K 개 알려줄 터이니, 각 문자열 마다 너가 만들 수 있는 경우의 수를 잘 대답해야 너의 세계로 돌아갈 것이다.\n경우의 수를 셀 때, 방문 순서가 다르면 다른 경우이다. 즉, (1,1)-\u0026gt;(1,2) 로 가는 것과 (1,2)-\u0026gt;(1,1) 을 가는 것은 서로 다른 경우이다.\n너가 1행에서 위로 가면 N 행으로 가게 되며 반대도 가능하다.\n너가 1열에서 왼쪽으로 가면 M 열로 가게 되며 반대도 가능하다.\n대각선 방향에 대해서도 동일한 규칙이 적용된다.\n하늘에 아래와 같은 그림을 구름으로 그려줄 터이니 이해해 돕도록 하여라.\n예를 들어서, 너가 (1, 1)에서 위로 가면 (N, 1)이고, 왼쪽으로 가면 (1, M)이며 왼쪽 위 대각선 방향으로 가면 (N, M)인 것이다.\n세상을 이루는 격자의 정보와, K 개의 문자열이 주어졌을 때, 호석이가 대답해야 하는 정답을 구하는 문제.\n16개 이상의 데이터를 맞아야 AC를 받는다.\n첫번째 줄에 격자의 크기 N, M과 신이 좋아하는 문자열의 개수 K 가 주어진다.\n다음에 N개의 줄에 걸쳐서 M개의 알파벳 소문자가 공백없이 주어진다. 여기서의 첫 번째 줄은 1행의 정보이며, N 번째 줄은 N행의 정보이다.\n이어서 K개의 줄에 걸쳐서 신이 좋아하는 문자열이 주어진다. 모두 알파벳 소문자로 이루어져 있다.\n3 ≤ N, M ≤ 10, N과 M은 자연수이다.\n1 ≤ K ≤ 1,000, K는 자연수이다.\n1 ≤ 신이 좋아하는 문자열의 길이 ≤ 5\n신이 좋아하는 문자열은 중복될 수도 있다.\nDFS, 깊이 우선 탐색 유형의 문제\n🔖 예제 및 실행결과 예제 3 4 3 abcb bcaa abac aba abc cab 실행결과 56 0 ⌨️ 문제 풀이 n개의 입력을 받아 arr 리스트에 저장한다.\nk번 반복하면서 신이 좋아하는 문자열 을 입력 받아 ans에 키 값으로 두고, 0으로 초기화 한다.\n또한 ans_list 에 신이 좋아하는 문자열을 저장한다.\nn * m 크기의 리스트를 순회하면서 각 좌표에 해당하는 문자로부터 시작해 만약 문자가 ans 에 있다면 + 1을 해준다.\n8방향으로 뻗어나가면서 재귀를 통해 solve() 힘수를 다시 타면서 cnt 파라미터가 5 이상이면 return 한다.\nn * m 크기의 리스트를 모두 순회했다면, ans_list 를 순회한다.(k)\nk 가 ans 에 있다면, ans 딕셔너리에 k 에 해당하는 키 값의 value를 출력하면 된다.\n🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n, m, k = map(int, stdin.readline().split()) ans, arr, res = {}, [], [] dx, dy = [1, 0, -1, 0, 1, 1, -1, -1], [0, 1, 0, -1, -1, 1, 1, -1] ans_list = [] for i in range(n): arr.append(list(stdin.readline().rstrip())) for _ in range(k): data = stdin.readline().rstrip() ans[data] = 0 ans_list.append(data) def solve(x, y, cnt, string): if cnt \u0026gt; 5: return if string in ans: ans[string] += 1 for i in range(8): nx, ny = (x + n + dx[i]) % n, (y + m + dy[i]) % m solve(nx, ny, cnt + 1, string + arr[nx][ny]) for i in range(n): for j in range(m): start = \u0026#39;\u0026#39; solve(i, j, 1, start + arr[i][j]) for k in ans_list: if k in ans: print(ans[k]) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20166-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A7%80%EC%98%A5%EC%97%90-%EB%B9%A0%EC%A7%84-%ED%98%B8%EC%84%9D-with-python/","summary":"📌 BOJ 20166 문자열 지옥에 빠진 호석 💡 조건 정신을 차려보니 바닥에는 격자 모양의 타일이 가득한 세상이었고, 각 타일마다 알파벳 소문자가 하나씩 써있다더라.\n두려움에 가득해 미친듯이 앞만 보고 달려 끝을 찾아 헤맸지만 이 세상은 끝이 없었고,\n달리다 지쳐 바닥에 드러누우니 하늘에 이런 문구가 핏빛 구름으로 떠다니고 있었다.\n이 세상은 N행 M열의 격자로 생겼으며, 각 칸에 알파벳이 써있고 환형으로 이어진다. 왼쪽 위를 (1, 1), 오른쪽 아래를 (N, M)이라고 하자.\n너는 아무 곳에서나 시작해서 상하좌우나 대각선 방향의 칸으로 한 칸씩 이동할 수 있다.","title":"[BOJ] 20166 문자열 지옥에 빠진 호석 with Python"},{"content":"\n📌 BOJ 13459 구슬 탈출 💡 조건 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다.\n보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다.\nN, M (3 ≤ N, M ≤ 10)\n가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다.\n빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다.\n게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다.\n왼쪽으로 기울이기, 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다.\n각각의 동작에서 공은 동시에 움직인다. 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다.\n빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다. 빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다.\n빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다. 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다.\n보드의 상태가 주어졌을 때, 10번 이하로 빨간 구슬을 구멍을 통해 빼낼 수 있는지 구하는 문제.\n파란 구슬을 구멍에 넣지 않으면서 빨간 구슬을 10번 이하로 움직여서 빼낼 수 있으면 1을 없으면 0을 출력한다.\n문자열은 \u0026lsquo;.\u0026rsquo;, \u0026lsquo;#\u0026rsquo;, \u0026lsquo;O\u0026rsquo;, \u0026lsquo;R\u0026rsquo;, \u0026lsquo;B\u0026rsquo; 로 이루어져 있다.\n\u0026lsquo;.\u0026lsquo;은 빈 칸을 의미하고, \u0026lsquo;#\u0026lsquo;은 공이 이동할 수 없는 장애물 또는 벽을 의미하며, \u0026lsquo;O\u0026rsquo;는 구멍의 위치를 의미한다.\n\u0026lsquo;R\u0026rsquo;은 빨간 구슬의 위치, \u0026lsquo;B\u0026rsquo;는 파란 구슬의 위치이다.\n입력되는 모든 보드의 가장자리에는 모두 \u0026lsquo;#\u0026lsquo;이 있다. 구멍의 개수는 한 개 이며, 빨간 구슬과 파란 구슬은 항상 1개가 주어진다.\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 10 10 ########## #R#...##B# #...#.##.# #####.##.# #......#.# #.######.# #.#....#.# #.#.##...# #O..#....# ########## 실행결과 1 ⌨️ 문제 풀이 구슬을 네 개의 방향으로 기울였을 떄의 상태를 큐에 넣고 관리한다.\n이미 방문했던 곳에는 방문하지 않도록 visit 리스트에 방문처리를 해주어야 한다.\n큐에서 꺼내고, 이동을 시킬 좌표를 move 함수로 계산해 파란구슬이 \u0026lsquo;0\u0026rsquo;이 아니고 빨간 구슬이 \u0026lsquo;0\u0026rsquo;으로 갈 경우 1을 출력한다.\n만약 움직였을 때 두 구슬이 이동할 좌표가 \u0026lsquo;0\u0026rsquo; 이거나 10회를 초과하여 기울였다면 0을 출력한다.\n🖥 소스 코드 from collections import deque n, m = map(int, input().split()) dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] visit = [[[[False] * m for i in range(n)] for i in range(m)] for i in range(n)] s = [] def move(i, j, dx, dy): c = 0 while s[i + dx][j + dy] != \u0026#34;#\u0026#34; and s[i][j] != \u0026#34;O\u0026#34;: i += dx j += dy c += 1 return i, j, c def bfs(): while q: ri, rj, bi, bj, d = q.popleft() if d \u0026gt; 10: break for i in range(4): nri, nrj, rc = move(ri, rj, dx[i], dy[i]) nbi, nbj, bc = move(bi, bj, dx[i], dy[i]) if s[nbi][nbj] != \u0026#34;O\u0026#34;: if s[nri][nrj] == \u0026#34;O\u0026#34;: print(1) return if nri == nbi and nrj == nbj: if rc \u0026gt; bc: nri -= dx[i] nrj -= dy[i] else: nbi -= dx[i] nbj -= dy[i] if not visit[nri][nrj][nbi][nbj]: visit[nri][nrj][nbi][nbj] = True q.append([nri, nrj, nbi, nbj, d + 1]) print(0) for i in range(n): a = list(input()) s.append(a) for j in range(m): if a[j] == \u0026#34;R\u0026#34;: ri, rj = i, j if a[j] == \u0026#34;B\u0026#34;: bi, bj = i, j q = deque() q.append([ri, rj, bi, bj, 1]) visit[ri][rj][bi][bj] = True bfs() 💾 느낀점 구슬을 움직여 상태를 나타내고, 방문처리를 할 리스트를 만들어 관리하는 것이 아이디어는 쉬웠다.\n구현이 어려웠다.\n","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-13459-%EA%B5%AC%EC%8A%AC-%ED%83%88%EC%B6%9C-with-python/","summary":"📌 BOJ 13459 구슬 탈출 💡 조건 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다.\n보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다.\nN, M (3 ≤ N, M ≤ 10)\n가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다.\n빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다.","title":"[BOJ] 13459 구슬 탈출 with Python"},{"content":"\n📌 BOJ 6010 Music Notes 💡 조건 노래는 음표 N개로 구성되며, i 번째 음표는 B_i 비트동안 지속된다.\nN(1 \u0026lt;= N \u0026lt;= 50,000), B_i(1 \u0026lt;= B_i \u0026lt;= 10,000)\n어떤 노래도 5억 비트 보다 길지 않다.\n0에서 노래를 연주하기 시작하며, 0에서부터 B_1 전까지 음표 1개, 시간 B_1에서 B_1 + B_2 직전까지 음표 2개를 연주한다.\nT 시간부터 T+1 직전까지의 간격에서 어떤 음표를 연주해야하는지 구하는 문제.\n질문의 개수는 Q개가 있다.\nQ(1 \u0026lt;= Q \u0026lt;= 50,000)\n질문은 T_i(0 \u0026lt;= T_i \u0026lt;= end_of_song)으로 제공된다.\n이분탐색 알고리즘 유형의 문제\n🔖 예제 및 실행결과 예제 3 5 2 1 3 2 3 4 0 1 실행결과 2 3 3 1 1 ⌨️ 문제 풀이 노트를 저장할 때, 해당 노트의 범위 X가 (a \u0026lt;= X \u0026lt; b)에 해당한다면, 최댓값 (b-1)만 저장한다.\nT_i 부분에서 이분탐색을 사용한다.\n이분 탐색을 사용하여 나온 end 값에서 +1 을 해주고 출력하면 된다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) nums = [] now = 0 def solve(start, end, target): while end \u0026gt; start: mid = (start + end) // 2 if nums[mid] \u0026lt; target: start = mid + 1 else: end = mid return end for _ in range(n): count = int(stdin.readline()) nums.append(now + count - 1) now += count nums.append(int(1e12)) for _ in range(m): j = int(stdin.readline()) it = solve(0, len(nums), j) print(it + 1) 💾 느낀점 이분탐색을 통해서 해야겠다는 생각을 못한 것 같다.\n영어로 된 문제의 지문을 해석해 문제를 풀이하는데 있어서 어려움을 겪었다.\n","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-6010-music-notes-with-python/","summary":"📌 BOJ 6010 Music Notes 💡 조건 노래는 음표 N개로 구성되며, i 번째 음표는 B_i 비트동안 지속된다.\nN(1 \u0026lt;= N \u0026lt;= 50,000), B_i(1 \u0026lt;= B_i \u0026lt;= 10,000)\n어떤 노래도 5억 비트 보다 길지 않다.\n0에서 노래를 연주하기 시작하며, 0에서부터 B_1 전까지 음표 1개, 시간 B_1에서 B_1 + B_2 직전까지 음표 2개를 연주한다.\nT 시간부터 T+1 직전까지의 간격에서 어떤 음표를 연주해야하는지 구하는 문제.\n질문의 개수는 Q개가 있다.\nQ(1 \u0026lt;= Q \u0026lt;= 50,000)","title":"[BOJ] 6010 Music Notes with Python"},{"content":"\n📌 BOJ 2637 장난감 조립 💡 조건 우리는 어떤 장난감을 여러 가지 부품으로 조립하여 만들려고 한다.\n이 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다.\n기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.\n어떤 장난감 완제품과 그에 필요한 부품들 사이의 관계가 주어져 있을 때 하나의 장난감 완제품을 조립하기 위해\n필요한 기본 부품의 종류별 개수를 계산하는 문제.\n자연수 N(3 ≤ N ≤ 100), 1부터 N-1까지는 기본 부품이나 중간 부품의 번호를 나타내고, N은 완제품의 번호를 나타낸다.\n자연수 M(3 ≤ M ≤ 100)이 주어지고, 그 다음 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다.\n\u0026ldquo;중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다\u0026quot;는 뜻\n하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음)\n반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 각 줄에는 기본 부품의 번호와 소요 개수를 출력한다.\n정답은 2,147,483,647 이하이다.\n위상 정렬 알고리즘 유형의 문제\n🔖 예제 및 실행결과 예제 7 8 5 1 2 5 2 2 7 5 2 6 5 2 6 3 3 6 4 4 7 6 3 7 4 5 실행결과 1 16 2 16 3 9 4 17 ⌨️ 문제 풀이 문제에서 가장 중요한 문장을 먼저 살펴보겠다.\n장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다.\n기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다.\n중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.\n요약하자면, 중간 부품과 기본 부품을 필요 개수 이상 만들어두어야 완제품을 만들 수 있으며,\n중간 부품은 기본 부품을 조립하여 만들 수 있다. 이는 반드시 기본 부품을 으로 중간 제품을 먼저 만들어야 완제품을\n만들 수 있다는 것 이다.\n위상 정렬은 순서가 있는 작업을 차례대로 수행해야할 때 그 순서를 결정해주기 위해 사용하는 알고리즘이다.\n각 중간 부품이 만들어지기 위해서는 몇 개의 기본 부품이 반드시 있어야하기 때문에 위상정렬을 통해 문제를 해결할 수 있다는 생각을 할 수 있다.\n필요한 개수를 needs 리스트에 저장하고, needs[n] 에서 각 부품의 개수를 번호 순서대로 출력할 것이다.\nconnect 리스트에는 X 를 만들기 위한 Y번 부품 K 개에 대해 저장한다.\n🖥 소스 코드 import sys from collections import deque input = sys.stdin.readline n = int(input()) connect = [[] for _ in range(n + 1)] needs = [[0] * (n + 1) for _ in range(n + 1)] q = deque() degree = [0] * (n + 1) for _ in range(int(input())): a, b, c = map(int, input().split()) connect[b].append((a, c)) degree[a] += 1 for i in range(1, n + 1): if degree[i] == 0: q.append(i) while q: now = q.popleft() for next, next_need in connect[now]: if needs[now].count(0) == n + 1: needs[next][now] += next_need else: for i in range(1, n + 1): needs[next][i] += needs[now][i] * next_need degree[next] -= 1 if degree[next] == 0: q.append(next) for x in enumerate(needs[n]): if x[1] \u0026gt; 0: print(*x) 💾 느낀점 위상 정렬의 개념 정리를 통해 문제의 컨셉을 이해함.\n순서가 있는 작업을 차례대로 수행하거나, 반드시 전제 조건이 만족되어야할 때를 잘 파악하여 생각하고\n그 로직을 구현하는 연습을 할 수 있었던 문제였다. 하지만 난이도는 상당한 것 같다.\n자꾸 까먹는 위상 정렬같은 문제는 코딩테스트 후반 번호로 등장할 가능성이 있을 것 같다.\n","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2637-%EC%9E%A5%EB%82%9C%EA%B0%90-%EC%A1%B0%EB%A6%BD-with-python/","summary":"📌 BOJ 2637 장난감 조립 💡 조건 우리는 어떤 장난감을 여러 가지 부품으로 조립하여 만들려고 한다.\n이 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다.\n기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.\n어떤 장난감 완제품과 그에 필요한 부품들 사이의 관계가 주어져 있을 때 하나의 장난감 완제품을 조립하기 위해\n필요한 기본 부품의 종류별 개수를 계산하는 문제.","title":"[BOJ] 2637 장난감 조립 with Python"},{"content":"\n📌 BOJ 3151 합이 0 💡 조건 1 ≤ N ≤ 10000\n-10000 ≤ Ai ≤ 10000\n대회는 정확히 3명으로 구성된 팀만 참가가 가능하다.\n코딩 실력이 좋으면 팀워크가 떨어지고, 팀워크가 좋을수록 코딩 실력이 떨어진다. 그리고 출전하고자 하는 대회는 코딩 실력과 팀워크 모두가 중요하다.\n세 팀원의 코딩 실력의 합이 0이 되는 팀을 만들고자 한다.\n대회에 출전할 수 있는 팀을 얼마나 많이 만들 수 있는지를 계산하여라.\nN명의 학생들의 코딩 실력 Ai가 -10000부터 10000사이의 정수로 주어질 때, 합이 0이 되는 3인조를 만들 수 있는 경우의 수를 구하는 문제.\n이분 탐색, 투 포인터 유형의 문제\n🔖 예제 및 실행결과 예제 10 2 -5 2 3 -4 7 -4 0 1 -6 실행결과 6 힌트 예시에서 가능한 참가자 그룹은 아래와 같다.\n(2, -5, 3), (2, 2, -4), (2, 2, -4), (-5, 2, 3), (3, -4, 1), (3, -4, 1) 두 개의 -4는 서로 다른 참가자를 나타내는 것에 유의하라. (2, 2, -4)와 (3, -4, 1)이 두 번씩 나타난다.\n⌨️ 문제 풀이 이분 탐색은 순서를 보장해야하는 리스트에서는 사용하지 못한다는 것을 인지하고 있어야 한다.\n이분 탐색할 리스트를 정렬해준다.\n3151번 문제는 순서와 상관없이 3명의 인원을 뽑아 코딩 실력의 합이 0이 되는 조합을 찾아야 한다.\n입력을 받은 리스트의 길이의 -2 만큼 순회한다.\n순회하는 숫자를 X 라고 할 때, X에서 두 숫자를 빼 0이 되는 경우를 투포인터 + 이분탐색을 통해 찾는다.\n🖥 소스 코드 from sys import stdin # 이분탐색 n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() ans = 0 def solve(s, e, g): global ans max_idx = n while s \u0026lt; e: tmp = arr[s] + arr[e] if tmp \u0026lt; goal: s += 1 elif tmp == g: if arr[s] == arr[e]: ans += e - s else: if max_idx \u0026gt; e: max_idx = e while max_idx \u0026gt;= 0 and arr[max_idx - 1] == arr[e]: max_idx -= 1 ans += e - max_idx + 1 s += 1 else: e -= 1 for i in range(n - 2): start = i + 1 end = n - 1 goal = -arr[i] solve(start, end, goal) print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-3151-%ED%95%A9%EC%9D%B4-0-with-python/","summary":"📌 BOJ 3151 합이 0 💡 조건 1 ≤ N ≤ 10000\n-10000 ≤ Ai ≤ 10000\n대회는 정확히 3명으로 구성된 팀만 참가가 가능하다.\n코딩 실력이 좋으면 팀워크가 떨어지고, 팀워크가 좋을수록 코딩 실력이 떨어진다. 그리고 출전하고자 하는 대회는 코딩 실력과 팀워크 모두가 중요하다.\n세 팀원의 코딩 실력의 합이 0이 되는 팀을 만들고자 한다.\n대회에 출전할 수 있는 팀을 얼마나 많이 만들 수 있는지를 계산하여라.\nN명의 학생들의 코딩 실력 Ai가 -10000부터 10000사이의 정수로 주어질 때, 합이 0이 되는 3인조를 만들 수 있는 경우의 수를 구하는 문제.","title":"[BOJ] 3151 합이 0 with Python"},{"content":"\n📌 BOJ 18291 비요뜨의 징검다리 건너기 💡 조건 징검다리는 비요뜨가 있는 방향에서부터 반대 방향까지 차례로 1번, 2번, \u0026hellip;, N번의 번호를 가지고 있다.\n비요뜨는 1번 징검다리 위에 올라갔다. 그리고 아래 두 가지 규칙을 지키며 징검다리를 건너려고 한다.\n1 ≤ X ≤ N 인 임의의 정수 X에 대해, 현재 있는 징검다리의 번호를 i번이라고 할 때 i+X번 징검다리로 뛸 수 있다. N번째 징검다리를 지나쳐선 안 되고, 정확히 도착해야 한다 첫 번째 줄에 테스트 케이스의 수 T가 주어진다. (1 ≤ T ≤ 1000)\n각 테스트 케이스는 한 줄로 구성되며, 징검다리의 개수를 의미하는 N이 주어진다. (1 ≤ N ≤ 109)\n각 테스트 케이스에 대해, 한 줄에 하나씩 규칙을 만족하면서 징검다리를 건너는 경우의 수를 109+7로 나눈 나머지를 출력한다.\n수학 유형의 문제\n🔖 예제 및 실행결과 예제 1 4 실행결과 4 ⌨️ 문제 풀이 분할정복을 통한 거듭제곱 문제이다. 재귀를 사용하지 않고 문제를 해결했다.\npow 를 사용할 경우 시간초과가 뜬다.\n🖥 소스 코드 from sys import stdin def solve(x): mod = 1000000007 a = 2 b = x ret = 1 while b: if b % 2 == 1: ret *= a ret %= mod a *= a a %= mod b //= 2 return ret for _ in range(int(stdin.readline())): test_data = int(stdin.readline()) if 0 \u0026lt; test_data \u0026lt; 2: print(1) else: x = test_data - 2 print(solve(x)) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-18291-%EB%B9%84%EC%9A%94%EB%9C%A8%EC%9D%98-%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC-%EA%B1%B4%EB%84%88%EA%B8%B0-with-python/","summary":"📌 BOJ 18291 비요뜨의 징검다리 건너기 💡 조건 징검다리는 비요뜨가 있는 방향에서부터 반대 방향까지 차례로 1번, 2번, \u0026hellip;, N번의 번호를 가지고 있다.\n비요뜨는 1번 징검다리 위에 올라갔다. 그리고 아래 두 가지 규칙을 지키며 징검다리를 건너려고 한다.\n1 ≤ X ≤ N 인 임의의 정수 X에 대해, 현재 있는 징검다리의 번호를 i번이라고 할 때 i+X번 징검다리로 뛸 수 있다. N번째 징검다리를 지나쳐선 안 되고, 정확히 도착해야 한다 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.","title":"[BOJ] 18291 비요뜨의 징검다리 건너기 with Python"},{"content":"\n📌 BOJ 2342 Dance Dance Revolution 💡 조건 편의상 중점을 0, 위를 1, 왼쪽을 2, 아래를 3, 오른쪽을 4라고 정하자. 처음에 게이머는 두 발을 중앙에 모으고 있다.(그림에서 0의 위치)\n그리고 게임이 시작하면, 지시에 따라 왼쪽 또는 오른쪽 발을 움직인다. 하지만 그의 두 발이 동시에 움직이지는 않는다.\n두 발이 같은 지점에 있는 것이 허락되지 않는다.\n한 발이 1의 위치에 있고, 다른 한 발이 3의 위치에 있을 때, 3을 연속으로 눌러야 한다면, 3의 위치에 있는 발로 반복해야 눌러야 한다.\n발을 이동할 때 힘을 사용하게 된다.\n중앙에 있던 발이 다른 지점으로 움직일 때, 2의 힘을 사용하게 된다. 다른 지점에서 인접한 지점으로 움직일 때는 3의 힘을 사용하게 된다. 반대편으로 움직일때는 4의 힘을 사용하게 된다. 같은 지점을 한번 더 누른다면, 그때는 1의 힘을 사용하게 된다. 입력은 지시 사항으로 이루어진다. 각각의 지시 사항은 하나의 수열로 이루어진다.\n각각의 수열은 1, 2, 3, 4의 숫자들로 이루어지고, 이 숫자들은 각각의 방향을 나타낸다.\n입력 파일의 마지막에는 0이 입력된다. 입력되는 수열의 길이는 100,000을 넘지 않는다.\n다이나믹프로그래밍 유형의 문제\n🔖 예제 및 실행결과 예제 1 2 2 4 0 실행결과 8 ⌨️ 문제 풀이 문제를 간단하게 말하자면, 최소한의 힘을 사용해 입력받은 수열의 번호를 다 눌러야한다.\n다시 말해, 왼쪽 발과 오른쪽 발이 어느 위치에 있을 때, 어떤 발판부터 밟아야 최소의 힘을 들일 수 있는가? 이다.\n그렇다면 이 문제는 solve(n, l, r) 이라고 간단하게 함수처럼 만들어 볼 수가 있다.\n발의 위치가 (l,r) 일 때 n번째 팔판부터 밟았을 때 소모되는 힘이라고 정의할 수 있다.\n발은 동시에 움직일 수 없으니, 발이 움직이는 건 2가지가 있다.\nsolve(n, l, r) 은 왼쪽 발을 움직여 발판을 밟은 상태와 오른쪽 발을 움직여 발판을 밟은 상태의 최솟값이 될 수 있다.\n그렇다면 아래와 같이 정의할 수 있다.\nmin(solve(n + 1, arr[n], r) + move(l, arr[n]), solve(n + 1, l, arr[n]) + move(r, arr[n])) 🖥 소스 코드 import sys sys.setrecursionlimit(10 ** 6) def move(a, b): if a == b: return 1 elif a == 0: return 2 elif abs(b - a) % 2 == 0: return 4 else: return 3 def solve(n, l, r): global dp if n \u0026gt;= len(arr) - 1: return 0 if dp[n][l][r] != -1: return dp[n][l][r] dp[n][l][r] = min(solve(n + 1, arr[n], r) + move(l, arr[n]), solve(n + 1, l, arr[n]) + move(r, arr[n])) return dp[n][l][r] arr = list(map(int, sys.stdin.readline().split())) dp = [[[-1] * 5 for _ in range(5)] for _ in range(100000)] print(solve(0, 0, 0)) 💾 느낀점 메모이제이션과 재귀함수를 통해 결과값을 도출하는 방법 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2342-dance-dance-revolution-with-python/","summary":"📌 BOJ 2342 Dance Dance Revolution 💡 조건 편의상 중점을 0, 위를 1, 왼쪽을 2, 아래를 3, 오른쪽을 4라고 정하자. 처음에 게이머는 두 발을 중앙에 모으고 있다.(그림에서 0의 위치)\n그리고 게임이 시작하면, 지시에 따라 왼쪽 또는 오른쪽 발을 움직인다. 하지만 그의 두 발이 동시에 움직이지는 않는다.\n두 발이 같은 지점에 있는 것이 허락되지 않는다.\n한 발이 1의 위치에 있고, 다른 한 발이 3의 위치에 있을 때, 3을 연속으로 눌러야 한다면, 3의 위치에 있는 발로 반복해야 눌러야 한다.","title":"[BOJ] 2342 Dance Dance Revolution with Python"},{"content":"\n📌 BOJ 17204 죽음의 게임 💡 조건 게임에 참여하는 N명의 사람들은 원탁에 둘러앉게 된다.\nN(3 ≤ N ≤ 150)\n게임을 시작하는 사람은 0번, 그 오른쪽 사람은 1번, 그 오른쪽은 2번, N-1번의 오른쪽 사람은 다시 0번이 된다.\n게임 참여자들간에 지목을 완료한 상태가 주어질때, 보성이가 벌주를 마시기 위해 록 하자.\n영기가 불러야 하는 가장 작은 양의 정수 M을 보성이 몰래 귀띔해 주도록 하자.\n보성이의 번호 K(1 ≤ K ≤ N - 1)\n김영기는 게임을 제안하였기에 자연스럽게 0번이 된다.\nN줄에 걸쳐 i(0 ≤ i ≤ N - 1)번 사람이 지목하는 사람의 번호 ai(0 ≤ ai ≤ N - 1)가 주어진다.\n자기 자신을 지목하는 경우도 존재할 수 있다.\n영기가 말해야 하는 가장 작은 양의 정수 M을 출력한다. 만약 어떤 방법으로도 보성이가 걸리지 않는다면 -1을 출력한다.\nBFS, 그래프탐색 유형의 문제\n🔖 예제 및 실행결과 예제 5 3 1 3 2 1 4 실행결과 2 ⌨️ 문제 풀이 N줄에 걸쳐 i번 사람이 지목하는 사람의 번호를 입력받아 그래프를 만들어준다.\nBFS 알고리즘을 통해 순회할 것인데 게임을 제한하고 시작한 사람은 0번이기 때문에 0번부터 시작을 해서 K번이 지목되는 숫자를 세어 주면 된다.\nQueue 에는 몇번째로 지목되었는지, 지목된 사람이 누구인지에 대한 데이터를 넣어준다.\nBFS를 위해 만들어 둔 Queue에서 원소를 뽑았을 때, K번이라면 number를 리턴해준다.\n만약 BFS 로 그래프를 순회하면서 K를 지목할 수 없다면 -1을 return 해준다.\n🖥 소스 코드 from collections import deque from sys import stdin n, m = map(int, stdin.readline().split()) arr = [[] for _ in range(n + 1)] for i in range(n): arr[i].append(int(stdin.readline())) def solve(x): q = deque() q.append((0, x)) visited = set() while q: number, x = q.popleft() if number \u0026gt; n and m not in visited: return -1 if x == m: return number if arr[x][0]: q.append((number + 1, arr[x][0])) return -1 print(solve(0)) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-17204-%EC%A3%BD%EC%9D%8C%EC%9D%98-%EA%B2%8C%EC%9E%84-with-python/","summary":"📌 BOJ 17204 죽음의 게임 💡 조건 게임에 참여하는 N명의 사람들은 원탁에 둘러앉게 된다.\nN(3 ≤ N ≤ 150)\n게임을 시작하는 사람은 0번, 그 오른쪽 사람은 1번, 그 오른쪽은 2번, N-1번의 오른쪽 사람은 다시 0번이 된다.\n게임 참여자들간에 지목을 완료한 상태가 주어질때, 보성이가 벌주를 마시기 위해 록 하자.\n영기가 불러야 하는 가장 작은 양의 정수 M을 보성이 몰래 귀띔해 주도록 하자.\n보성이의 번호 K(1 ≤ K ≤ N - 1)","title":"[BOJ] 17204 죽음의 게임 with Python"},{"content":"\n📌 BOJ 20444 색종이와 가위 💡 조건 색종이를 자를 때는 다음과 같은 규칙을 따른다.\n색종이는 직사각형이며, 색종이를 자를 때는 한 변에 평행하게 자른다. 자르기 시작했으면, 경로 상의 모든 색종이를 자를 때까지 멈추지 않는다. 이미 자른 곳을 또 자를 수 없다. 하나의 색종이를 정확히 n번의 가위질로 k개의 색종이 조각으로 만들 수 있는지 궁금해졌다.\n정수 n, k가 주어진다. (1 ≤ n ≤ 231-1, 1 ≤ k ≤ 263-1)\nn번의 가위질로 k개의 색종이 조각을 만들 수 있다면 YES, 아니라면 NO를 출력한다.\n이분 탐색 유형의 문제\n🔖 예제 및 실행결과 예제 4 9 실행결과 YES ⌨️ 문제 풀이 종이를 가로로 a번, 세로로 b번 자른다고 하면, (a + 1) * (b + 1) 개로 잘린다. 이 문제에서는 총 n번 자르길 원하고, 가로와 세로를 각각 몇 번 자르는지에 따라 개수는 달라진다. n = a + b 이다.\nb = n - a 라고 할 수 있다. (a + 1) * (b + 1) 식에 b를 대입하면, (a + 1) * (n - a + 1) 개로 바뀐다. n은 범위가 (2 ** 31 - 1) 까지이기에 하나하나 찾아볼 순 없고, 이분탐색을 사용해야한다. 또한 0 에서 n // 2 까지만 탐색을 해주면 된다. 🖥 소스 코드 import sys input = sys.stdin.readline n, k = map(int, input().split()) def f(x): return (x + 1) * (n - x + 1) lo, hi = 0, n // 2 + 1 while lo != hi: mid = (lo + hi) // 2 data = f(mid) if data == k: print(\u0026#34;YES\u0026#34;) sys.exit(0) if data \u0026gt; k: hi = mid else: lo = mid + 1 print(\u0026#34;NO\u0026#34;) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20444-%EC%83%89%EC%A2%85%EC%9D%B4%EC%99%80-%EA%B0%80%EC%9C%84-with-python/","summary":"📌 BOJ 20444 색종이와 가위 💡 조건 색종이를 자를 때는 다음과 같은 규칙을 따른다.\n색종이는 직사각형이며, 색종이를 자를 때는 한 변에 평행하게 자른다. 자르기 시작했으면, 경로 상의 모든 색종이를 자를 때까지 멈추지 않는다. 이미 자른 곳을 또 자를 수 없다. 하나의 색종이를 정확히 n번의 가위질로 k개의 색종이 조각으로 만들 수 있는지 궁금해졌다.\n정수 n, k가 주어진다. (1 ≤ n ≤ 231-1, 1 ≤ k ≤ 263-1)\nn번의 가위질로 k개의 색종이 조각을 만들 수 있다면 YES, 아니라면 NO를 출력한다.","title":"[BOJ] 20444 색종이와 가위 with Python"},{"content":"\n📌 BOJ 22252 정보 상인 호석 💡 조건 관찰하면서 얻은 정보는 총 $Q$ 개이다. 각 정보는 다음의 2가지 중 하나이다.\n1 Name k C_1, C_2, \u0026hellip;, C_k : 이름이 [Name]인 고릴라가 k 개의 정보를 얻었으며, 각 가치는 C_1 부터 C_k 이다. 2 Name b : 호석이가 이름이 [Name]인 고릴라에게 b 개의 정보를 구매한다.\n이때 고릴라가 가진 정보들 중 가장 비싼 b 개를 구매하며, 고릴라가 가진 정보가 b개 이하이면 가진 모든 정보를 구매한다. 고릴라들이 정보를 얻는 사건과 호석이가 거래하는 정보가 시간순으로 주어진다. 첫 번째 줄에는 쿼리의 개수 Q가 주어진다.\nQ 개의 줄에 걸쳐서 각 줄에 쿼리가 주어진다.\n쿼리는 1이나 2로 시작한다.\n1로 시작하는 경우에는 정보를 얻은 정보 고릴라의 이름과 k가 주어지며 이어서\nk개의 정보 가치 C_1, \u0026hellip;, C_k가 자연수로 주어진다.\n모든 C_i는 1 이상 100,000 이하이다.\n2로 시작하는 경우에는 호석이가 거래하려는 정보 고릴라의 이름과 구매하려는 정보의 개수 b가 주어진다.\n제한사항은 아래와 같다.\n1 ≤ Q ≤ 100,000, Q 는 자연수 모든 Name은 알파벳 소문자 혹은 대문자로 이루어져 있고 공백이 없으며 길이는 1 이상 15 이하이다. 1 ≤ k ≤ 100,000, k 는 자연수 1 ≤ C ≤ 100,000, C 는 자연수 1 ≤ b ≤ 100,000, b 는 자연수 모든 쿼리에 대한 k 의 합은 1,000,000 을 넘지 않는다. 자료구조, 우선순위큐, heapq 유형의 문제\n🔖 예제 및 실행결과 예제 7 1 Cpp 5 10 4 2 8 4 1 Java 2 8 2 2 Cpp 2 1 Cpp 2 10 3 2 Cpp 3 2 Java 1 2 Python 10 실행결과 44 ⌨️ 문제 풀이 우선순위 큐의 성질을 이용해 각 정보의 가치를 우선순위로 정해 데이터를 관리하며 구현하는 문제이다. dictionary 로 정보의 이름을 관리하면 편하게 구현할 수 있다. 🖥 소스 코드 from sys import stdin import heapq dictionary, res = {}, 0 for _ in range(int(stdin.readline())): data = list(stdin.readline().split()) info = data[:3] if info[0] == \u0026#39;1\u0026#39;: try: for i in range(int(info[2])): heapq.heappush(dictionary[info[1]], (-int(data[3 + i]), int(data[3 + i]))) except: dictionary[info[1]] = [] for i in range(int(info[2])): heapq.heappush(dictionary[info[1]], (-int(data[3 + i]), int(data[3 + i]))) else: try: for i in range(int(info[2])): res += heapq.heappop(dictionary[info[1]])[1] except: pass print(res) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-22252-%EC%A0%95%EB%B3%B4-%EC%83%81%EC%9D%B8-%ED%98%B8%EC%84%9D-with-python/","summary":"📌 BOJ 22252 정보 상인 호석 💡 조건 관찰하면서 얻은 정보는 총 $Q$ 개이다. 각 정보는 다음의 2가지 중 하나이다.\n1 Name k C_1, C_2, \u0026hellip;, C_k : 이름이 [Name]인 고릴라가 k 개의 정보를 얻었으며, 각 가치는 C_1 부터 C_k 이다. 2 Name b : 호석이가 이름이 [Name]인 고릴라에게 b 개의 정보를 구매한다.\n이때 고릴라가 가진 정보들 중 가장 비싼 b 개를 구매하며, 고릴라가 가진 정보가 b개 이하이면 가진 모든 정보를 구매한다.","title":"[BOJ] 22252 정보 상인 호석 with Python"},{"content":"\n📌 BOJ 20436 ZOAC 3 💡 조건 독수리 타법이란 양 손의 검지손가락만을 이용해 타자를 치는 타법이다.\n성우는 한글 자음 쪽 자판은 왼손 검지손가락으로 입력하고, 한글 모음 쪽 자판은 오른손 검지손가락으로 입력한다. a의 좌표가 (x1, y1)이고, b의 좌표가 (x2, y2)일 때,\na에 위치한 성우의 손가락이 b로 이동하는 데에는 a와 b의 택시 거리 |x1-x2|+|y1-y2| 만큼의 시간이 걸린다. 각 키를 누르는 데에는 1의 시간이 걸린다. 성우는 두 손을 동시에 움직일 수 없다.\n성우가 사용하는 키보드는 쿼티식 키보드이며, 아래 그림처럼 생겼다. 첫 번째 줄에는 두 알파벳 소문자 sL, sR이 주어진다. sL, sR은 각각 왼손 검지손가락, 오른손 검지손가락의 처음 위치이다.\n그 다음 줄에는 알파벳 소문자로 구성된 문자열이 주어진다. 문자열의 길이는 최대 100자이다. 빈 문자열은 주어지지 않는다.\n입력으로 주어진 문자열을 출력하는 데에 걸리는 시간의 최솟값을 출력한다. 구현, 시뮬레이션 유형의 문제 성우가 두 손을 동시에 움직이지 못하는 이유는 다음과 같다. 사람은 두 가지 이상의 일을 동시에 할 수 없다. 대학원생은 사람이다. 성우는 대학원생이다. 🔖 예제 및 실행결과 예제 z o zoac 실행결과 8 ⌨️ 문제 풀이 문제에 한글 자음 쪽 자판은 왼손 검지손가락으로 입력하고, 한글 모음 쪽 자판은 오른손 검지손가락으로 입력한다.\n라는 문구가 있다. 이는 자음과 모음을 따로 구분하여 구현을 하는 것이 좋을 것이라는 힌트를 얻을 수 있다. 키보드가 생긴 모양을 따라 keyboard 리스트를 생성하고, 모음을 따로 분리하여 모음 리스트를 생성한다면, 아래와 같이 만들 수 있다. keyboard = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'] mo = 'yuiophjklbnm' 첫번째 줄에 주어진 손이 위치한 알파벳을 입력받아, 손 위치의 좌표를 저장한다. 각 문자마다 누르는 시간은 1만큼 소요되기 때문에, 입력하려고 하는 문자열을 순회하면서 ans + 1을 해준다. 입력하려는 문자 s 가 모음 리스트에 있을 때, 오른손에 해당하는 좌표로부터 누르려는 키까지의 거리를 계산하여 ans에 더해준다. 입력하려는 문자 s 가 모음 리스트에 없을 때, 왼손에 해당하는 좌표로부터 누르려는 키까지의 거리를 계산하여 ans에 더해준다. 🖥 소스 코드 from sys import stdin l, r = map(str, stdin.readline().rstrip().split()) string = stdin.readline().rstrip() keyboard = [\u0026#39;qwertyuiop\u0026#39;, \u0026#39;asdfghjkl\u0026#39;, \u0026#39;zxcvbnm\u0026#39;] mo = \u0026#39;yuiophjklbnm\u0026#39; xl, yl, xr, yr = None, None, None, None for i in range(len(keyboard)): if l in keyboard[i]: xl, yl = i, keyboard[i].index(l) if r in keyboard[i]: xr, yr = i, keyboard[i].index(r) ans = 0 for s in string: ans += 1 if s in mo: for i in range(len(keyboard)): if s in keyboard[i]: nx = i ny = keyboard[i].index(s) ans += abs(xr - nx) + abs(yr - ny) xr, yr = nx, ny break else: for i in range(len(keyboard)): if s in keyboard[i]: nx = i ny = keyboard[i].index(s) ans += abs(xl - nx) + abs(yl - ny) xl, yl = nx, ny break print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20436-zoac-3-with-python/","summary":"📌 BOJ 20436 ZOAC 3 💡 조건 독수리 타법이란 양 손의 검지손가락만을 이용해 타자를 치는 타법이다.\n성우는 한글 자음 쪽 자판은 왼손 검지손가락으로 입력하고, 한글 모음 쪽 자판은 오른손 검지손가락으로 입력한다. a의 좌표가 (x1, y1)이고, b의 좌표가 (x2, y2)일 때,\na에 위치한 성우의 손가락이 b로 이동하는 데에는 a와 b의 택시 거리 |x1-x2|+|y1-y2| 만큼의 시간이 걸린다. 각 키를 누르는 데에는 1의 시간이 걸린다. 성우는 두 손을 동시에 움직일 수 없다.","title":"[BOJ] 20436 ZOAC 3 with Python"},{"content":"\n📌 BOJ 20440 니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마 - 1 💡 조건 어떤 모기가 방에 언제 입장했고 언제 퇴장했는지를 기록할 수 있다. 방에 출입한 모기의 마릿수 N(1 ≤ N ≤ 1,000,000) N개의 줄에 모기의 입장 시각 TE과 퇴장 시각 TX이 주어진다. (0 ≤ TE \u0026lt; TX ≤ 2,100,000,000)\n모기는 [TE, Tx)동안 존재한다. 첫째 줄에 지동이 방에 모기가 가장 많이 있는 시간대의 모기 마릿수를 출력한다.\n방에 모기가 가장 많이 있는 시간대의 연속 구간 전체를 [TEm, TXm)이라고 할 때,\n둘째 줄에 TEm, TXm을 공백으로 구분하여 출력한다.\n단, 여러 가지 방법이 있으면 가장 빠른 시작 시각을 기준으로 출력한다. 모기들의 방 입장, 퇴장 시각이 주어졌을 때 모기들이 가장 많이 있는 시간대와 해당 시간대에 모기가 몇 마리가 있는지 구하는 문제 imos, 누적 합, 좌표압축 유형의 문제 🔖 예제 및 실행결과 예제 1 3 2 16 4 6 6 10 실행결과 1 2 4 10 예제 2 3 0 16 0 6 0 10 실행결과 2 3 0 6 ⌨️ 문제 풀이 먼저, 나는 좌표 압축 + imos 알고리즘을 통해 문제를 풀이했다.\n좌표압축이란 모든 구간이 아니라, 중요한 구간 혹은 숫자만 들고있는 기법이다.\n순위가 중요한 알고리즘에서 입력값의 개수 \u0026lt; 입력값의 범위일때 사용한다.\n문제에서 주어지는 모기들이 존재하는 시간은 최대 100만 개이다.\n모기들이 존재할 수 있는 시간대는 0에서 최대 21억까지이기 때문에 모든 구간을 순회하면서 구간합을 구할 수는 없다.\n따라서 (2)번에서 설명한 좌표압축을 통해 내가 필요한, 중요한 구간의 번호만 관리해야 한다.\n이 때, 모기들이 존재할 수 있는 구간은 최대 200만개의 정보가 되기에 중요한 정보를 모두 리스트에 넣어 관리할 수 있다.\n(4)번의 생각을 구현하기 위해서 나는 time_set = set() 집합 자료형을 통해 중복을 제거했다.\n이 set() 자료형의 길이 + 1만큼 리스트를 생성했다.\n생성한 리스트에 각 모기의 좌표를 update 해주면 중복제거가 되며, 이를 다시 리스트로 만들어주고 정렬한다.\n(5)번의 작업을 진행하면서, 각 시간대를 저장할 time 리스트에 각 구간을 tuple로 묶어넣어 관리한다.\n예제 1번을 예로 들었을 때, set() 자료형에는 {2, 4, 6, 10, 16} 이 들어가 있고, 이를 기준으로 만든 배열을 대응 시키면\n2는 인덱스 0, 4는 인덱스 1에 대응된다.\n대응되는 관계를 dictionary 자료형을 사용해 저장해주면 관리가 쉽다.\ntime_set 의 길이 + 1만큼 생성한 리스트는 imos 알고리즘을 사용해 구간을 갱신시킬 것.\nimos 알고리즘이란, 각 쿼리가 구간 [s, e] 내의 값을 갱신시키는 경우,\n이를 매 쿼리마다 일일히 갱신하지 않고, 시작과 끝만 기록해두었다가 마지막에 한 번의 처리로 값을 시뮬레이팅하는 방법이다.\n아무리 많은 쿼리가 있더라도, O(N)의 시간을 보장한다.(개사기)\n모기가 존재하는 구간의 정보를 담아두었던 time을 순회하면서, 1. 모기가 있는 구간의 시작(s) 시간이 prefix 리스트에 대응하는 원소값에 +1을 해준다.\n이는 dictionary[s] += 1 을 통해서 쉽게 할 수 있다. 2. 모기가 있는 구간의 끝(e) 시간이 prefix 리스트에 대응하는 원소값에 -1을 해준다.\n이제 prefix 리스트를 순회하면서 구간합을 구해주며, 이 prefix 리스트의 max값을 구해 max_val에 저장한다.\n문제 지문에서 단, 여러 가지 방법이 있으면 가장 빠른 시작 시각을 기준으로 출력한다. 라고 했다.\nprefix를 순회하면서 max_val이 어느 인덱스부터 시작하는지 저장하고, 어느 구간에서 달라지는지 저장한 뒤, 출력하면 된다.\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) time = [] time_set = set() for i in range(n): s, e = map(int, stdin.readline().split()) time.append((s, e)) time_set.update([s, e]) d = {} cnt = 0 time_set = list(time_set) time_set.sort() for i in time_set: d[i] = cnt cnt += 1 prefix = [0 for _ in range(len(time_set) + 1)] for s, e in time: prefix[d[s]] += 1 prefix[d[e]] -= 1 max_val = 0 for i in range(len(time_set)): prefix[i] = prefix[i] + prefix[i - 1] if prefix[i] \u0026gt; max_val: max_val = prefix[i] print(max_val) ans = [0, 0] tf = False for i in range(len(time_set) + 1): if prefix[i] == max_val and not tf: ans[0] = time_set[i] tf = True if prefix[i] != max_val and tf: ans[1] = time_set[i] break print(*ans) 💾 느낀점 imos 알고리즘, 구간합의 확장 좌표압축을 통해 관리하려는 데이터의 수 최소화하기 (1), (2) 를 통해 prefix 를 할 때, 큰 범위를 좁게 좁혀 구할 수 있는 방법 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20440-%EB%8B%88%EA%B0%80-%EC%8B%AB%EC%96%B4-%EC%8B%AB%EC%96%B4-%EB%84%88%EB%AC%B4-%EC%8B%AB%EC%96%B4-%EC%8B%AB%EC%96%B4-%EC%98%A4%EC%A7%80-%EB%A7%88-%EB%82%B4%EA%B2%8C-%EC%B0%9D%EC%A9%8D%EB%8C%80%EC%A7%80%EB%A7%88-1-with-python/","summary":"📌 BOJ 20440 니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마 - 1 💡 조건 어떤 모기가 방에 언제 입장했고 언제 퇴장했는지를 기록할 수 있다. 방에 출입한 모기의 마릿수 N(1 ≤ N ≤ 1,000,000) N개의 줄에 모기의 입장 시각 TE과 퇴장 시각 TX이 주어진다. (0 ≤ TE \u0026lt; TX ≤ 2,100,000,000)\n모기는 [TE, Tx)동안 존재한다. 첫째 줄에 지동이 방에 모기가 가장 많이 있는 시간대의 모기 마릿수를 출력한다.","title":"[BOJ] 20440 🎵니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마🎵 - 1 with Python"},{"content":"\n📌 BOJ 18004 From A to B 💡 조건 두 개의 정수인 a와 b가 입력된다. 일련의 작업을 수행하여 a를 b로 만들려고 한다. 다음의 두가지 작업만 할 수 있다. 짝수인 경우에만 2로 나누기. 1 더하기 (1 ≤ a , b ≤ 10 9 ) a 를 b 로 변환하는 데 필요한 주어진 연산의 최소 횟수를 출력하는 문제 수학, 그리디 알고리즘, BFS 유형의 문제 🔖 예제 및 실행결과 예제 103 27 실행결과 4 ⌨️ 문제 풀이 a 와 b 정수를 입력받고, a 를 b로 만드는 문제이다. a에 연산할 수 있는 두가지 연산을 가지고 b를 만들어야하는데, 나누기와 더하기 1이다. 문제의 첫번째 연산은 a를 작게 만드는 연산인만큼, a가 b보다 작으면 할 필요가 없는 연산이다. BFS 알고리즘을 통해서 queue에 a를 연산한 값과 연산한 횟수를 넣어 관리한다. (3)번 조건에 의해 queue에서 뽑아낸 연산된 a가 b보다 작아지면 현재 연산한 횟수와 (b - queue에서 뽑아낸 연산된 a)값을 더해 리턴한다. 🖥 소스 코드 from collections import deque from sys import stdin a, b = map(int, stdin.readline().split()) def solve(): q = deque() if a \u0026lt;= b: print(b - a) return q.append((0, a)) while q: cost, now = q.popleft() if now == b: print(cost) return if now \u0026gt; b: if now % 2 == 0: q.append((cost + 1, now // 2)) else: q.append((cost + 1, now + 1)) else: print(cost + (b - now)) return solve() ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-18004-from-a-to-b-with-python/","summary":"📌 BOJ 18004 From A to B 💡 조건 두 개의 정수인 a와 b가 입력된다. 일련의 작업을 수행하여 a를 b로 만들려고 한다. 다음의 두가지 작업만 할 수 있다. 짝수인 경우에만 2로 나누기. 1 더하기 (1 ≤ a , b ≤ 10 9 ) a 를 b 로 변환하는 데 필요한 주어진 연산의 최소 횟수를 출력하는 문제 수학, 그리디 알고리즘, BFS 유형의 문제 🔖 예제 및 실행결과 예제 103 27 실행결과 4 ⌨️ 문제 풀이 a 와 b 정수를 입력받고, a 를 b로 만드는 문제이다.","title":"[BOJ] 18004 From A to B with Python"},{"content":"\n📌 BOJ 20114 미아 노트 💡 조건 노트에 적힌 문자열이 번진 패턴은 일정했는데, 가령 \u0026ldquo;abc\u0026rdquo; 문자가 세로로 3글자씩, 가로로 2글자씩 번진 경우는 다음과 같았다. 아쉽게도 번진 문자열의 일부는 지워진 상태였다.\n너무 많이 지워져버려서 해당 자리의 문자를 유추할 수 없는 경우, 완전히 문자열을 복원하지 못할 수도 있다. 첫째 줄에 원래 문자열의 길이 N, 세로로 번진 글자의 개수 H, 가로로 번진 글자의 개수 W가 주어진다.\n(1 ≤ N ≤ 100, 1 ≤ H ≤ 10, 1 ≤ W ≤ 10) H개의 줄에 걸쳐 N × W 길이의 문자열이 주어진다.\n문자열은 알파벳 소문자 또는 \u0026lsquo;?\u0026lsquo;로만 이루어져 있다.\n\u0026lsquo;?\u0026lsquo;는 해당 자리의 문자가 지워진 경우를 뜻한다. 문자가 번진 자리에 두 개 이상의 문자가 있는 등 모순되는 경우는 입력으로 주어지지 않는다. 문자열, 구현 유형의 문제 🔖 예제 및 실행결과 예제 6 2 3 ???rrruuu???ttt??? f?f?rruuu?????t??? 실행결과 fru?t? ⌨️ 문제 풀이 원래의 문자열의 길이를 복원하는 문제이다. 원래의 문자열의 길이만큼 반복하면서 해당 문자열의 위치(변수 x) 부터 번진만큼 반복문을 통해 원래 문자를 찾는다. 원래 문자열의 위치 x부터 가로로 번진만큼 반복하고, 세로로 번진만큼 또 반복을 하면서 원래 문자열을 지금 찾을 수 있는지 알아본다. ans에 문자열을 찾을 수 있다면 찾은 해당 문자열을 넣고, 아니라면 ? 를 넣는다. 🖥 소스 코드 from sys import stdin n, h, w = map(int, stdin.readline().split()) arr = [list(stdin.readline().rstrip()) for _ in range(h)] def solve(x): global ans for i in range(x * w, (x + 1) * w): for j in range(h): if arr[j][i] != \u0026#39;?\u0026#39;: ans += arr[j][i] return ans += \u0026#39;?\u0026#39; return ans = \u0026#39;\u0026#39; for i in range(n): solve(i) print(ans) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20114-%EB%AF%B8%EC%95%84-%EB%85%B8%ED%8A%B8-with-python/","summary":"📌 BOJ 20114 미아 노트 💡 조건 노트에 적힌 문자열이 번진 패턴은 일정했는데, 가령 \u0026ldquo;abc\u0026rdquo; 문자가 세로로 3글자씩, 가로로 2글자씩 번진 경우는 다음과 같았다. 아쉽게도 번진 문자열의 일부는 지워진 상태였다.\n너무 많이 지워져버려서 해당 자리의 문자를 유추할 수 없는 경우, 완전히 문자열을 복원하지 못할 수도 있다. 첫째 줄에 원래 문자열의 길이 N, 세로로 번진 글자의 개수 H, 가로로 번진 글자의 개수 W가 주어진다.\n(1 ≤ N ≤ 100, 1 ≤ H ≤ 10, 1 ≤ W ≤ 10) H개의 줄에 걸쳐 N × W 길이의 문자열이 주어진다.","title":"[BOJ] 20114 미아 노트 with Python"},{"content":"\n📌 BOJ 17839 Baba is Rabbit 💡 조건 N(1 ≤ N ≤ 100,000) N개의 줄에 걸쳐 명령이 주어진다.\n각 명령은 p is q의 형태로 주어지며, p와 q는 첫 글자가 영문 대문자이고, 나머지 글자는 영문 소문자인 길이 10 이내의 문자열이다. Baba에 명령을 한 번 이상 적용한 결과로 나올 수 있는 사물을 사전순으로 출력한다.\n단, 적용할 수 있는 명령이 없다면, 아무것도 출력하지 않는다. 그래프 탐색, BFS 유형의 문제 🔖 예제 및 실행결과 예제 1 1 Rabbit is Carrot 실행결과 1 예제 2 3 Rabbit is Carrot Baba is Cat Cat is Rabbit 실행결과 2 Carrot Cat Rabbit ⌨️ 문제 풀이 Baba에 명령을 한 번 이상 적용한 결과로 나올 수 있는 결과를 뽑아야하는 문제이다. 그래프 탐색을 해야하는데, 문자열로 이루어진 노드로 구성된 그래프를 만들어야 하기 때문에 딕셔너리 타입을 사용해 그래프를 만들어야 한다.\n어떤 사물 p에 명령을 한 번 이상 적용한 결과로 다시 p가 나오는 경우는 없다. 라는 조건이 있기 때문에 단방향 그래프를 만들어주면 된다. 만든 그래프를 BFS 로 탐색하면 되는데, Baba 에 명령을 한 번 이상 해야하기 때문에 큐에는 Baba를 넣어 탐색을 시작한다. 딕셔너리에 해당 키가 없을 수 있기 때문에 try - except 문을 사용하여 예외처리를 해준다. 🖥 소스 코드 from collections import deque from sys import stdin graph = {} for _ in range(int(stdin.readline())): a, b = stdin.readline().rstrip().split(\u0026#39; is \u0026#39;) if a not in graph: graph[a] = [b] else: graph[a].append(b) def solve(): q = deque() q.append(\u0026#34;Baba\u0026#34;) visited = {} while q: now = q.popleft() try: for i in graph[now]: if i not in visited: visited[i] = 1 q.append(i) except: pass return visited try: ans = sorted(solve()) print(*ans, sep=\u0026#39;n\u0026#39;) except: pass 💾 느낀점 숫자가 아닌 문자열로 이루어진 그래프를 만들고, 탐색하는 법 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-17839-baba-is-rabbit-with-python/","summary":"📌 BOJ 17839 Baba is Rabbit 💡 조건 N(1 ≤ N ≤ 100,000) N개의 줄에 걸쳐 명령이 주어진다.\n각 명령은 p is q의 형태로 주어지며, p와 q는 첫 글자가 영문 대문자이고, 나머지 글자는 영문 소문자인 길이 10 이내의 문자열이다. Baba에 명령을 한 번 이상 적용한 결과로 나올 수 있는 사물을 사전순으로 출력한다.\n단, 적용할 수 있는 명령이 없다면, 아무것도 출력하지 않는다. 그래프 탐색, BFS 유형의 문제 🔖 예제 및 실행결과 예제 1 1 Rabbit is Carrot 실행결과 1 예제 2 3 Rabbit is Carrot Baba is Cat Cat is Rabbit 실행결과 2 Carrot Cat Rabbit ⌨️ 문제 풀이 Baba에 명령을 한 번 이상 적용한 결과로 나올 수 있는 결과를 뽑아야하는 문제이다.","title":"[BOJ] 17839 Baba is Rabbit with Python"},{"content":"\n📌 BOJ 1951 활자 💡 조건 N(1 ≤ N ≤ 2,000,000,000) 가나다라는 글씨를 쓰기 위해서는 3개의 활자가 필요하다.\nN이하의 자연수를 활자로 표현하기 위해서는 몇 개의 활자가 필요한지 구하는 문제 10이하의 자연수를 활자로 표현하려면 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0 이렇게 11개의 활자가 필요하다. 첫째 줄에 필요한 활자의 수를 1234567로 나눈 나머지를 출력. 수학 유형의 문제 🔖 예제 및 실행결과 예제 10 실행결과 11 ⌨️ 문제 풀이 일단 먼저, N의 크기를 확인해보자. N이 무려 2억을 넘어 천장을 뚫고 20억이다.\n1부터 N까지 올라가면서 각 숫자를 세어본다는 아이디어에서 못벗어나 코드를 짰다면 반성해야하며, 난 반성하고 있다. 0부터 9까지 몇 개의 숫자를 사용했는지 저장할 리스트 s를 만든다. N이 0 이 될 때까지 반복문을 돌려주면되는데, N 을 10으로 나눈 나머지가 9가 아닐 경우, n을 문자열로 만들어 s[해당 숫자]에 point 만큼 숫자를 더해준다.\n그 후 n - 1 을 해준다. 이 작업은 10으로 나눈 나머지가 9가 될 때까지 반복한다.\n이 후, 아래의 두가지 조건을 다시 살펴본다. N 을 10으로 나눈 나머지가 9이며 10보다 작을 경우, 각 자리의 값을 point 만큼 늘려준다 0에 해당하는 숫자는 point를 빼준다.\n이 작업이 완료되면 break. N 을 10으로 나눈 나머지가 9이며 10보다 클 경우, s를 순회하면서 s[i]의 값을 (n // 10 + 1) * point 만큼 늘려준다.이 세가지 조건문에 해당하는 작업을 완료하고, s[0] - point, point의 값을 * 10, n // 10 을 해준다. (3-1) 조건은 1의 자리 수를 9가 아닌 수로 만들기 위해서 하는 작업이다.\n9는 0~9까지 한번씩 모두 사용하기 때문이다. (3-2) 조건은 N이 한자리 수로 떨어졌을 때, 사용할 조건이다. 굳이 뭘 계산할 필요없이 s의 각 원소에 point를 더해주면 된다. 🖥 소스 코드 n = int(input()) s = [0 for i in range(10)] point = 1 while n != 0: while n % 10 != 9: for i in str(n): s[int(i)] += point n -= 1 if n \u0026lt; 10: for i in range(n + 1): s[i] += point s[0] -= point break else: for i in range(10): s[i] += (n // 10 + 1) * point s[0] -= point point *= 10 n //= 10 print(sum(s) % 1234567) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1951-%ED%99%9C%EC%9E%90-with-python/","summary":"📌 BOJ 1951 활자 💡 조건 N(1 ≤ N ≤ 2,000,000,000) 가나다라는 글씨를 쓰기 위해서는 3개의 활자가 필요하다.\nN이하의 자연수를 활자로 표현하기 위해서는 몇 개의 활자가 필요한지 구하는 문제 10이하의 자연수를 활자로 표현하려면 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0 이렇게 11개의 활자가 필요하다. 첫째 줄에 필요한 활자의 수를 1234567로 나눈 나머지를 출력. 수학 유형의 문제 🔖 예제 및 실행결과 예제 10 실행결과 11 ⌨️ 문제 풀이 일단 먼저, N의 크기를 확인해보자.","title":"[BOJ] 1951 활자 with Python"},{"content":"\n📌 BOJ 14562 태권왕 💡 조건 테스트 케이스의 수 C(1 ≤ C ≤ 100)\n현재 점수 S와 T가 공백을 사이에 두고 주어진다. (1 ≤ S \u0026lt; T ≤ 100) 태균이가 현재 할 수 있는 연속 발차기는 두가지가 있다.\nA는 현재 점수만큼 점수를 얻을 수 있는 엄청난 연속 발차기이다. 하지만 상대 역시 3점을 득점하는 위험이 있다.\nB는 1점을 얻는 연속 발차기이다. 태균이의 점수 S와 상대의 점수 T가 주어질 때, S와 T가 같아지는 최소 연속 발차기 횟수를 구하는 문제 BFS(너비우선탐색) 유형의 문제 🔖 예제 및 실행결과 예제 6 10 20 2 7 15 62 10 37 11 50 34 59 실행결과 3 3 4 4 5 25 ⌨️ 문제 풀이 BFS로 점수를 얻을 수 있는 점수를 큐에 추가한다. (time + 1, s 16926 배열 돌리기 1* 2, t + 3)는 내가 현재 점수만큼 점수를 얻고, 상대방에게 점수를 3점 내어주는 상태. (time + 1, s + 1, t) 는 내가 1점만큼 점수를 얻을 수 있는 상태 (현재 나의 점수 16926 배열 돌리기 1* 2)의 상태를 만든 적이 없다면 (2)번을,\n(현재나의 점수 + 1)의 상태를 만든적이 없다면 (3)번의 상태를 큐에 넣어준다. 현재 나의 점수와 상대방의 점수가 같으면 return 🖥 소스 코드 from sys import stdin from collections import deque def solve(s, t): q = deque() q.append((0, s, t)) while q: time, s, t = q.popleft() if s == t: return time if (t + 3) \u0026gt;= s * 2: if use[s * 2] == -1: q.append((time + 1, s * 2, t + 3)) if use[s + 1] == -1: q.append((time + 1, s + 1, t)) for _ in range(int(stdin.readline())): s, t = map(int, stdin.readline().split()) use = [-1 for _ in range(100001)] print(solve(s, t)) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14562-%ED%83%9C%EA%B6%8C%EC%99%95-with-python/","summary":"📌 BOJ 14562 태권왕 💡 조건 테스트 케이스의 수 C(1 ≤ C ≤ 100)\n현재 점수 S와 T가 공백을 사이에 두고 주어진다. (1 ≤ S \u0026lt; T ≤ 100) 태균이가 현재 할 수 있는 연속 발차기는 두가지가 있다.\nA는 현재 점수만큼 점수를 얻을 수 있는 엄청난 연속 발차기이다. 하지만 상대 역시 3점을 득점하는 위험이 있다.\nB는 1점을 얻는 연속 발차기이다. 태균이의 점수 S와 상대의 점수 T가 주어질 때, S와 T가 같아지는 최소 연속 발차기 횟수를 구하는 문제 BFS(너비우선탐색) 유형의 문제 🔖 예제 및 실행결과 예제 6 10 20 2 7 15 62 10 37 11 50 34 59 실행결과 3 3 4 4 5 25 ⌨️ 문제 풀이 BFS로 점수를 얻을 수 있는 점수를 큐에 추가한다.","title":"[BOJ] 14562 태권왕 with Python"},{"content":"\n📌 BOJ 20125 쿠키의 신체 측정 💡 조건 쿠키들은 신체를 측정하기 위해서 한 변의 길이가 N인 정사각형 판 위에 누워있으며, 어느 신체 부위도 판 밖으로 벗어나지 않는다. 판의 x번째 행, y번째 열에 위치한 곳을 (x, y)로 지칭한다. 판의 맨 왼쪽 위 칸을 (1, 1), 오른쪽 아래 칸을 (N, N)으로 나타낼 수 있다. 쿠키의 신체는 머리, 심장, 허리, 그리고 좌우 팔, 다리로 구성되어 있다. 그림에서 빨간 곳으로 칠해진 부분이 심장이다. 머리는 심장 바로 윗 칸에 1칸 크기로 있다.\n왼쪽 팔은 심장 바로 왼쪽에 붙어있고 왼쪽으로 뻗어 있으며, 오른쪽 팔은 심장 바로 오른쪽에 붙어있고 오른쪽으로 뻗어있다.\n허리는 심장의 바로 아래 쪽에 붙어있고 아래 쪽으로 뻗어 있다.\n왼쪽 다리는 허리의 왼쪽 아래에, 오른쪽 다리는 허리의 오른쪽 아래에 바로 붙어있고, 각 다리들은 전부 아래쪽으로 뻗어 있다.\n각 신체 부위들은 절대로 끊겨있지 않으며 굽혀진 곳도 없다.\n또한, 허리, 팔, 다리의 길이는 1 이상이며, 너비는 무조건 1이다. 쿠키의 신체가 주어졌을 때 심장의 위치와 팔, 다리, 허리의 길이를 구하는 문제 5 ≤ N ≤ 1,000. N은 판의 한 변의 길이를 의미하는 양의 정수다. ai,j는 * 또는 _이다. *는 쿠키의 신체 부분이고, _는 쿠키의 신체가 올라가 있지 않은 칸을 의미한다. (1 ≤ i, j ≤ N) 쿠키의 신체 조건에 위배되는 입력은 주어지지 않는다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 5 _____ __*__ _***_ __*__ _*_*_ 실행결과 3 3 1 1 1 1 1 🖥 소스 코드 from sys import stdin arr = [] n = int(stdin.readline()) for i in range(n): arr.append(list(stdin.readline().rstrip())) heo, l_leg, r_leg = 0, 0, 0 def find_heart(): for i in range(n): for j in range(n): if arr[i][j] == \u0026#39;*\u0026#39;: return (i, j), (i + 1, j) head, heart = find_heart() l_arm = arr[heart[0]][:heart[1]].count(\u0026#39;*\u0026#39;) r_arm = arr[heart[0]][heart[1] + 1:].count(\u0026#39;*\u0026#39;) for i in range(heart[0] + 1, n): if arr[i][heart[1]] != \u0026#39;*\u0026#39;: last_heo = (i, heart[1]) break else: heo += 1 for i in range(last_heo[0], n): if arr[i][heart[1] - 1] == \u0026#39;*\u0026#39;: l_leg += 1 if arr[i][heart[1] + 1] == \u0026#39;*\u0026#39;: r_leg += 1 print(heart[0] + 1, heart[1] + 1) print(l_arm, r_arm, heo, l_leg, r_leg) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20125-%EC%BF%A0%ED%82%A4%EC%9D%98-%EC%8B%A0%EC%B2%B4-%EC%B8%A1%EC%A0%95-with-python/","summary":"📌 BOJ 20125 쿠키의 신체 측정 💡 조건 쿠키들은 신체를 측정하기 위해서 한 변의 길이가 N인 정사각형 판 위에 누워있으며, 어느 신체 부위도 판 밖으로 벗어나지 않는다. 판의 x번째 행, y번째 열에 위치한 곳을 (x, y)로 지칭한다. 판의 맨 왼쪽 위 칸을 (1, 1), 오른쪽 아래 칸을 (N, N)으로 나타낼 수 있다. 쿠키의 신체는 머리, 심장, 허리, 그리고 좌우 팔, 다리로 구성되어 있다. 그림에서 빨간 곳으로 칠해진 부분이 심장이다. 머리는 심장 바로 윗 칸에 1칸 크기로 있다.","title":"[BOJ] 20125 쿠키의 신체 측정 with Python"},{"content":"\n📌 BOJ 14696 딱지놀이 💡 조건 4, 3, 2, 1 에 해당하는 숫자가 각 몇 개인지 파악하여 승자가 누구인지 출력하는 문제 서브태크스가 존재한다. 출력의 i번째 (1 ≤ i ≤ N) 줄에 정확히 한 글자를 출력하는데, 출력하는 글자는 A, B, D 중 하나로 라운드 i의 결과를 나타낸다. 각 라운드의 결과는 A가 승자라면 A, B가 승자라면 B, 무승부라면 D이다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 5 1 4 4 3 3 2 1 5 2 4 3 2 1 4 4 3 3 1 4 3 2 1 1 4 2 3 2 1 4 4 3 2 1 3 4 3 2 5 4 4 2 3 1 5 4 2 4 1 3 실행결과 A B B A D 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): a = list(map(int, stdin.readline().split()))[1:] b = list(map(int, stdin.readline().split()))[1:] _4a, _4b = a.count(4), b.count(4) if _4a == _4b: _3a, _3b = a.count(3), b.count(3) if _3a == _3b: _2a, _2b = a.count(2), b.count(2) if _2a == _2b: _1a, _1b = a.count(1), b.count(1) if _1a == _1b: print(\u0026#39;D\u0026#39;) else: print(\u0026#39;A\u0026#39;) if _1a \u0026gt; _1b else print(\u0026#39;B\u0026#39;) else: print(\u0026#39;A\u0026#39;) if _2a \u0026gt; _2b else print(\u0026#39;B\u0026#39;) else: print(\u0026#39;A\u0026#39;) if _3a \u0026gt; _3b else print(\u0026#39;B\u0026#39;) else: print(\u0026#39;A\u0026#39;) if _4a \u0026gt; _4b else print(\u0026#39;B\u0026#39;) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14696-%EB%94%B1%EC%A7%80%EB%86%80%EC%9D%B4-with-python/","summary":"📌 BOJ 14696 딱지놀이 💡 조건 4, 3, 2, 1 에 해당하는 숫자가 각 몇 개인지 파악하여 승자가 누구인지 출력하는 문제 서브태크스가 존재한다. 출력의 i번째 (1 ≤ i ≤ N) 줄에 정확히 한 글자를 출력하는데, 출력하는 글자는 A, B, D 중 하나로 라운드 i의 결과를 나타낸다. 각 라운드의 결과는 A가 승자라면 A, B가 승자라면 B, 무승부라면 D이다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 5 1 4 4 3 3 2 1 5 2 4 3 2 1 4 4 3 3 1 4 3 2 1 1 4 2 3 2 1 4 4 3 2 1 3 4 3 2 5 4 4 2 3 1 5 4 2 4 1 3 실행결과 A B B A D 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.","title":"[BOJ] 14696 딱지놀이 with Python"},{"content":"\n📌 BOJ 16926 배열 돌리기 1 💡 조건 크기가 N×M인 배열이 있을 때, 배열을 반시계 방향으로 돌린다. 첫째 줄에 배열의 크기 N, M과 수행해야 하는 회전의 수 R이 주어진다.\n둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다. 2 ≤ N, M ≤ 300\n1 ≤ R ≤ 1,000\nmin(N, M) mod 2 = 0\n1 ≤ Aij ≤ 108 배열을 R번 회전시킨 결과를 출력하는 문제 구현 유형의 문제 🔖 예제 및 실행결과 예제 5 4 7 1 2 3 4 7 8 9 10 13 14 15 16 19 20 21 22 25 26 27 28 실행결과 28 27 26 25 22 9 15 19 16 8 21 13 10 14 20 7 4 3 2 1 🖥 소스 코드 from sys import stdin n, m, r = map(int, stdin.readline().split()) arr = [] for i in range(n): arr.append(list(map(int, stdin.readline().split()))) for _ in range(r): for i in range(min(n, m) // 2): x, y = i, i value = arr[x][y] for j in range(i + 1, n - i): # 좌 x = j prev_value = arr[x][y] arr[x][y] = value value = prev_value for j in range(i + 1, m - i): # 하 y = j prev_value = arr[x][y] arr[x][y] = value value = prev_value for j in range(i + 1, n - i): # 우 x = n - j - 1 prev_value = arr[x][y] arr[x][y] = value value = prev_value for j in range(i + 1, m - i): # 상 y = m - j - 1 prev_value = arr[x][y] arr[x][y] = value value = prev_value for i in arr: print(*i) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-16926-%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0-1-with-python/","summary":"📌 BOJ 16926 배열 돌리기 1 💡 조건 크기가 N×M인 배열이 있을 때, 배열을 반시계 방향으로 돌린다. 첫째 줄에 배열의 크기 N, M과 수행해야 하는 회전의 수 R이 주어진다.\n둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다. 2 ≤ N, M ≤ 300\n1 ≤ R ≤ 1,000\nmin(N, M) mod 2 = 0\n1 ≤ Aij ≤ 108 배열을 R번 회전시킨 결과를 출력하는 문제 구현 유형의 문제 🔖 예제 및 실행결과 예제 5 4 7 1 2 3 4 7 8 9 10 13 14 15 16 19 20 21 22 25 26 27 28 실행결과 28 27 26 25 22 9 15 19 16 8 21 13 10 14 20 7 4 3 2 1 🖥 소스 코드 from sys import stdin n, m, r = map(int, stdin.","title":"[BOJ] 16926 배열 돌리기 1 with Python"},{"content":"\n📌 BOJ 11508 2+1 세일 💡 조건 유제품 3개를 한 번에 산다면 그중에서 가장 싼 것은 무료로 지불하고 나머지 두 개의 제품 가격만 지불하면 됩니다. 한 번에 3개의 유제품을 사지 않는다면 할인 없이 정가를 지불해야 합니다. 유제품의 수 N (1 ≤ N ≤ 100,000) N개의 줄에는 각 유제품의 가격 Ci (1 ≤ Ci ≤ 100,000)\n정답은 231-1보다 작거나 같다. 최소비용으로 유제품을 구입할 수 있도록 도와주는 문제. 그리디, 정렬 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 4 3 2 3 2 실행결과 8 ⌨️ 문제 풀이 유제품의 가격을 arr 배열에 입력 받는다. arr 리스트를 역순으로 정렬(내림차순)한다. 역순으로 정렬된 arr 리스트를 순회하면서 어떤 조건에 해당하지 않으면 ans 에 arr[i]을 추가해줄 것 이다. (3)에서 말한 조건 \u0026raquo; 가장 비싼 물건 순으로 꾸러미에 넣으면, 최소한 세번째로 비싼 물건을 무료가 될 수 있다. 그렇기 때문에 i 를 mod 3 연산을 해주어 이미 상품 두 개를 꾸러미에 넣었다면, 세번째는 무료이기 때문에 ans에 값을 더해주지 않아도 된다는 것. 🖥 소스 코드 from sys import stdin arr = [] n = int(stdin.readline()) for i in range(n): arr.append(int(stdin.readline())) arr.sort(reverse=True) ans = 0 for i in range(n): if i % 3 != 2: ans += arr[i] print(ans) 💾 느낀점 단순 그리디 문제였는데, 잘 풀지 못했다. 그리디 알고리즘이 묻어(?)있는 유형의 문제들을 매우 고전하는 모습이 보인다. 경우의 수 문제도 헷갈리는데, 생각난 김에 복습을 해봐야할 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11508-2+1-%EC%84%B8%EC%9D%BC-with-python/","summary":"📌 BOJ 11508 2+1 세일 💡 조건 유제품 3개를 한 번에 산다면 그중에서 가장 싼 것은 무료로 지불하고 나머지 두 개의 제품 가격만 지불하면 됩니다. 한 번에 3개의 유제품을 사지 않는다면 할인 없이 정가를 지불해야 합니다. 유제품의 수 N (1 ≤ N ≤ 100,000) N개의 줄에는 각 유제품의 가격 Ci (1 ≤ Ci ≤ 100,000)\n정답은 231-1보다 작거나 같다. 최소비용으로 유제품을 구입할 수 있도록 도와주는 문제. 그리디, 정렬 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 4 3 2 3 2 실행결과 8 ⌨️ 문제 풀이 유제품의 가격을 arr 배열에 입력 받는다.","title":"[BOJ] 11508 2+1 세일 with Python"},{"content":"\n📌 BOJ 12970 AB 💡 조건 문자열의 길이 n 0 ≤ i \u0026lt; j \u0026lt; N 이면서 s[i] == \u0026lsquo;A\u0026rsquo; \u0026amp;\u0026amp; s[j] == \u0026lsquo;B\u0026rsquo;를 만족하는 (i, j) 쌍의 개수 K 개가 있다. N과 K가 주어진다. (2 ≤ N ≤ 50, 0 ≤ K ≤ N(N-1)/2) 문제의 조건을 만족하는 문자열 S를 출력한다. 가능한 S가 여러 가지라면, 아무거나 출력한다. S가 존재하지 않는 경우에는 -1을 출력한다. 수학, 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 2 실행결과 ABB ⌨️ 문제 풀이 문자열 s는 B로 n만큼 채워서 초기화한다. 예제 4번을 예로 들면, BBBBBBBBBB 으로 먼저 s를 초기화한다. 오른쪽 기준 두번째 부터 A를 넣는데, 끝에 넣어봐야 쌍의 개수가 0이기 때문에 두번째부터 넣는다. A를 왼쪽으로 밀면서 쌍의 개수를 검사한다. curk 의 값이 k가 되었을 때, while 을 종료하고, 문자열을 출력해준다. 만약 while 이 종료된 후에도 curk 값이 k 의 값과 같지 않다면, 문자열을 만들 수 없는 것이니 -1을 출력한다. 🖥 소스 코드 from sys import stdin n, k = map(int, stdin.readline().split()) def solve(n, k): s = list(\u0026#39;B\u0026#39; * n) acnt, curk, lidx = 0, 0, -1 while curk \u0026lt; k: if lidx \u0026lt;= acnt - 1: if s[n - 1 - (acnt + 1)] == \u0026#39;A\u0026#39;: break s[n - 1 - (acnt + 1)] = \u0026#39;A\u0026#39; lidx = n - 1 - (acnt + 1) acnt += 1 curk += 1 else: s[lidx] = \u0026#39;B\u0026#39; s[lidx - 1] = \u0026#39;A\u0026#39; lidx -= 1 curk += 1 return s if curk == k else \u0026#39;-1\u0026#39; answer = solve(n, k) print(*answer, sep=\u0026#39;\u0026#39;) 💾 느낀점 그리디는 너무 어렵다. 문제가 조금 난이도가 높아지면 손을 대지 못하는 상황이 오는 것 같다. 그리디 유형을 더욱 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12970-ab-with-python/","summary":"📌 BOJ 12970 AB 💡 조건 문자열의 길이 n 0 ≤ i \u0026lt; j \u0026lt; N 이면서 s[i] == \u0026lsquo;A\u0026rsquo; \u0026amp;\u0026amp; s[j] == \u0026lsquo;B\u0026rsquo;를 만족하는 (i, j) 쌍의 개수 K 개가 있다. N과 K가 주어진다. (2 ≤ N ≤ 50, 0 ≤ K ≤ N(N-1)/2) 문제의 조건을 만족하는 문자열 S를 출력한다. 가능한 S가 여러 가지라면, 아무거나 출력한다. S가 존재하지 않는 경우에는 -1을 출력한다. 수학, 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 2 실행결과 ABB ⌨️ 문제 풀이 문자열 s는 B로 n만큼 채워서 초기화한다.","title":"[BOJ] 12970 AB with Python"},{"content":"\n📌 BOJ 2012 등수 매기기 💡 조건 2007년 KOI에 N명의 학생들이 참가하였다. 모든 학생들은 자신이 N명 중에서 몇 등을 할 것인지 예상 등수를 적어서 제출하도록 하였다. 1등부터 N등까지 동석차 없이 등수를 매겨야한다. 제출한 예상 등수를 바탕으로 임의로 등수를 매기기로 했다. 자신의 등수를 A등으로 예상하였는데 실제 등수가 B등이 될 경우, 이 사람의 불만도는 A와 B의 차이 (|A - B|)로 수치화할 수 있다. 당신은 N명의 사람들의 불만도의 총 합을 최소로 하면서, 학생들의 등수를 매기려고 한다. 자연수 N이 주어진다. (1 ≤ N ≤ 500,000) 둘째 줄부터 N개의 줄에 걸쳐 각 사람의 예상 등수가 순서대로 주어진다.\n예상 등수는 500,000 이하의 자연수이다. 그리디알고리즘, 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 1 5 3 1 2 실행결과 3 ⌨️ 문제 풀이 예상 등수를 입력받아 차례대로 list s 에 저장한다. list s 를 정렬 한 뒤, ans 변수를 0으로 초기화 하고, 1부터 n + 1까지 순회하면서 예상등수에 해당하는\n불만도를 계산하여 ans에 저장해준다. ans를 출력한다. 불만도를 정렬하여 실제 등수와 비교하여 계산을 하면 최솟값을 구할 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) s = [] for i in range(n): s.append(int(stdin.readline())) s.sort() ans = 0 for i in range(1, n + 1): ans += abs(i - s[i - 1]) print(ans) 💾 느낀점 정렬하여 문제를 푸는 간단한 문제였습니다. 골드 5 난이도 정도의 그리디에 취약한 모습을 보이는 것 같아 연습이 많이 필요할 것 같습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2012-%EB%93%B1%EC%88%98-%EB%A7%A4%EA%B8%B0%EA%B8%B0-with-python/","summary":"📌 BOJ 2012 등수 매기기 💡 조건 2007년 KOI에 N명의 학생들이 참가하였다. 모든 학생들은 자신이 N명 중에서 몇 등을 할 것인지 예상 등수를 적어서 제출하도록 하였다. 1등부터 N등까지 동석차 없이 등수를 매겨야한다. 제출한 예상 등수를 바탕으로 임의로 등수를 매기기로 했다. 자신의 등수를 A등으로 예상하였는데 실제 등수가 B등이 될 경우, 이 사람의 불만도는 A와 B의 차이 (|A - B|)로 수치화할 수 있다. 당신은 N명의 사람들의 불만도의 총 합을 최소로 하면서, 학생들의 등수를 매기려고 한다.","title":"[BOJ] 2012 등수 매기기 with Python"},{"content":"\n📌 BOJ 2302 극장 좌석 💡 조건 어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다.\n공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다. 오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다.\nVIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오. N은 1 이상 40 이하이다. 둘째 줄에는 고정석의 개수 M이 입력된다.\n방법의 가짓수는 2,000,000,000을 넘지 않는다. (2,000,000,000 \u0026lt; 231-1) 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 9 2 4 7 실행결과 12 ⌨️ 문제 풀이 m 의 크기만 큼 수를 입력받아 vip 리스트에 저장한다. n의 값에 따라 가짓수를 정리하면 아래와 같다.\nn = 0 일 때는 한가지로 본다.\nn = 1 일 때는 1\nn = 2 일 때는 2\nn = 3 일 때는 3\nn = 4 일 때는 5 (2)번을 정리하면 피보나치 수열과 같다.\n점화식은 dp[i] = dp[i-2] + dp[i-1] 이 되겠다. arr 리스트를 생성하고 피보나치 수열을 만들어준다. vip 가 있는 경우, vip는 제자리에만 있어야하기 때문에\nvip의 수만큼 순회하면서 각 vip 자리 이전 번호에서 이전 vip 번호를 뺀 arr의 값까지의\n경우의 수를 곱해준다. 🖥 소스 코드 from sys import stdin n, m = int(stdin.readline()), int(stdin.readline()) vip = [] for _ in range(m): vip.append(int(stdin.readline())) arr = [1, 1, 2] for i in range(3, 41): arr.append(arr[i-2] + arr[i-1]) ans = 1 if m \u0026gt; 0: pre = 0 for i in range(m): ans *= arr[vip[i] - 1 - pre] pre = vip[i] ans *= arr[n - pre] else: ans = arr[n] print(ans) 💾 느낀점 다이나믹프로그래밍이 너무 어렵다는 것을 다시 한 번 느꼈다. 점화식을 구현하지 못하는 부분에서 문제를 이해하지 못하는 것인가를 생각하고 처음부터 찬찬히 살펴본 문제였다. 이해를 한 후, 블로그 포스팅을 하면서 다시 복기를 하니 처음보다 이해가 쉬웠다. (3)번처럼 쉬운 느낌을 받았다고 하나, 비슷한 유형을 풀 수 있을까? 라는 질문에는 자신있게 대답하지는 못하겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2302-%EA%B7%B9%EC%9E%A5-%EC%A2%8C%EC%84%9D-with-python/","summary":"📌 BOJ 2302 극장 좌석 💡 조건 어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다.\n공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다. 오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다.","title":"[BOJ] 2302 극장 좌석 with Python"},{"content":"\n📌 BOJ 1145 적어도 대부분의 배수 💡 조건 다섯 개의 자연수가 있다. 이 수의 적어도 대부분의 배수는 위의 수 중 적어도 세 개로 나누어 지는 가장 작은 자연수이다. 서로 다른 다섯 개의 자연수가 주어질 때, 적어도 대부분의 배수를 출력하는 문제 100보다 작거나 같은 자연수이고, 서로 다른 수이다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 1 2 3 4 5 실행결과 4 ⌨️ 문제 풀이 math 라이브러리의 lcm 함수를 사용하여 문제를 풀었다. 5개의 숫자 중 3개를 뽑아 최소공배수를 구해 출력하면 된다. math 라이브러리의 lcm 함수는 python 3.9 버전부터 사용이 가능하다. 🖥 소스 코드 from sys import stdin from math import lcm arr = list(map(int, stdin.readline().split())) res = int(1e9) for i in range(5): for j in range(i + 1, 5): for k in range(j + 1, 5): res = min(res, lcm(arr[i], arr[j], arr[k])) print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1145-%EC%A0%81%EC%96%B4%EB%8F%84-%EB%8C%80%EB%B6%80%EB%B6%84%EC%9D%98-%EB%B0%B0%EC%88%98-with-python/","summary":"📌 BOJ 1145 적어도 대부분의 배수 💡 조건 다섯 개의 자연수가 있다. 이 수의 적어도 대부분의 배수는 위의 수 중 적어도 세 개로 나누어 지는 가장 작은 자연수이다. 서로 다른 다섯 개의 자연수가 주어질 때, 적어도 대부분의 배수를 출력하는 문제 100보다 작거나 같은 자연수이고, 서로 다른 수이다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 1 2 3 4 5 실행결과 4 ⌨️ 문제 풀이 math 라이브러리의 lcm 함수를 사용하여 문제를 풀었다.","title":"[BOJ] 1145 적어도 대부분의 배수 with Python"},{"content":"\n📌 BOJ 1343 폴리오미노 💡 조건 AAAA와 BB 폴리오미노 2개를 무한개만큼 가지고 있다. \u0026lsquo;.\u0026lsquo;와 \u0026lsquo;X\u0026rsquo;로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 \u0026lsquo;X\u0026rsquo;를 모두 폴리오미노로 덮으려고 한다.\n\u0026lsquo;.\u0026lsquo;는 폴리오미노로 덮으면 안 된다. 폴리오미노로 모두 덮은 보드판을 출력하는 문제 보드판의 크기는 최대 50이다. 문자열 유형의 문제 🔖 예제 및 실행결과 예제 XXXXXX 실행결과 AAAABB ⌨️ 문제 풀이 AAAA 네개가 들어갈 수 있다면 먼저 XXXX를 AAAA로 변경해준다. 그 후 XX를 BB로 변경해준다. 변경 후에도 X가 남아있다면 -1 출력\n없다면 변경된 문자를 출력 🖥 소스 코드 from sys import stdin p = stdin.readline().rstrip() p = p.replace(\u0026#39;XXXX\u0026#39;, \u0026#39;AAAA\u0026#39;) p = p.replace(\u0026#39;XX\u0026#39;, \u0026#39;BB\u0026#39;) if \u0026#39;X\u0026#39; in p: print(-1) else: print(p) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1343-%ED%8F%B4%EB%A6%AC%EC%98%A4%EB%AF%B8%EB%85%B8-with-python/","summary":"📌 BOJ 1343 폴리오미노 💡 조건 AAAA와 BB 폴리오미노 2개를 무한개만큼 가지고 있다. \u0026lsquo;.\u0026lsquo;와 \u0026lsquo;X\u0026rsquo;로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 \u0026lsquo;X\u0026rsquo;를 모두 폴리오미노로 덮으려고 한다.\n\u0026lsquo;.\u0026lsquo;는 폴리오미노로 덮으면 안 된다. 폴리오미노로 모두 덮은 보드판을 출력하는 문제 보드판의 크기는 최대 50이다. 문자열 유형의 문제 🔖 예제 및 실행결과 예제 XXXXXX 실행결과 AAAABB ⌨️ 문제 풀이 AAAA 네개가 들어갈 수 있다면 먼저 XXXX를 AAAA로 변경해준다. 그 후 XX를 BB로 변경해준다. 변경 후에도 X가 남아있다면 -1 출력","title":"[BOJ] 1343 폴리오미노 with Python"},{"content":"\n📌 BOJ 1038 감소하는 수 💡 조건 음이 아닌 정수 X의 자릿수가 가장 큰 자릿수부터 작은 자릿수까지 감소한다면, 그 수를 감소하는 수라고 한다. N번째 감소하는 수를 출력하는 문제. 0은 0번째 감소하는 수이고, 1은 1번째 감소하는 수이다. 만약 N번째 감소하는 수가 없다면 -1을 출력한다. N은 1,000,000보다 작거나 같은 자연수 또는 0이다. 백트래킹, 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 18 실행결과 42 ⌨️ 문제 풀이 줄어드는 수를 구해서 dp 리스트에 이어붙여준다. 0에서 9까지는 미리 dp 생성 할 때 넣어둔 후, 재귀함수를 호출해 줄어드는 수를 구해 넣어준다. dp 리스트를 정렬해준 뒤, n이 리스트의 범위를 초과한다면 -1을 출력해준다. 초과하지 않는다면 dp[n] 을 출력한다. 숫자를 순회하면서 하는 것이 아닌, 문자를 이어붙이면서 줄어드는 수를 만들면서 구하면 쉽게 구할 수 있다. 🖥 소스 코드 from sys import stdin dp = [x for x in range(10)] def solve(cnt, s, num): if cnt == len(s): dp.append(int(s)) return for i in range(num, -1, -1): if not s: solve(cnt, s + str(i), num - 1) else: if int(s[-1]) \u0026gt; i: solve(cnt, s + str(i), i - 1) for i in range(2, 11): solve(i, \u0026#39;\u0026#39;, 9) dp.sort() n = int(stdin.readline()) if len(dp) - 1 \u0026lt; n: print(-1) else: print(dp[n]) 💾 느낀점 조금 헤맬뻔 했지만 바로 정답을 맞출 수 있는, 티어에 비해 별로 어렵지 않은 문제였다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1038-%EA%B0%90%EC%86%8C%ED%95%98%EB%8A%94-%EC%88%98-with-python/","summary":"📌 BOJ 1038 감소하는 수 💡 조건 음이 아닌 정수 X의 자릿수가 가장 큰 자릿수부터 작은 자릿수까지 감소한다면, 그 수를 감소하는 수라고 한다. N번째 감소하는 수를 출력하는 문제. 0은 0번째 감소하는 수이고, 1은 1번째 감소하는 수이다. 만약 N번째 감소하는 수가 없다면 -1을 출력한다. N은 1,000,000보다 작거나 같은 자연수 또는 0이다. 백트래킹, 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 18 실행결과 42 ⌨️ 문제 풀이 줄어드는 수를 구해서 dp 리스트에 이어붙여준다.","title":"[BOJ] 1038 감소하는 수 with Python"},{"content":"\n📌 BOJ 12761 돌다리 💡 조건 돌의 번호는 0 부터 100,000 까지 존재하고 동규는 N번 돌 위에, 주미는 M번 돌 위에 위치하고 있다. 동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해 A, B 만큼의 힘을 가진 스카이 콩콩을 가져왔다. 현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 A나 B만큼 좌우로 점프할 수 있으며,\n순간적으로 힘을 모아 현 위치의 A배 나 B배의 위치로 이동을 할 수 있다. 이동 과정에서 100,000보다 크거나 0보다 작은 번호의 돌은 존재하지 않으므로 갈 수 없고,\n같은 방법을 계속 사용해도 되며 항상 도달할 수 있는 케이스만 주어진다. 첫 줄에 스카이 콩콩의 힘 A와 B, 그리고 동규의 현재위치 N, 주미의 현재 위치 M이 주어진다.\n(단, 2 \u0026lt;= A, B \u0026lt;= 30 이고 0 \u0026lt;= N, M \u0026lt;= 100,000) 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 3 7 2 98500 실행결과 10 ⌨️ 문제 풀이 -1로 채워진 dp 리스트를 생성한다. 이미 방문했던 돌다리는 건너지 않을 것이다.\n즉, -1이 아닌 돌다리만 밟고 갈 것이다. 현재 위치 n은 0으로 갱신해준다.\n또한 큐에 n을 넣어 이동을 시작한다. 조건 (3)번에 써놓았던 이동이 가능한 경우의 계산값을 순회하면서 0 과 100000 값 사이에 있는지 확인한다. (2)번의 조건에 해당한다면, dp[i] 의 값을 현재 위치에 해당하는 이동 값에서 + 1한 값을 저장해준다. 이동할 돌다리의 번호를 큐에 넣어준다. 큐가 비어서 끝나게 되면, N에서 출발하여 M까지 가는 최소 이동횟수 dp[M]을 출력한다. 🖥 소스 코드 from sys import stdin from collections import deque a, b, n, m = map(int, stdin.readline().split()) dp = [-1 for _ in range(100001)] def solve(): q = deque() q.append(n) dp[n] = 0 while q: x = q.popleft() for i in (x * a, x * b, x + a, x - a, x + b, x - b, x + 1, x - 1): if 0 \u0026lt; i \u0026lt; 100001: if dp[i] == -1: dp[i] = dp[x] + 1 q.append(i) solve() print(dp[m]) 💾 느낀점 숨바꼭질과 비슷한 느낌. 수평으로 좌표이동을 한다고 생각하고 풀이하니 쉽게 풀렸다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12761-%EB%8F%8C%EB%8B%A4%EB%A6%AC-with-python/","summary":"📌 BOJ 12761 돌다리 💡 조건 돌의 번호는 0 부터 100,000 까지 존재하고 동규는 N번 돌 위에, 주미는 M번 돌 위에 위치하고 있다. 동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해 A, B 만큼의 힘을 가진 스카이 콩콩을 가져왔다. 현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 A나 B만큼 좌우로 점프할 수 있으며,\n순간적으로 힘을 모아 현 위치의 A배 나 B배의 위치로 이동을 할 수 있다.","title":"[BOJ] 12761 돌다리 with Python"},{"content":"\n📌 BOJ 10211 Maximum Subarray 💡 조건 크기 N인 정수형 배열 X가 있을 때, X의 부분 배열(X의 연속한 일부분) 중\n각 원소의 합이 가장 큰 부분 배열을 찾는 Maximum subarray problem(최대 부분배열 문제) N과 배열 X가 주어졌을 때, X의 maximum subarray의 합을 구하는 문제. 배열의 크기 N이 주어진다. (1 ≤ N ≤ 1,000) 배열 X의 내용을 나타내는 N개의 정수가 공백으로 구분되어 주어진다. 이때 주어지는 수는 절댓값이 1,000보다 작은 정수이다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 1 2 3 4 5 5 2 1 -2 3 -5 실행결과 15 4 ⌨️ 문제 풀이 i번째를 기준으로 i + 1번째 숫자부터 더했을 때, 최댓값을 구하여 res에 저장한다 res 출력 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) res = -int(1e9) for i in range(n): temp = arr[i] if res \u0026lt; temp: res = temp for j in range(i + 1, n): temp += arr[j] if temp \u0026gt; res: res = temp print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10211-maximum-subarray-with-python/","summary":"📌 BOJ 10211 Maximum Subarray 💡 조건 크기 N인 정수형 배열 X가 있을 때, X의 부분 배열(X의 연속한 일부분) 중\n각 원소의 합이 가장 큰 부분 배열을 찾는 Maximum subarray problem(최대 부분배열 문제) N과 배열 X가 주어졌을 때, X의 maximum subarray의 합을 구하는 문제. 배열의 크기 N이 주어진다. (1 ≤ N ≤ 1,000) 배열 X의 내용을 나타내는 N개의 정수가 공백으로 구분되어 주어진다. 이때 주어지는 수는 절댓값이 1,000보다 작은 정수이다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 1 2 3 4 5 5 2 1 -2 3 -5 실행결과 15 4 ⌨️ 문제 풀이 i번째를 기준으로 i + 1번째 숫자부터 더했을 때, 최댓값을 구하여 res에 저장한다 res 출력 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.","title":"[BOJ] 10211 Maximum Subarray with Python"},{"content":"\n📌 BOJ 11104 Fridge of Your Dreams 💡 조건 2진수를 읽어 10진수로 출력하는 문제 진수변환 유형의 문제 🔖 예제 및 실행결과 예제 5 000000000000000000000001 000000000001010101010101 000000000000000000001010 101011001010101100101101 111111111111111111111111 실행결과 1 5461 10 11316013 16777215 ⌨️ 문제 풀이 int() 함수를 사용해 2진수를 10진수로 출력해준다. int(문자열, 진수) 로 사용하면 된다 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): print(int(stdin.readline().rstrip(), 2)) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11104-fridge-of-your-dreams-with-python/","summary":"\n📌 BOJ 11104 Fridge of Your Dreams 💡 조건 2진수를 읽어 10진수로 출력하는 문제 진수변환 유형의 문제 🔖 예제 및 실행결과 예제 5 000000000000000000000001 000000000001010101010101 000000000000000000001010 101011001010101100101101 111111111111111111111111 실행결과 1 5461 10 11316013 16777215 ⌨️ 문제 풀이 int() 함수를 사용해 2진수를 10진수로 출력해준다. int(문자열, 진수) 로 사용하면 된다 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): print(int(stdin.readline().rstrip(), 2)) 💾 느낀점 ","title":"[BOJ] 11104 Fridge of Your Dreams with Python"},{"content":"\n📌 BOJ 8911 거북이 💡 조건 2차원 평면 위에서 움직일 수 있는 거북이 로봇을 하나 가지고 있다. 거북이 로봇에게 내릴 수 있는 명령은 다음과 같이 네가지가 있다.\nF: 한 눈금 앞으로\nB: 한 눈금 뒤로\nL: 왼쪽으로 90도 회전\nR: 오른쪽으로 90도 회전 L과 R명령을 내렸을 때, 로봇은 이동하지 않고, 방향만 바꾼다.\n거북이는 항상 x축과 y축에 평행한 방향으로만 이동한다. 거북이가 지나간 영역을 모두 포함할 수 있는 가장 작은 직사각형의 넓이를 구하는 문제.\n단, 직사각형의 모든 변은 x축이나 y축에 평행이어야 한다. 거북이는 가장 처음에 (0, 0)에 있고, 북쪽을 쳐다보고 있다. 이 경우에 거북이가 지나간 영역을 모두 포함하는 직사각형은 선분이고, 선분은 한 변이 0인 직사각형으로 생각할 수 있다.\n따라서, 선분의 경우에 넓이는 0이 된다. 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 FFLF FFRRFF FFFBBBRFFFBBB 실행결과 2 0 9 ⌨️ 문제 풀이 문제에서 요구하는대로 구현을 하면 되는 문제입니다. 방향값을 +1 해줄 때 4로 나눈 나머지를 구하면 더욱 편합니다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): x, y, direction = 0, 0, 0 visited = set() for command in list(stdin.readline().rstrip()): if command == \u0026#39;F\u0026#39;: if direction == 0: y += 1 elif direction == 1: x += 1 elif direction == 2: y -= 1 else: x -= 1 elif command == \u0026#39;B\u0026#39;: if direction == 0: y -= 1 elif direction == 1: x -= 1 elif direction == 2: y += 1 else: x += 1 elif command == \u0026#39;L\u0026#39;: if direction == 0: direction = 3 else: direction -= 1 elif command == \u0026#39;R\u0026#39;: direction += 1 direction %= 4 visited.add((x, y)) max_x, min_x = 0, 0 max_y, min_y = 0, 0 for x, y in visited: max_x, max_y = max(max_x, x), max(max_y, y) min_x, min_y = min(min_x, x), min(min_y, y) height = abs(max_y) + abs(min_y) width = abs(max_x) + abs(min_x) print(height * width) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-8911-%EA%B1%B0%EB%B6%81%EC%9D%B4-with-python/","summary":"📌 BOJ 8911 거북이 💡 조건 2차원 평면 위에서 움직일 수 있는 거북이 로봇을 하나 가지고 있다. 거북이 로봇에게 내릴 수 있는 명령은 다음과 같이 네가지가 있다.\nF: 한 눈금 앞으로\nB: 한 눈금 뒤로\nL: 왼쪽으로 90도 회전\nR: 오른쪽으로 90도 회전 L과 R명령을 내렸을 때, 로봇은 이동하지 않고, 방향만 바꾼다.\n거북이는 항상 x축과 y축에 평행한 방향으로만 이동한다. 거북이가 지나간 영역을 모두 포함할 수 있는 가장 작은 직사각형의 넓이를 구하는 문제.","title":"[BOJ] 8911 거북이 with Python"},{"content":"\n📌 BOJ 8974 희주의 수학시험 💡 조건 연습문제 중에 하나가 정수를 적어나가는 것이였는데 수열은 1이 한 개, 2가 두 개, 3이 세 개.. 와 같이 만들어진다. 이제 강민이는 희주에게 두 개의 정수 A, B를 부를텐데, 그럼 희주는 주어진 수열에서 A번째와 B번째 사이에 있는 모든 수들의 합을 말해야한다. 희주에게 문제를 내기 위해 정답을 계산하는 문제 사칙연산, 구현 유형의 문제 🔖 예제 및 실행결과 예제 3 7 실행결과 15 ⌨️ 문제 풀이 반복문을 50회 순회하면서, 각 숫자에 해당하는만큼 리스트에 숫자를 append()한다. 구하고자 하는 범위의 숫자를 순회(i)하면서 arr[i-1] 값을 res에 더해준 뒤, 출력한다. 🖥 소스 코드 from sys import stdin arr, res = [], 0 a, b = map(int, stdin.readline().split()) for i in range(1, 50): cnt = 0 while cnt != i: arr.append(i) cnt += 1 for i in range(a, b + 1): res += arr[i-1] print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-8974-%ED%9D%AC%EC%A3%BC%EC%9D%98-%EC%88%98%ED%95%99%EC%8B%9C%ED%97%98-with-python/","summary":"📌 BOJ 8974 희주의 수학시험 💡 조건 연습문제 중에 하나가 정수를 적어나가는 것이였는데 수열은 1이 한 개, 2가 두 개, 3이 세 개.. 와 같이 만들어진다. 이제 강민이는 희주에게 두 개의 정수 A, B를 부를텐데, 그럼 희주는 주어진 수열에서 A번째와 B번째 사이에 있는 모든 수들의 합을 말해야한다. 희주에게 문제를 내기 위해 정답을 계산하는 문제 사칙연산, 구현 유형의 문제 🔖 예제 및 실행결과 예제 3 7 실행결과 15 ⌨️ 문제 풀이 반복문을 50회 순회하면서, 각 숫자에 해당하는만큼 리스트에 숫자를 append()한다.","title":"[BOJ] 8974 희주의 수학시험 with Python"},{"content":"\n📌 BOJ 2631 줄세우기 💡 조건 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌어 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다. 아이들의 수 N은 2 이상 200 이하의 정수이다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 7 3 7 5 2 6 1 4 실행결과 4 ⌨️ 문제 풀이 가장 긴 증가하는 부분 수열 알고리즘으로 해결 할 수 있는 문제입니다. 입력받은 아이들의 순서를 유지하고 숫자를 뽑았을 때, 증가하는 수열인데 가장 긴 길이를 구하는 알고리즘입니다. N만큼 순회하면서 i번째 아이를 이전의 아이의 번호를 i-1번째 아이의 숫자와 비교해\ndp[i] 번째 아이의 번호와 dp[j]+1 의 숫자 중 큰걸 dp[i]에 dp 리스트를 갱신합니다. dp 리스트에서 가장 큰 값을 찾아 답을 출력할 변수 lis와 max() 함수로 크기를 비교한 후 저장합니다. answer 변수에 n명의 아이 - lis 값을 저장하고 출력합니다. n명의 아이 중, 이동하는 아이의 수는 lis 입니다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) num = [int(stdin.readline()) for _ in range(n)] dp = [0 for _ in range(n)] for i in range(n): dp[i] = 1 for j in range(i): if num[i] \u0026gt; num[j]: dp[i] = max(dp[i], dp[j] + 1) lis = 0 lis = max(lis, max(dp)) answer = n - lis print(answer) 💾 느낀점 다이나믹프로그래밍은 진짜 극혐이다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2631-%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0-with-python/","summary":"📌 BOJ 2631 줄세우기 💡 조건 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌어 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다. 아이들의 수 N은 2 이상 200 이하의 정수이다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 7 3 7 5 2 6 1 4 실행결과 4 ⌨️ 문제 풀이 가장 긴 증가하는 부분 수열 알고리즘으로 해결 할 수 있는 문제입니다.","title":"[BOJ] 2631 줄세우기 with Python"},{"content":"\n📌 BOJ 2636 치즈 💡 조건 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 그 위에 얇은 치즈가 놓여 있다. 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다.\n치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다. 입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때,\n공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 문제 세로와 가로의 길이는 최대 100이다. 치즈가 없는 칸은 0, 치즈가 있는 칸은 1로 주어지며 각 숫자 사이에는 빈칸이 하나씩 있다. 너비우선탐색, BFS 유형의 문제 🔖 예제 및 실행결과 예제 13 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 0 1 1 0 0 0 0 1 1 1 1 0 0 1 1 0 0 0 0 0 1 1 0 0 0 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 실행결과 3 5 ⌨️ 문제 풀이 BFS 알고리즘을 사용하여 좌표 이동을 하며 빈공간과 치즈를 입력받은 board 에서 치즈를 찾아 표시를 한 뒤, 녹았다고 처리하는 것이 목표입니다.\n치즈가 모두 녹을 때까지 BFS 알고리즘을 호출해야하기에 while 로 호출해주면서 호출한 횟수를 ans에 저장해줍니다. 이 문제는 치즈 위를 걷는 느낌이 아닌, 빈 공간을 걸으면서 치즈가 있는 곳을 표시하여 처리하는 문제입니다. (2)번과 같이 처리하지 않으면 치즈의 겉만 체크해줄 수 없습니다. 체크된 치즈를 녹이는 함수인 melt() 를 정의하여 호출했습니다. melt() 함수를 호출하고 반환받은 값은 치즈가 녹은 개수입니다.\n모두 녹기 한시간 전에 치즈가 녹은 개수를 출력해야하니, 반환된 값을 cnt 라는 변수에 저장해줍니다. 녹지 않았다면 그대로 ans, cnt 를 출력해줍니다. 🖥 소스 코드 from collections import deque from sys import stdin n, m = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] ans = 0 cnt = 0 def melt(): cnt = 0 for i in range(n): for j in range(m): if board[i][j] == -1: cnt += 1 board[i][j] = 0 return cnt def bfs(): global ans, cnt q = deque() q.append((0, 0)) visited = set() visited.add((0, 0)) while q: x, y = q.popleft() for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: if (nx, ny) not in visited: if board[nx][ny] == 0: q.append((nx, ny)) visited.add((nx, ny)) elif board[nx][ny] == 1: board[nx][ny] = -1 melt_cnt = melt() if melt_cnt != 0: cnt = melt_cnt else: print(ans) print(cnt) exit() while 1: bfs() ans += 1 💾 느낀점 빈공간을 걸으며 치즈의 벽면을 훑는다는 느낌을 얻기 어려웠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2636-%EC%B9%98%EC%A6%88-with-python/","summary":"📌 BOJ 2636 치즈 💡 조건 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 그 위에 얇은 치즈가 놓여 있다. 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다.\n치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어가게 된다. 입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때,\n공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈조각이 놓여 있는 칸의 개수를 구하는 문제 세로와 가로의 길이는 최대 100이다.","title":"[BOJ] 2636 치즈 with Python"},{"content":"\n📌 BOJ 5671 호텔 방 번호 💡 조건 선영이는 투숙객에게 불운이 찾아오는 것을 피하기 위해서 반복되는 숫자가 없게 방 번호를 만들려고 한다. 정부는 선영이의 호텔 방 번호는 N보다 크거나 같고, M보다 작거나 같아야 한다는 조건을 걸고 신축 허가를 내주었다. 선영이의 새 호텔에는 방이 최대 몇 개 있을 수 있을까?\n두 방이 같은 방 번호를 사용할 수 없다 입력은 여러 개의 테스트 케이스로 이루어져 있고, 한 줄이다.\n각 줄에는 문제의 설명에 나와있는 N과 M이 주어진다. (1 ≤ N ≤ M ≤ 5000) 각각의 테스트 케이스에 대해서 N보다 크거나 같고, M보다 작거나 같은 수 중에서 반복되는 숫자가 없는 것의 개수를 출력한다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 87 104 989 1022 22 25 1234 1234 실행결과 14 0 3 1 ⌨️ 문제 풀이 여러개의 테스트 케이스가 있다고 했으니, while로 반복을 하도록 하자.\n입력받은 테스트케이스가 만약 비어있다면, break로 반목문을 중단해주면 된다. n 부터 m까지 순회하면서, 각 숫자를 str() 로 변환한 후, set()으로 감싸주면 중복제거가 된다. (2)번의 결과와 순회하고 있는 숫자의 길이를 비교해 같을 경우에만 res + 1을 해준다. 순회가 끝이 났다면 res를 출력해준다. 🖥 소스 코드 from sys import stdin while 1: data = stdin.readline().rstrip() if not data: break res = 0 a, b = data.split() for i in range(int(a), int(b) + 1): if len(set(str(i))) == len(str(i)): res += 1 print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-5671-%ED%98%B8%ED%85%94-%EB%B0%A9-%EB%B2%88%ED%98%B8-with-python/","summary":"📌 BOJ 5671 호텔 방 번호 💡 조건 선영이는 투숙객에게 불운이 찾아오는 것을 피하기 위해서 반복되는 숫자가 없게 방 번호를 만들려고 한다. 정부는 선영이의 호텔 방 번호는 N보다 크거나 같고, M보다 작거나 같아야 한다는 조건을 걸고 신축 허가를 내주었다. 선영이의 새 호텔에는 방이 최대 몇 개 있을 수 있을까?\n두 방이 같은 방 번호를 사용할 수 없다 입력은 여러 개의 테스트 케이스로 이루어져 있고, 한 줄이다.\n각 줄에는 문제의 설명에 나와있는 N과 M이 주어진다.","title":"[BOJ] 5671 호텔 방 번호 with Python"},{"content":"\n📌 BOJ 1758 알바생 강호 💡 조건 손님들은 입구에 들어갈 때, 강호에게 팁을 준다. 손님들은 자기가 커피를 몇 번째 받는지에 따라 팁을 다른 액수로 강호에게 준다. 각 손님은 강호에게 원래 주려고 생각했던 돈 - (받은 등수 - 1) 만큼의 팁을 강호에게 준다. 만약, 위의 식으로 나온 값이 음수라면, 강호는 팁을 받을 수 없다. 사람의 수 N과, 각 사람이 주려고 생각하는 팁이 주어질 때, 손님의 순서를 적절히 바꿔 강호가 받을 수 잇는 팁의 최댓값을 구하는 문제 N은 100,000보다 작거나 같은 자연수이다. 팁은 100,000보다 작거나 같은 자연수이다. 정렬 유형의 문제 🔖 예제 및 실행결과 예제 4 3 3 3 3 실행결과 6 ⌨️ 문제 풀이 각 손님이 지불할 돈이 담긴 리스트를 입력받아 내림차순으로 정렬한다. 가장 돈을 많이 낼 손님이 첫번째 등수가 되어야 최댓값을 구할 수 있다. 계산식을 사용해 각 손님에게 받을 수 있는 팁의 금액을 더해 출력한다. 🖥 소스 코드 from sys import stdin res, n = 0, int(stdin.readline()) arr = [] for i in range(n): arr.append(int(stdin.readline())) arr.sort(reverse=True) for i in range(1, n + 1): tips = arr[i-1] - (i - 1) if tips \u0026gt; 0: res += tips print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1758-%EC%95%8C%EB%B0%94%EC%83%9D-%EA%B0%95%ED%98%B8-with-python/","summary":"📌 BOJ 1758 알바생 강호 💡 조건 손님들은 입구에 들어갈 때, 강호에게 팁을 준다. 손님들은 자기가 커피를 몇 번째 받는지에 따라 팁을 다른 액수로 강호에게 준다. 각 손님은 강호에게 원래 주려고 생각했던 돈 - (받은 등수 - 1) 만큼의 팁을 강호에게 준다. 만약, 위의 식으로 나온 값이 음수라면, 강호는 팁을 받을 수 없다. 사람의 수 N과, 각 사람이 주려고 생각하는 팁이 주어질 때, 손님의 순서를 적절히 바꿔 강호가 받을 수 잇는 팁의 최댓값을 구하는 문제 N은 100,000보다 작거나 같은 자연수이다.","title":"[BOJ] 1758 알바생 강호 with Python"},{"content":"\n📌 BOJ 10166 관중석 💡 조건 반지름이 1인 원 위에는 좌석이 1개, 반지름이 2인 원 위에는 좌석이 2개, 이런 식으로 반지름이 D 인 원 위에는 좌석이 D 개가 있다. 무대에서 정확히 북쪽 방향에는 모든 원들에 좌석이 있으며, 하나의 원 위에 있는 좌석들은 동일한 간격을 두고 배치되어 있다. 공연에 반지름이 D1보다 같거나 크고, D2(D1 ≤ D2)보다 같거나 작은 원들에 배치된 좌석만을 활용하려고 한다. 좌석을 점으로 간주했을 때, 다른 좌석에 의해 무대 중심이 가려지는 좌석은 사용하지 않고, 그렇지 않은 좌석은 모두 사용한다. 숫자는 원의 반지름을 나타내고, ●은 공연에 사용되는 좌석, ⊗은 공연에 사용되지 않는 좌석을 나타낸다.\n원의 반지름 D1과 D2가 양의 정수로 주어진다. 단, 1 ≤ D1 ≤ D2 ≤ 2,000이다. 수학, 정수론 유형의 문제 🔖 예제 및 실행결과 예제 3 6 실행결과 12 ⌨️ 문제 풀이 D1부터 D2까지 순회하면서 자리 찾기 1번부터 i까지 좌석을 찾아서 최대공약수를 구하고 확인하고있는 자리들을 최대공약수 g로 나누어준다. 확인하려는 자리가 이미 어딘가에 가려져 있다면 pass, 아니면 ans += 1 🖥 소스 코드 from sys import stdin from math import gcd def solve(): a, b = map(int, stdin.readline().split()) arr = [[0] * b for _ in range(b)] ans = 0 for i in range(a, b + 1): for j in range(1, i + 1): g = gcd(i, j) x, y = i // g, j // g if not arr[x-1][y-1]: arr[x-1][y-1] = 1 ans += 1 print(ans) solve() 💾 느낀점 문제를 어떻게 풀어야할지 아예 감이 오질 않아서 문제의 해설을 보고 풀었습니다. 수학에 관련된 문제를 많이 어려워하는 것 같습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10166-%EA%B4%80%EC%A4%91%EC%84%9D-with-python/","summary":"📌 BOJ 10166 관중석 💡 조건 반지름이 1인 원 위에는 좌석이 1개, 반지름이 2인 원 위에는 좌석이 2개, 이런 식으로 반지름이 D 인 원 위에는 좌석이 D 개가 있다. 무대에서 정확히 북쪽 방향에는 모든 원들에 좌석이 있으며, 하나의 원 위에 있는 좌석들은 동일한 간격을 두고 배치되어 있다. 공연에 반지름이 D1보다 같거나 크고, D2(D1 ≤ D2)보다 같거나 작은 원들에 배치된 좌석만을 활용하려고 한다. 좌석을 점으로 간주했을 때, 다른 좌석에 의해 무대 중심이 가려지는 좌석은 사용하지 않고, 그렇지 않은 좌석은 모두 사용한다.","title":"[BOJ] 10166 관중석 with Python"},{"content":"\n📌 BOJ 11899 괄호 끼워넣기 💡 조건 올바르지 않은 괄호열이 주어질 때, 올바른 괄호열으로 만들기 위해 앞과 뒤에 붙여야 할 괄호의 최소 개수를 구하는 문제. S의 길이는 1 이상 50 이하이며 불가능한 경우는 주어지지 않는다. 괄호열이란 여는 괄호 ‘(’와 닫는 괄호 ‘)’로만 구성된 문자열을 말합니다. 올바른 괄호열은 아래와 같이 정의할 수 있다. \u0026ldquo;()\u0026ldquo;는 올바른 괄호열입니다. A가 올바른 괄호열이라면 \u0026ldquo;(A)\u0026rdquo; 역시 올바른 괄호열입니다. A와 B가 모두 올바른 괄호열이라면 \u0026ldquo;AB\u0026rdquo; 역시 올바른 괄호열입니다. 문자열, 스택, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 ))()(( 실행결과 4 ⌨️ 문제 풀이 문자열을 입력받아 solve() 함수를 거쳐 cnt에 저장된 값을 출력한다. solve() 는 문자열을 역순회하며 닫는 괄호의 수를 세며 temp 에 저장한다. 만약 순회하는 중, 닫는 괄호가 아닐 경우 또한 temp가 0일 경우, cnt + 1 만약 순회하는 중, 닫는 괄호가 아닐 경우 또한 temp가 0이 아닐 경우, temp - 1 순회가 끝난 후에 temp 가 0이 아니라면 cnt 에 temp를 더해준다. cnt 출력 🖥 소스 코드 from sys import stdin g = stdin.readline().rstrip() cnt = 0 def solve(s): global cnt temp = 0 for i in range(len(s) - 1, -1, -1): if s[i] == \u0026#39;)\u0026#39;: temp += 1 else: if temp - 1 \u0026lt; 0: cnt += 1 else: temp -= 1 if temp != 0: cnt += temp solve(g) print(cnt) 💾 느낀점 프로그래머스에서 괄호 변환 등의 문제를 풀면서 고생을 해서 그런지, 감각은 확실이 깨어 있는 듯하다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11899-%EA%B4%84%ED%98%B8-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-with-python/","summary":"📌 BOJ 11899 괄호 끼워넣기 💡 조건 올바르지 않은 괄호열이 주어질 때, 올바른 괄호열으로 만들기 위해 앞과 뒤에 붙여야 할 괄호의 최소 개수를 구하는 문제. S의 길이는 1 이상 50 이하이며 불가능한 경우는 주어지지 않는다. 괄호열이란 여는 괄호 ‘(’와 닫는 괄호 ‘)’로만 구성된 문자열을 말합니다. 올바른 괄호열은 아래와 같이 정의할 수 있다. \u0026ldquo;()\u0026ldquo;는 올바른 괄호열입니다. A가 올바른 괄호열이라면 \u0026ldquo;(A)\u0026rdquo; 역시 올바른 괄호열입니다. A와 B가 모두 올바른 괄호열이라면 \u0026ldquo;AB\u0026rdquo; 역시 올바른 괄호열입니다.","title":"[BOJ] 11899 괄호 끼워넣기 with Python"},{"content":"\n📌 BOJ 12788 제 2회 IUPC는 잘 개최될 수 있을까? 💡 조건 대회 개최를 위한 예산을 아끼기 위하여 펜을 구매하지 않고 CTP회원들에게 펜을 빌리기로 하였다. CTP에는 N명의 회원들이 존재하며 각각의 회원들의 필통에 들어있는 펜의 개수는 모두 다르다.\n정은이는 여러명의 회원에게 펜을 빌릴경우 펜을 돌려주기에 번거롭다고 생각하여 최소한의 회원들에게 펜을 빌려 참가자들에게 나누어 주려고 한다. 대회에 참가하는 참가자들은 팀을 구성해서 참가하는데 모든 팀원에게 펜을 지급해야한다. 한 팀이 k명의 팀원으로 구성되어 있을때 몇 명의 회원들에게 펜을 빌려야하는지 출력하는 문제. CTP의 회원수 N(1 ≤ N ≤ 1,000)\n대회에 참가한 팀의 수 M(1 ≤ M ≤ 1,000)\n팀을 구성하는데 필요한 팀원의 수 K(1 ≤ K ≤ 10)\n각각의 CTP 회원들이 가지고 있는 펜의 수 A(0 ≤ A ≤ 100) 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 7 36 3 9 70 15 13 19 20 11 실행결과 3 ⌨️ 문제 풀이 입력 받은 배열을 정렬한 뒤, n크기의 배열을 순회한다. 필요한 펜의 수(m * k)에서 arr[i] 를 뺀 결과가 만약 -1보다 크다면, cnt + 1, need_pens - arr[i] 0보다 작다면, cnt + 1, need_pens - arr[i] need_pensrk \u0026gt; 0 일 경우, STRESS를 출력하고 그 반대의 경우 cnt를 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) m, k = map(int, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) arr.sort(reverse=True) need_pens = m * k cnt = 0 for i in range(n): if need_pens == 0: break if need_pens - arr[i] \u0026gt; -1: cnt += 1 need_pens -= arr[i] elif need_pens - arr[i] \u0026lt; 0: cnt += 1 need_pens -= arr[i] break print(\u0026#34;STRESS\u0026#34;) if need_pens \u0026gt; 0 else print(cnt) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12788-%EC%A0%9C-2%ED%9A%8C-iupc%EB%8A%94-%EC%9E%98-%EA%B0%9C%EC%B5%9C%EB%90%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-with-python/","summary":"📌 BOJ 12788 제 2회 IUPC는 잘 개최될 수 있을까? 💡 조건 대회 개최를 위한 예산을 아끼기 위하여 펜을 구매하지 않고 CTP회원들에게 펜을 빌리기로 하였다. CTP에는 N명의 회원들이 존재하며 각각의 회원들의 필통에 들어있는 펜의 개수는 모두 다르다.\n정은이는 여러명의 회원에게 펜을 빌릴경우 펜을 돌려주기에 번거롭다고 생각하여 최소한의 회원들에게 펜을 빌려 참가자들에게 나누어 주려고 한다. 대회에 참가하는 참가자들은 팀을 구성해서 참가하는데 모든 팀원에게 펜을 지급해야한다. 한 팀이 k명의 팀원으로 구성되어 있을때 몇 명의 회원들에게 펜을 빌려야하는지 출력하는 문제.","title":"[BOJ] 12788 제 2회 IUPC는 잘 개최될 수 있을까? with Python"},{"content":"\n📌 BOJ 5698 Tautogram 💡 조건 Tautogram은 매우 특별한 형태의 두운법으로, 인접한 단어가 같은 글자로 시작하는 것을 말한다. 문장이 Tautogram이 되려면, 모든 단어가 같은 글자로 시작해야 한다. 선영이의 편지에 있는 문장이 주어졌을 때, Tautogram인지 아닌지 알아내는 프로그램을 작성하시오. 문장은 최대 50개의 단어로 이루어져 있으며, 공백으로 구분되어져 있다. 단어는 알파벳 대문자와 소문자로 이루어져 있고, 길이는 최대 20이다. 마지막 테스트 케이스의 다음 줄에는 \u0026lsquo;*\u0026lsquo;이 하나 주어진다.\n입력으로 주어진 문장이 Tautogram이라면 \u0026lsquo;Y\u0026rsquo;를, 아니라면 \u0026lsquo;N\u0026rsquo;을 출력한다. 문자열 유형의 문제 🔖 예제 및 실행결과 예제 Flowers Flourish from France Sam Simmonds speaks softly Peter pIckEd pePPers truly tautograms triumph this is NOT a tautogram * 실행결과 Y Y Y Y N ⌨️ 문제 풀이 검사할 문자열을 검사한다. 검사한 문자열이 * 이라면 반복문을 멈춘다. 문자열을 공백으로 나누어서 체크할 문자열을 뽑는다.\n모든 단어가 같은 문자열로 시작해야하기 때문에 맨 첫번째 단어의 첫번째 글자를 뽑아 소문자로 변경하여 chk에 저장한다. 각 단어를 순회하면서 단어의 첫글자를 chk 와 비교하여 다르면 단어 순회를 중단하고 tf를 False 로 갱신. tf 가 True 라면 \u0026lsquo;Y\u0026rsquo; tf 가 False 라면 \u0026lsquo;Y\u0026rsquo; 🖥 소스 코드 from sys import stdin while 1: data = stdin.readline().rstrip() if data == \u0026#39;*\u0026#39;: break words = data.split() chk = words[0][0].lower() tf = True for i in range(1, len(words)): if words[i][0].lower() != chk: tf = False break print(\u0026#39;Y\u0026#39;) if tf else print(\u0026#39;N\u0026#39;) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-5698-tautogram-with-python/","summary":"📌 BOJ 5698 Tautogram 💡 조건 Tautogram은 매우 특별한 형태의 두운법으로, 인접한 단어가 같은 글자로 시작하는 것을 말한다. 문장이 Tautogram이 되려면, 모든 단어가 같은 글자로 시작해야 한다. 선영이의 편지에 있는 문장이 주어졌을 때, Tautogram인지 아닌지 알아내는 프로그램을 작성하시오. 문장은 최대 50개의 단어로 이루어져 있으며, 공백으로 구분되어져 있다. 단어는 알파벳 대문자와 소문자로 이루어져 있고, 길이는 최대 20이다. 마지막 테스트 케이스의 다음 줄에는 \u0026lsquo;*\u0026lsquo;이 하나 주어진다.\n입력으로 주어진 문장이 Tautogram이라면 \u0026lsquo;Y\u0026rsquo;를, 아니라면 \u0026lsquo;N\u0026rsquo;을 출력한다.","title":"[BOJ] 5698 Tautogram with Python"},{"content":"\n📌 BOJ 2493 탑 💡 조건 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고,\n탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다.\n하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다. N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 문제. N은 1 이상 500,000 이하 탑들의 높이는 1 이상 100,000,000 이하의 정수 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 5 6 9 5 7 4 실행결과 0 0 2 2 4 ⌨️ 문제 풀이 n의 길이의 data를 차례대로 순회한다. stack이 빌 때까지 while 문을 통해서 반복하며 stack 맨 마지막 탑이 현재 검사하는 탑보다 값이 크면 현재 검사하는 탑은 스택 맨 마지막 탑이 신호를 받고 있다는 뜻.\nans[i] 의 값을 stack의 [-1][0] 에서 1을 더해 넣어주고 while 반복문을 정지. (3)번의 조건에 해당하지 않는다면 stack 맨 마지막 값을 뺀다. while 문이 끝나면 stack에 (i, data[i])를 넣어주고 다시 n 만큼 순회하는 반복문을 이어 진행한다. ans의 내용을 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) data = list(map(int, stdin.readline().split())) stack = [] ans = [0 for _ in range(n)] for i in range(n): while stack: if stack[-1][1] \u0026gt; data[i]: ans[i] = stack[-1][0] + 1 break else: stack.pop() stack.append((i, data[i])) print(*ans) 💾 느낀점 스택을 사용하여 푸는 문제라고 생각을 하지 못했다. 왜 스택을 하용하는지 디버깅 하기 전까지는 이해를 못했었다. 스택의 사용 방법이 더 많다는 것을 느꼈으며, 스택에 대한 문제를 한번 더 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2493-%ED%83%91-with-python/","summary":"📌 BOJ 2493 탑 💡 조건 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고,\n탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다.\n하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다. N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 문제.","title":"[BOJ] 2493 탑 with Python"},{"content":"\n📌 BOJ 3187 양치기 꿍 💡 조건 같은 울타리 영역 안의 양들의 숫자가 늑대의 숫자보다 더 많을 경우 늑대가 전부 잡아먹힌다. 물론 그 외의 경우는 양이 전부 잡아먹힌다. 만약 빈 공간을 \u0026lsquo;.\u0026rsquo;(점)으로 나타내고 울타리를 \u0026lsquo;#\u0026rsquo;, 늑대를 \u0026lsquo;v\u0026rsquo;, 양을 \u0026lsquo;k\u0026rsquo;라고 나타낸다면 몇마리의 양과 늑대가 남아있는가? 울타리로 막히지 않은 영역에는 양과 늑대가 없으며 양과 늑대는 대각선으로 이동할 수 없다. 영역의 세로와 가로의 길이를 나타내는 두 개의 정수 R, C (3 ≤ R, C ≤ 250) BFS 유형의 문제 🔖 예제 및 실행결과 예제 6 6 ...#.. .##v#. #v.#.# #.k#.# .###.# ...### 실행결과 0 2 ⌨️ 문제 풀이 양과 늑대와 울타리 정보를 입력받아 board에 저장한다. 맵을 순회하면서 울타리가 아니며, (i, j) 좌표가 방문하지 않은 좌표라면 bfs 함수를 호출한다. k일 때와 v일 때, .일 때 큐에 집어넣고, 방문처리를 해준다. k일 때는 sheep 변수에 1을 더하고, v일 때는 wolf 변수에 1을 더해준다. 만약 늑대의 수가 많다면 wolf, \u0026lsquo;w\u0026rsquo; 를 반환하고\n만약 양의 수가 만ㄷ나면 sheep, \u0026rsquo;s\u0026rsquo; 을 반환한다. 반환받은 결과에 따라서 양과 늑대의 수를 ans에 각각 저장한다.\nans는 앞부터 양과 늑대의 수다. 🖥 소스 코드 from collections import deque from sys import stdin board = [] n, m = map(int, stdin.readline().split()) for i in range(n): board.append(list(stdin.readline().rstrip())) dx, dy = [1, -1, 0, 0], [0, 0, 1, -1] visited = set() def bfs(x, y): wolf, sheep = 0, 0 if board[x][y] == \u0026#39;k\u0026#39;: sheep += 1 elif board[x][y] == \u0026#39;v\u0026#39;: wolf += 1 q = deque() q.append((x, y)) visited.add((x, y)) while q: x, y = q.popleft() for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: if (nx, ny) not in visited: if board[nx][ny] == \u0026#39;k\u0026#39;: sheep += 1 q.append((nx, ny)) visited.add((nx, ny)) elif board[nx][ny] == \u0026#39;v\u0026#39;: wolf += 1 q.append((nx, ny)) visited.add((nx, ny)) elif board[nx][ny] == \u0026#39;.\u0026#39;: q.append((nx, ny)) visited.add((nx, ny)) if wolf \u0026gt;= sheep: return wolf, \u0026#39;w\u0026#39; else: return sheep, \u0026#39;s\u0026#39; ans = [0, 0] for i in range(n): for j in range(m): if board[i][j] != \u0026#39;#\u0026#39; and (i, j) not in visited: res, win = bfs(i, j) if win == \u0026#39;s\u0026#39;: ans[0] += res else: ans[1] += res print(*ans) 💾 느낀점 BSF를 사용하는 문제였습니다. 이와 같은 유형이 은근히 많아 연습하기 좋은 문제라고 생각합니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-3187-%EC%96%91%EC%B9%98%EA%B8%B0-%EA%BF%8D-with-python/","summary":"📌 BOJ 3187 양치기 꿍 💡 조건 같은 울타리 영역 안의 양들의 숫자가 늑대의 숫자보다 더 많을 경우 늑대가 전부 잡아먹힌다. 물론 그 외의 경우는 양이 전부 잡아먹힌다. 만약 빈 공간을 \u0026lsquo;.\u0026rsquo;(점)으로 나타내고 울타리를 \u0026lsquo;#\u0026rsquo;, 늑대를 \u0026lsquo;v\u0026rsquo;, 양을 \u0026lsquo;k\u0026rsquo;라고 나타낸다면 몇마리의 양과 늑대가 남아있는가? 울타리로 막히지 않은 영역에는 양과 늑대가 없으며 양과 늑대는 대각선으로 이동할 수 없다. 영역의 세로와 가로의 길이를 나타내는 두 개의 정수 R, C (3 ≤ R, C ≤ 250) BFS 유형의 문제 🔖 예제 및 실행결과 예제 6 6 .","title":"[BOJ] 3187 양치기 꿍 with Python"},{"content":"\n📌 BOJ 1531 투명 💡 조건 세준이는 1×1크기의 그림으로 모자이크한 100×100크기의 그림을 가지고 있다. 어느 날 이 모자이크 중 일부 그림이 너무 보기 싫어서 N개의 불투명한 종이로 그림을 가리기 시작했다. 그림의 현재 부분 위에 M개 이하의 종이가 올려져 있으면 그림은 그 부분에서 보이게 된다. N은 0보다 크거나 같고, 50보다 작거나 같다. M은 0보다 크거나 같고, 50보다 작거나 같다. 왼쪽 아래 모서리의 x, y좌표, 오른쪽 위 모서리의 x, y좌표 순으로 주어진다.\n모든 좌표는 100보다 작거나 같은 자연수이다. 시뮬레이션, 구현 🔖 예제 및 실행결과 예제 3 1 21 21 80 80 41 41 60 60 71 71 90 90 실행결과 500 ⌨️ 문제 풀이 N개의 불투명한 종이의 좌표를 받아서 x1부터 x2까지, y1부터 y2까지 순회한다. 순회하면서 해당하는 인덱스에 해당하는 배열의 값이 False라면 1로 변경한다. 순회하면서 해당하는 인덱스에 해당하는 배열의 값이 False가 아니라면 + 1 해준다. 100 * 100 크기의 좌표를 순회하면서 m 이상의 크기가 있다면 res + 1 해준다. 🖥 소스 코드 from sys import stdin board = [[False] * 101 for _ in range(101)] n, m = map(int, stdin.readline().split()) for _ in range(n): x1, y1, x2, y2 = map(int, stdin.readline().split()) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): if board[i][j] is False: board[i][j] = 1 else: board[i][j] += 1 res = 0 for i in range(1, 101): for j in range(1, 101): if board[i][j] \u0026gt; m: res += 1 print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1531-%ED%88%AC%EB%AA%85-with-python/","summary":"📌 BOJ 1531 투명 💡 조건 세준이는 1×1크기의 그림으로 모자이크한 100×100크기의 그림을 가지고 있다. 어느 날 이 모자이크 중 일부 그림이 너무 보기 싫어서 N개의 불투명한 종이로 그림을 가리기 시작했다. 그림의 현재 부분 위에 M개 이하의 종이가 올려져 있으면 그림은 그 부분에서 보이게 된다. N은 0보다 크거나 같고, 50보다 작거나 같다. M은 0보다 크거나 같고, 50보다 작거나 같다. 왼쪽 아래 모서리의 x, y좌표, 오른쪽 위 모서리의 x, y좌표 순으로 주어진다.","title":"[BOJ] 1531 투명 with Python"},{"content":"\n📌 BOJ 2096 내려가기 💡 조건 N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다.\n내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다. 먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다.\n그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다.\n바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 최대 점수, 최소 점수를 구하는 프로그램을 작성하는 문제 첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.\n첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 3 1 2 3 4 5 6 4 9 0 실행결과 18 6 ⌨️ 문제 풀이 입력받은 n만큼 순회한다. 아래층으로 내려가면서 합칠 때 가장 큰 값과 작은 값을 x_temp, n_temp에 저장한다. dp에 x_temp, n_temp 내용을 저장한다. 최댓갑과 최댓값을 따로 저장할 배열을 만들고, 위치에 따라 선택할 수 있는 값을 달리하여 최댓값과 최솟값을 구하는 것이 목적이다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) x_dp = [0] * 3 n_dp = [0] * 3 x_temp = [0] * 3 n_temp = [0] * 3 for i in range(n): a, b, c = map(int, stdin.readline().split()) for j in range(3): if j == 0: x_temp[j] = a + max(x_dp[j], x_dp[j + 1]) n_temp[j] = a + min(n_dp[j], n_dp[j + 1]) elif j == 1: x_temp[j] = b + max(x_dp[j - 1], x_dp[j], x_dp[j + 1]) n_temp[j] = b + min(n_dp[j - 1], n_dp[j], n_dp[j + 1]) elif j == 2: x_temp[j] = c + max(x_dp[j], x_dp[j - 1]) n_temp[j] = c + min(n_dp[j], n_dp[j - 1]) for j in range(3): x_dp[j] = x_temp[j] n_dp[j] = n_temp[j] print(max(x_dp), min(n_dp)) 💾 느낀점 다이나믹프로그래밍 문제는 역시 점화식 때문에 골치를 많이 썩어하는 것 같다. 생각보다 문제풀이를 보고 어렵지 않았던 문제인데 왜 헤맸을까 하는 생각을 했다. 이러한 유형을 다시 풀었을 때, 잘 풀 수 있게 풀이를 써야겠다는 생각을 했다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2096-%EB%82%B4%EB%A0%A4%EA%B0%80%EA%B8%B0-with-python/","summary":"📌 BOJ 2096 내려가기 💡 조건 N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다.\n내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다. 먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다.\n그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다.\n바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다.","title":"[BOJ] 2096 내려가기 with Python"},{"content":"\n📌 BOJ 1269 대칭 차집합 💡 조건 자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다. 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,\nA-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로,\n대칭 차집합의 원소의 개수는 1 + 3 = 4개이다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다. 대칭 차집합의 원소의 개수를 출력하는 문제 해시맵, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 3 5 1 2 4 2 3 4 5 6 실행결과 4 ⌨️ 문제 풀이 집합 A의 원소의 개수와 집합 B의 원소의 개수를 입력 받는다. 각 집합의 원소를 set()으로 입력받아 저장한다. (a - b) 의 길이와 (b - a)의 길이를 더한 뒤 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) a = set(map(int, stdin.readline().split())) b = set(map(int, stdin.readline().split())) print(len(a - b) + len(b - a)) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1269-%EB%8C%80%EC%B9%AD-%EC%B0%A8%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 1269 대칭 차집합 💡 조건 자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다. 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,\nA-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로,\n대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.","title":"[BOJ] 1269 대칭 차집합 with Python"},{"content":"\n📌 BOJ 12760 최후의 승자는 누구? 💡 조건 최종 플레이어 N명이 남아있다. 각 플레이어는 M장씩의 숫자가 적힌 카드를 가지고 있으며,\n이들은 매 턴 자신이 가진 카드 중 가장 큰 카드를 두고 비교를 하는데, 그 카드들 중 가장 큰 수를 가진 플레이어가 1점을 획득한다. 그 턴에 사용된 카드는 버리기로 한다. (가장 큰 수를 가진 플레이어는 여러 명일 수 있다.) 3. M번의 경기 후 가장 많은 점수를 획득한 플레이어는 몇 번 플레이어인지 구하는 문제.\n2 \u0026lt;= N \u0026lt;= 100, 1 \u0026lt;= M \u0026lt;= 100\n1 \u0026lt;= 카드에 적힌 숫자 \u0026lt;= 100 가장 많은 점수를 획득한 플레이어가 여러 명일 경우, 빈칸을 사이에 두고 플레이어들의 번호를 오름차순으로 출력한다. 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 3 5 4 3 3 4 5 3 5 4 4 5 3 3 4 4 실행결과 1 2 3 4 ⌨️ 문제 풀이 d 변수는 dictionary 이며, 각 플레이어의 점수를 저장할 변수이다. N 명의 플레이어가 각자 들고 있는 카드의 숫자들이 입력될 때, 그 숫자들을 내림차순으로 정렬하여 players에 넣어준다. 각 플레이어의 카드를 순회하면서 가장 큰 카드 값을 저장한다. 각 플레이어의 카드를 순회하면서 mx[j] 가 i 번 플레이어의[j]번째 카드와 값이 같다면, d[i + 1] 에 + 1을 해준다. d 에 저장된 값 중, 가장 큰 값을 골라낸 뒤, mx_cnt 에 저장한다. d를 순회하면서 mx_cnt 와 같은 값을 가진 키를 res에 저장해준다.\nres를 출력할 땐, 오름차순 정렬을 한 번 수행해준 뒤 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) d = {x: 0 for x in range(1, n + 1)} players = [] for i in range(n): cards = list(map(int, stdin.readline().split())) cards.sort() players.append(list(reversed(cards))) mx = [0 for _ in range(m)] for i in range(n): for j in range(m): mx[j] = max(mx[j], players[i][j]) for i in range(n): for j in range(m): if mx[j] == players[i][j]: d[i + 1] += 1 mx_cnt = max(d.values()) res = [] for key, item in d.items(): if item == mx_cnt: res.append(key) res.sort() print(*res) 💾 느낀점 간단하게 풀 수 있었던 정렬 문제였습니다. 카드의 숫자를 큰 순서대로 보아야하는 것을 떠올리지 못해 조금 헤맸습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12760-%EC%B5%9C%ED%9B%84%EC%9D%98-%EC%8A%B9%EC%9E%90%EB%8A%94-%EB%88%84%EA%B5%AC-with-python/","summary":"📌 BOJ 12760 최후의 승자는 누구? 💡 조건 최종 플레이어 N명이 남아있다. 각 플레이어는 M장씩의 숫자가 적힌 카드를 가지고 있으며,\n이들은 매 턴 자신이 가진 카드 중 가장 큰 카드를 두고 비교를 하는데, 그 카드들 중 가장 큰 수를 가진 플레이어가 1점을 획득한다. 그 턴에 사용된 카드는 버리기로 한다. (가장 큰 수를 가진 플레이어는 여러 명일 수 있다.) 3. M번의 경기 후 가장 많은 점수를 획득한 플레이어는 몇 번 플레이어인지 구하는 문제.","title":"[BOJ] 12760 최후의 승자는 누구? with Python"},{"content":"\n📌 BOJ 10163 색종이 💡 조건 평면에 색깔이 서로 다른 직사각형 모양의 색종이 N장이 하나씩 차례로 놓여진다. 이때 색종이가 비스듬하게 놓이는 경우는 없다. 색종이의 장수를 나타내는 정수 N (1 ≤ N ≤ 100) N장의 색종이가 주어진 위치에 차례로 놓일 경우, 각 색종이가 보이는 부분의 면적을 구하는 문제 가로 최대 1001칸, 세로 최대 1001칸으로 구성된 격자 모양이다.\n격자의 각 칸은 가로, 세로 길이가 1인 면적이 1인 정사각형 색종이가 놓인 상태는 가장 왼쪽 아래 칸의 번호와 너비, 높이를 나타내는 네 정수로 표현한다.\n예를 들어, 위 그림에서 회색으로 표시된 색종이는 (1,4)가 가장 왼쪽 아래에 있고 너비 3, 높이 2이므로 1 4 3 2로 표현한다.\n색종이가 격자 경계 밖으로 나가는 경우는 없다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 4 0 2 10 10 7 9 8 4 8 4 10 6 6 0 12 10 실행결과 62 24 0 120 ⌨️ 문제 풀이 색종이의 정보를 입력받아서 가장 왼쪽 아래칸에서부터 놓는다. (1)번의 작업을 반복문을 통해서 board 에 채워넣는데, 이때 k의 값은 색종이의 번호를 뜻한다. 색종이가 놓인 부분에서 가장 작은 좌표의 값과 가장 큰 좌표의 값을 계산하여 변수를 갱신한다. 모든 입력을 받았다면, k를 순회하면서 각 색종이의 면적을 구해준다. 각 번호에 알맞은 색종이의 면적은 res 변수에 k 번째에 더해지고, res를 순회하면서 출력하면 된다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) board = [[-1] * 1001 for _ in range(1001)] res = [0 for _ in range(n)] minx, miny = 1001, 1001 maxx, maxy = 0, 0 for k in range(n): x, y, width, height = map(int, stdin.readline().split()) for i in range(x, x + width): for j in range(y, y + height): board[i][j] = k minx, miny = min(x, minx), min(y, miny) maxx, maxy = max(x + width, maxx), max(y + height, maxy) for k in range(n): for i in range(minx, maxx): for j in range(miny, maxy): if board[i][j] == k: res[k] += 1 for i in res: print(i) 💾 느낀점 pypy로 제출하여 풀었던 문제이다. 서브태스크가 있는 문제라서 문제를 풀이할 때, 몇 번 틀리기도 했다. 이 때, 구현이 참 힘들고 어려웠었는데, 성장했음을 느꼈다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10163-%EC%83%89%EC%A2%85%EC%9D%B4-with-python/","summary":"📌 BOJ 10163 색종이 💡 조건 평면에 색깔이 서로 다른 직사각형 모양의 색종이 N장이 하나씩 차례로 놓여진다. 이때 색종이가 비스듬하게 놓이는 경우는 없다. 색종이의 장수를 나타내는 정수 N (1 ≤ N ≤ 100) N장의 색종이가 주어진 위치에 차례로 놓일 경우, 각 색종이가 보이는 부분의 면적을 구하는 문제 가로 최대 1001칸, 세로 최대 1001칸으로 구성된 격자 모양이다.\n격자의 각 칸은 가로, 세로 길이가 1인 면적이 1인 정사각형 색종이가 놓인 상태는 가장 왼쪽 아래 칸의 번호와 너비, 높이를 나타내는 네 정수로 표현한다.","title":"[BOJ] 10163 색종이 with Python"},{"content":"\n📌 BOJ 12018 Yonsei TOTO 💡 조건 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다.\n그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다.\n(내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다. 과목 수 n (1 ≤ n ≤ 100)\n마일리지 m (1 ≤ m ≤ 100)\n각 과목마다 2줄의 입력이 주어지는데 첫째 줄에는 각 과목에 신청한 사람 수 Pi과 과목의 수강인원 Li\n그 다음 줄에는 각 사람이 마일리지를 얼마나 넣었는지 주어진다. 정렬 유형의 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) res = 0 c = [] for i in range(n): p, l = map(int, stdin.readline().split()) point = list(map(int, stdin.readline().split())) point.sort(reverse=True) if p \u0026lt; l: c.append(1) else: mile = point[l - 1] c.append(mile) c.sort() for class_m in c: if m - class_m \u0026gt;= 0: res += 1 m -= class_m print(res) 🔖 예제 및 실행결과 예제 5 76 5 4 36 25 1 36 36 4 4 30 24 25 20 6 4 36 36 36 36 36 36 2 4 3 7 5 4 27 15 26 8 14 실행결과 4 ⌨️ 문제 풀이 과목에 신청한 인원 수보다 수강 인원이 높다면, 마일리지를 크게 투자하지 않아도 된다.\n반대로 신청한 인원 수가 수강 인원보다 높다면, 성준이가 우선순위를 가지기 때문에\n(수강인원) 번째 신청한 사람만큼만 신청하면 수강할 수 있다.\n신청한 마일리지는 내림차순으로 정렬해서 계산한다. if p \u0026lt; l: c.append(1) else: mile = point[l - 1] c.append(mile) c를 정렬하고 성준이가 가지고 있는 마일리지에서 신청할 때 필요한 마일리지를 빼주며, 음수가 되지 않으면 res 에 1을 추가한다 💾 느낀점 그리디가 묻은 정렬을 이용한 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12018-yonsei-toto-with-python/","summary":"📌 BOJ 12018 Yonsei TOTO 💡 조건 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다.\n그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다.\n(내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다. 과목 수 n (1 ≤ n ≤ 100)\n마일리지 m (1 ≤ m ≤ 100)","title":"[BOJ] 12018 Yonsei TOTO with Python"},{"content":"\n📌 BOJ 4811 알약 💡 조건 70세 박종수 할아버지는 매일 매일 약 반알을 먹는다.\n손녀 선영이는 종수 할아버지에게 약이 N개 담긴 병을 선물로 주었다. 다음 날부터 종수는 병에서 약을 하나 꺼낸다.\n(약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고,\n아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다. 종수는 손녀에게 한 조각을 꺼낸 날에는 W를, 반 조각을 꺼낸 날에는 H 보낸다. 손녀는 할아버지에게 받은 문자를 종이에 기록해 놓는다. 총 2N일이 지나면 길이가 2N인 문자열이 만들어지게 된다. 이때, 가능한 서로 다른 문자열의 개수는 총 몇 개일까? 입력은 최대 1000개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스는 한 줄이며, 병에 들어있는 약의 개수 N ≤ 30 가 주어진다.\n입력의 마지막 줄에는 0이 하나 주어진다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 6 1 4 2 3 30 0 실행결과 132 1 14 2 5 3814986502092304 ⌨️ 문제 풀이 알약을 먹지 않으면 절대로 반개짜리는 존재할 수도 없다. 온전한 알약을 먹으면 반쪽짜리 알약이 생긴다.\n이 경우, 반쪽짜리 알약을 먹을 수 있는 경우의 수가 하나 더 늘어난다. h/w 0 1 2 3 4\n0 0 1 1 1 1\n1 1 2 3 4\n2 2 5 9\n3 5 14\n4 14 🖥 소스 코드 from sys import stdin arr = [[0] * 31 for _ in range(31)] arr[0][1] = 1 for i in range(31): for j in range(i, 31): if i == 0: arr[i][j] = 1 else: if i == j: arr[i][j] = arr[i-1][j] else: arr[i][j] = arr[i-1][j] + arr[i][j-1] while 1: n = int(stdin.readline()) if n == 0: break print(arr[n][n]) 💾 느낀점 다이나믹프로그래밍을 너무 못한다. 문제를 이해하고, 이해한 내용을 바탕으로 풀이를 유도하는 것이 아예 되지를 않는다. DP 문제같다고 생각이 되면 천천히 그려가면서 생각을 해보자. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-4811-%EC%95%8C%EC%95%BD-with-python/","summary":"📌 BOJ 4811 알약 💡 조건 70세 박종수 할아버지는 매일 매일 약 반알을 먹는다.\n손녀 선영이는 종수 할아버지에게 약이 N개 담긴 병을 선물로 주었다. 다음 날부터 종수는 병에서 약을 하나 꺼낸다.\n(약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고,\n아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다. 종수는 손녀에게 한 조각을 꺼낸 날에는 W를, 반 조각을 꺼낸 날에는 H 보낸다.","title":"[BOJ] 4811 알약 with Python"},{"content":"\n📌 BOJ 9081 단어 맞추기 💡 조건 단어를 주면 그 단어를 이루는 알파벳들로 만들 수 있는 단어들을 사전 순으로 정렬할 때에\n주어진 단어 다음에 나오는 단어를 찾는 프로그램을 작성하는 문제 케이스의 개수 T (1 ≤ T ≤ 10) 단어는 알파벳 A~Z 대문자로만 이루어지며 항상 공백이 없는 연속된 알파벳으로 이루어진다.\n단어의 길이는 100을 넘지 않는다. 구현 유형의 문제 🖥 소스 코드 from sys import stdin for t in range(int(stdin.readline())): string = list(stdin.readline().rstrip()) length = len(string) i, j = 0, 1 for idx in range(1, length): if string[idx] \u0026gt; string[idx - 1]: if i \u0026lt; idx: i = idx for idx in range(1, length): if string[idx] \u0026gt; string[i - 1]: if j \u0026lt; idx: j = idx if i != 0 and j != 0: string[i-1], string[j] = string[j], string[i-1] string[i:] = list(reversed(string[i:])) print(\u0026#39;\u0026#39;.join(string)) 🔖 예제 및 실행결과 예제 4 HELLO DRINK SHUTTLE ZOO 실행결과 HELOL DRKIN SLEHTTU ZOO ⌨️ 문제 풀이 s[i-1] \u0026lt; s[i] 를 만족하는 최대 i(s의 value) 찾는다. j \u0026gt;= 1, s[i-1] \u0026lt; s[j] 를 만족하는 최대 j(index) 찾는다. s[i-1] 과 s[j] 를 바꿔준 뒤, s[i:]의 데이터를 뒤집어 준다. 💾 느낀점 문제를 풀기 위해서 다음에 오는 문자를 구하기 위한 공식이 따로 있었습니다. cpp 에서는 next_permutation 을 사용해서 풀면 된다고 했던 것 같은데, 파이썬은 그게 없다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9081-%EB%8B%A8%EC%96%B4-%EB%A7%9E%EC%B6%94%EA%B8%B0-with-python/","summary":"📌 BOJ 9081 단어 맞추기 💡 조건 단어를 주면 그 단어를 이루는 알파벳들로 만들 수 있는 단어들을 사전 순으로 정렬할 때에\n주어진 단어 다음에 나오는 단어를 찾는 프로그램을 작성하는 문제 케이스의 개수 T (1 ≤ T ≤ 10) 단어는 알파벳 A~Z 대문자로만 이루어지며 항상 공백이 없는 연속된 알파벳으로 이루어진다.\n단어의 길이는 100을 넘지 않는다. 구현 유형의 문제 🖥 소스 코드 from sys import stdin for t in range(int(stdin.readline())): string = list(stdin.","title":"[BOJ] 9081 단어 맞추기 with Python"},{"content":"\n📌 BOJ 1660 캡틴 이다솜 💡 조건 N은 300,000보다 작거나 같은 자연수이다. 사면체를 만드는 방법은 길이가 N인 정삼각형 모양을 만든다.\n그 위에 길이가 N-1인 정삼각형 모양을 얹고 그위에 계속 해서 얹어서 1크기의 정삼각형 모양을 얹으면 된다. N개의 대포알로 만들 수 있는 사면체의 최소 개수를 출력하는 프로그램을 작성하는 문제 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 15 실행결과 3 ⌨️ 문제 풀이 대포알의 개수는 1, 4, 10, 20 \u0026hellip; 순으로 늘어난다. n이 30만이기 때문에 모두 한번에 다 구해놓기에는 힘들기 떄문에,\nn보다 같거나 많은 양의 대포가 쌓여있는 사면체가 처음 등장할때까지 구해야한다. N 이 15라면 1, 4, 10 으로 만들 수 있다.\n15는 14에서 1을 더해 만들 수 있다. 10에서 4를 더하고, 5에서 10을 더해서 만들 수 있다. dp10384 팬그램[i10384 팬그램] = min(dp10384 팬그램[i10384 팬그램], 1 + dp10384 팬그램[i - num10384 팬그램])\n라는 점화식을 세울 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] num = 0 i = 1 while n \u0026gt; num: num += (i * (i + 1)) // 2 arr.append(num) i += 1 dp = [int(1e9) for i in range(n + 1)] for i in range(1, n + 1): for num in arr: if num == i: dp[i] = 1 break elif num \u0026gt; i: break dp[i] = min(dp[i], 1 + dp[i - num]) print(dp[n]) 💾 느낀점 다이나믹\u0026hellip; 프로그래밍\u0026hellip; ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1660-%EC%BA%A1%ED%8B%B4-%EC%9D%B4%EB%8B%A4%EC%86%9C-with-python/","summary":"📌 BOJ 1660 캡틴 이다솜 💡 조건 N은 300,000보다 작거나 같은 자연수이다. 사면체를 만드는 방법은 길이가 N인 정삼각형 모양을 만든다.\n그 위에 길이가 N-1인 정삼각형 모양을 얹고 그위에 계속 해서 얹어서 1크기의 정삼각형 모양을 얹으면 된다. N개의 대포알로 만들 수 있는 사면체의 최소 개수를 출력하는 프로그램을 작성하는 문제 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 15 실행결과 3 ⌨️ 문제 풀이 대포알의 개수는 1, 4, 10, 20 \u0026hellip; 순으로 늘어난다.","title":"[BOJ] 1660 캡틴 이다솜 with Python"},{"content":"\n📌 BOJ 1755 숫자놀이 💡 조건 79를 영어로 읽되 숫자 단위로 하나씩 읽는다면 \u0026ldquo;seven nine\u0026quot;이 된다. 80은 마찬가지로 \u0026ldquo;eight zero\u0026quot;라고 읽는다. 79는 80보다 작지만, 영어로 숫자 하나씩 읽는다면 \u0026ldquo;eight zero\u0026quot;가 \u0026ldquo;seven nine\u0026quot;보다 사전순으로 먼저 온다. 문제는 정수 M, N(1 ≤ M ≤ N ≤ 99)이 주어지면 M 이상 N 이하의 정수를 숫자 하나씩 읽었을 때를 기준으로 사전순으로 정렬하여 출력하는 것. M 이상 N 이하의 정수를 문제 조건에 맞게 정렬하여 한 줄에 10개씩 출력한다. 정렬 유형의 문제 🔖 예제 및 실행결과 예제 8 28 실행결과 8 9 18 15 14 19 11 17 16 13 12 10 28 25 24 21 27 26 23 22 20 ⌨️ 문제 풀이 dict 형 변수 d 에 각 숫자마다의 영어 문자열을 저장한다. n부터 m + 1 까지 순회(i)하면서 i를 문자열로 변환했을 때 길이만큼 또 순회(j)한다. s 배열에 data[j]를 영어 문자열로 변환 후 넣어준다. j 순회가 끝나면 s 리스트에 i를 문자열로 변환한 값을 추가해준다. 그 후, temp 배열에 s를 튜플로 만들어 추가한다. temp를 정렬하고, 정렬된 숫자값을 10개씩 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] num = 0 i = 1 while n \u0026gt; num: num += (i * (i + 1)) // 2 arr.append(num) i += 1 dp = [int(1e9) for i in range(n + 1)] for i in range(1, n + 1): for num in arr: if num == i: dp[i] = 1 break elif num \u0026gt; i: break dp[i] = min(dp[i], 1 + dp[i - num]) print(dp[n]) 💾 느낀점 그다지 어려운 문제가 아니었는데, 복잡하게 생각해서 힘들었던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1755-%EC%88%AB%EC%9E%90%EB%86%80%EC%9D%B4-with-python/","summary":"📌 BOJ 1755 숫자놀이 💡 조건 79를 영어로 읽되 숫자 단위로 하나씩 읽는다면 \u0026ldquo;seven nine\u0026quot;이 된다. 80은 마찬가지로 \u0026ldquo;eight zero\u0026quot;라고 읽는다. 79는 80보다 작지만, 영어로 숫자 하나씩 읽는다면 \u0026ldquo;eight zero\u0026quot;가 \u0026ldquo;seven nine\u0026quot;보다 사전순으로 먼저 온다. 문제는 정수 M, N(1 ≤ M ≤ N ≤ 99)이 주어지면 M 이상 N 이하의 정수를 숫자 하나씩 읽었을 때를 기준으로 사전순으로 정렬하여 출력하는 것. M 이상 N 이하의 정수를 문제 조건에 맞게 정렬하여 한 줄에 10개씩 출력한다.","title":"[BOJ] 1755 숫자놀이 with Python"},{"content":"\n📌 BOJ 1788 피보나치수의 확장 💡 조건 피보나치 수 F(n)을 n이 음수인 경우로도 확장시킬 수 있다. F(n) = F(n-1) + F(n-2)를 n ≤ 1일 때도 성립되도록 정의하는 것이다. n = 1일 때 F(1) = F(0) + F(-1)이 성립되어야 하므로, F(-1)은 1이 되어야 한다. n이 주어졌을 때, 피보나치 수 F(n)을 구하는 프로그램을 작성하는 프로그램.\nn은 음수로 주어질 수도 있다. n은 절댓값이 1,000,000을 넘지 않는 정수이다.\n첫째 줄에 F(n)이 양수이면 1, 0이면 0, 음수이면 -1을 출력한다.\n둘째 줄에는 F(n)의 절댓값을 출력한다.\n이 수가 충분히 커질 수 있으므로, 절댓값을 1,000,000,000으로 나눈 나머지를 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 10 실행결과 1 55 ⌨️ 문제 풀이 피보나치 값을 저장할 fibo 리스트 크기를 150만 개로 만들어준다.\n리스트의 첫번째 값과 두번째 값을 0 과 1로 저장한다. n 이 0보다 작은 경우, -1부터 n까지 -1씩 줄여가면서 순회한다.\nfibo[i + 2] - fibo[i + 1] 의 점화식을 통한 값이 0 보다 작을 경우\nfibo[i]의 값은 fibo[i + 2] - fibo[i + 1] 를 절대값 처리해 준 후, 1000000000로 나누고 다시 음수로 만들어준다. fibo[n] \u0026lt; 0 일 경우, -1 을 출력하고, fibo[n]를 음수로 변환하여 출력한다. fibo[n] \u0026gt;= 0 일 경우, 1 을 출력하고, fibo[n]을 출력한다. n \u0026gt; 0 경우, 일반 피보나치처럼 수를 구한다. n = 0 경우, 0을 출력한다. 🖥 소스 코드 from sys import stdin fibo = [0 for _ in range(1500000)] n = int(stdin.readline()) fibo[0:1] = [0, 1] if n \u0026lt; 0: for i in range(-1, n - 1, -1): data = fibo[i+2] - fibo[i+1] if data \u0026lt; 0: fibo[i] = (abs(data) % 1000000000) * -1 else: fibo[i] = data % 1000000000 if fibo[n] \u0026lt; 0: print(-1) print(fibo[n] * -1) else: print(1) print(fibo[n]) elif n \u0026gt; 0: for i in range(2, n + 1): fibo[i] = (fibo[i - 1] + fibo[i - 2]) % 1000000000 print(1) print(fibo[n]) else: print(0) print(0) 💾 느낀점 음수로 피보나치를 확장하는 것이 생각보다 조금 까다로운 느낌이 있었습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1788-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EC%88%98%EC%9D%98-%ED%99%95%EC%9E%A5-with-python/","summary":"📌 BOJ 1788 피보나치수의 확장 💡 조건 피보나치 수 F(n)을 n이 음수인 경우로도 확장시킬 수 있다. F(n) = F(n-1) + F(n-2)를 n ≤ 1일 때도 성립되도록 정의하는 것이다. n = 1일 때 F(1) = F(0) + F(-1)이 성립되어야 하므로, F(-1)은 1이 되어야 한다. n이 주어졌을 때, 피보나치 수 F(n)을 구하는 프로그램을 작성하는 프로그램.\nn은 음수로 주어질 수도 있다. n은 절댓값이 1,000,000을 넘지 않는 정수이다.\n첫째 줄에 F(n)이 양수이면 1, 0이면 0, 음수이면 -1을 출력한다.","title":"[BOJ] 1788 피보나치수의 확장 with Python"},{"content":"\n📌 BOJ 1822 차집합 💡 조건 집합 A에는 속하면서 집합 B에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하는 문제. 집합 A의 원소의 개수 n(A)와 집합 B의 원소의 개수 n(B)가 빈 칸을 사이에 두고 주어진다. (1 ≤ n(A), n(B) ≤ 500,000)이 주어진다. 둘째 줄에는 집합 A의 원소가, 셋째 줄에는 집합 B의 원소가 빈 칸을 사이에 두고 주어진다. 하나의 집합의 원소는 2,147,483,647 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다르다. 지료구조 유형의 문제 🔖 예제 및 실행결과 예제 4 3 2 5 11 7 9 7 4 실행결과 3 2 5 11 ⌨️ 문제 풀이 각 집합의 원소의 개수를 입력받는다. 각 집합을 입력받되, set() 자료구조에 입력을 받는다. a 집합 자료형에서 b 집합 자료형을 빼준 결과값을 res에 저장한다. res가 빈 값이라면, 0을 출력한다. res가 비어있지 않다면, res의 길이와 정렬된 res를 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) a = set(map(int, stdin.readline().split())) b = set(map(int, stdin.readline().split())) res = a-b if res: print(len(res)) print(*sorted(list(res))) else: print(0) 💾 느낀점 해시맵 자료구조를 사용한 간단한 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1822-%EC%B0%A8%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 1822 차집합 💡 조건 집합 A에는 속하면서 집합 B에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하는 문제. 집합 A의 원소의 개수 n(A)와 집합 B의 원소의 개수 n(B)가 빈 칸을 사이에 두고 주어진다. (1 ≤ n(A), n(B) ≤ 500,000)이 주어진다. 둘째 줄에는 집합 A의 원소가, 셋째 줄에는 집합 B의 원소가 빈 칸을 사이에 두고 주어진다. 하나의 집합의 원소는 2,147,483,647 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다르다. 지료구조 유형의 문제 🔖 예제 및 실행결과 예제 4 3 2 5 11 7 9 7 4 실행결과 3 2 5 11 ⌨️ 문제 풀이 각 집합의 원소의 개수를 입력받는다.","title":"[BOJ] 1822 차집합 with Python"},{"content":"\n📌 BOJ 15965 K번째 소수 💡 조건 서브태스크가 존재한다. 2 이상의 자연수 N이 1과 N을 제외하고 어떤 자연수로도 나누어 떨어지지 않을 때 소수라고 한다. 자연수 K가 주어진다.(1 ≤ K ≤ 500,000) k번째 소수를 구하는 문제 수학, 에라토스테네스의 체 유형의 문제 🔖 예제 및 실행결과 예제 3 실행결과 5 ⌨️ 문제 풀이 에라토스테네스의 체를 사용하여 풀이를 하면 됩니다. i 가 소수일 때, i의 배수는 소수가 아니다 라는 아이디어에서 시작을 합니다. i가 소수로 판별이 되었다면, 10^7 까지 검사를 하면서 i의 배수는 모두 array 배열에서 0으로 체크합니다. 소수로 판별된 i는 answer에 추가해줍니다. 🖥 소스 코드 BIG_NUM = 10**7 k = int(input()) array = [1 for _ in range(BIG_NUM + 1)] answer = [] for i in range(2, BIG_NUM + 1): if array[i]: answer.append(i) for j in range(i+i, BIG_NUM + 1, i): array[j] = 0 print(answer[k - 1]) 💾 느낀점 에라토스테네스의 체가 익숙하지 않은 상태에서 풀었었던 문제였다. 지금은 문제를 슥 읽으니 바로 풀이가 생각이 났다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-15965-k%EB%B2%88%EC%A7%B8-%EC%86%8C%EC%88%98-with-python/","summary":"📌 BOJ 15965 K번째 소수 💡 조건 서브태스크가 존재한다. 2 이상의 자연수 N이 1과 N을 제외하고 어떤 자연수로도 나누어 떨어지지 않을 때 소수라고 한다. 자연수 K가 주어진다.(1 ≤ K ≤ 500,000) k번째 소수를 구하는 문제 수학, 에라토스테네스의 체 유형의 문제 🔖 예제 및 실행결과 예제 3 실행결과 5 ⌨️ 문제 풀이 에라토스테네스의 체를 사용하여 풀이를 하면 됩니다. i 가 소수일 때, i의 배수는 소수가 아니다 라는 아이디어에서 시작을 합니다. i가 소수로 판별이 되었다면, 10^7 까지 검사를 하면서 i의 배수는 모두 array 배열에서 0으로 체크합니다.","title":"[BOJ] 15965 K번째 소수 with Python"},{"content":"\n📌 BOJ 16935 배열 돌리기 3 💡 조건 크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다.\n1번 연산은 배열을 상하 반전시키는 연산이다.\n2번 연산은 배열을 좌우 반전시키는 연산이다.\n3번 연산은 오른쪽으로 90도 회전시키는 연산이다.\n4번 연산은 왼쪽으로 90도 회전시키는 연산이다.\n5, 6번은 문제 참고 첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.\n2 ≤ N, M ≤ 100, N, M은 짝수\n1 ≤ R ≤ 1,000 둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.\n1 ≤ Aij ≤ 108 연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 6 8 6 3 2 6 3 1 2 9 7 9 7 8 2 1 4 5 3 5 9 2 1 9 6 1 8 2 1 3 8 6 3 9 2 1 3 2 8 7 9 2 1 4 5 1 9 8 2 1 3 1 2 3 4 5 6 실행결과 3 1 2 8 9 1 5 4 1 2 9 7 8 2 3 1 2 9 3 6 8 3 1 2 8 1 6 9 1 2 9 5 3 5 4 1 2 8 7 9 7 9 2 1 3 6 2 3 ⌨️ 문제 풀이 말 그대로 구현을 하는 문제였다. 🖥 소스 코드 from sys import stdin n, m, r = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) command = list(map(int, list(stdin.readline().split()))) for i in range(r): if command[i] == 1: length = len(board) for j in range(length // 2): board[j], board[length - 1 - j] = board[length - 1 - j], board[j] elif command[i] == 2: for i in range(len(board)): board[i] = list(reversed(board[i])) elif command[i] == 3: if len(board) == n: new_board = [[0] * n for _ in range(m)] for j in range(m): for k in range(n): new_board[j][n - 1 - k] = board[k][j] else: new_board = [[0] * m for _ in range(n)] for j in range(n): for k in range(m): new_board[j][m - 1 - k] = board[k][j] board = new_board elif command[i] == 4: if len(board) == n: new_board = [[0] * n for _ in range(m)] for j in range(m - 1, -1, -1): for k in range(n - 1, -1, -1): new_board[(m - 1) - j][k] = board[k][j] else: new_board = [[0] * m for _ in range(n)] for j in range(n - 1, -1, -1): for k in range(m - 1, -1, -1): new_board[(n - 1) - j][k] = board[k][j] board = new_board elif command[i] == 5: r, c = len(board), len(board[0]) new_board = [[0] * c for _ in range(r)] arr1 = [item[:c // 2] for item in board[:r // 2]] arr2 = [item[c // 2:] for item in board[:r // 2]] arr3 = [item[c // 2:] for item in board[r // 2:]] arr4 = [item[:c // 2] for item in board[r // 2:]] for j in range(r // 2): new_board[j] = arr4[j] + arr1[j] for j in range(r // 2, r): new_board[j] = arr3[j - r // 2] + arr2[j - r // 2] board = new_board elif command[i] == 6: r, c = len(board), len(board[0]) new_board = [[0] * c for _ in range(r)] arr1 = [item[:c // 2] for item in board[:r // 2]] arr2 = [item[c // 2:] for item in board[:r // 2]] arr3 = [item[c // 2:] for item in board[r // 2:]] arr4 = [item[:c // 2] for item in board[r // 2:]] for j in range(r // 2): new_board[j] = arr2[j] + arr3[j] for j in range(r // 2, r): new_board[j] = arr1[j - r // 2] + arr4[j - r // 2] board = new_board for arr in board: print(*arr) 💾 느낀점 배열을 돌리는게 꽤 까다롭긴한데, 천천히 그림을 그리며 정리해서 풀었습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-16935-%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0-3-with-python/","summary":"📌 BOJ 16935 배열 돌리기 3 💡 조건 크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다.\n1번 연산은 배열을 상하 반전시키는 연산이다.\n2번 연산은 배열을 좌우 반전시키는 연산이다.\n3번 연산은 오른쪽으로 90도 회전시키는 연산이다.\n4번 연산은 왼쪽으로 90도 회전시키는 연산이다.\n5, 6번은 문제 참고 첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.\n2 ≤ N, M ≤ 100, N, M은 짝수\n1 ≤ R ≤ 1,000 둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.","title":"[BOJ] 16935 배열 돌리기 3 with Python"},{"content":"\n📌 BOJ 10384 팬그램 💡 조건 팬그램은 모든 알파벳을 적어도 한 번씩을 사용한 영어 문장을 말한다. 더블 팬그램은 모든 알파벳을 적어도 두 번씩은 사용한 문장을 말하고, 트리플 팬그램은 모든 알파벳을 적어도 세 번씩은 사용한 문장을 말한다. 입력은 여러 줄의 테스트케이스들로 이루어진다.\n첫째 줄에 테스트케이스의 수 n이 주어진다.\n각 테스트케이스는 영어 소문자와 대문자, 특수기호들로 이루어진다. 팬그램이 아닐 경우 - Not a pangram\n팬그램일 경우 - Pangram!\n더블 팬그램일 경우 - Double pangram!!\n트리플 팬그램일 경우 - Triple pangram!!! 구현 유형의 문제 🔖 예제 및 실행결과 예제 3 The quick brown fox jumps over a lazy dog. The quick brown fox jumps over a laconic dog. abcdefghijklmNOPQRSTUVWXYZ-zyxwvutsrqpon 2013/2014 MLKJIHGFEDCBA 실행결과 Case 1: Pangram! Case 2: Not a pangram Case 3: Double pangram!! ⌨️ 문제 풀이 테스트케이스만큼 반복문을 진행하면서, 결과값을 저장할 res 변수를 \u0026lsquo;Not a pangram\u0026rsquo;으로 초기화한다. string에 어떤 검사할 문자열을 입력받고, 알파벳을 몇번 썼는지 검사할 alphabet 이라는 2차원 배열을 만든다. string을 순회하면서 알파벳이 아닐 경우 continue, 알파벳일 경우 해당 알파벳을 True로 체크해주면된다. 최대 트리플 팬그램까지 밖에 없으니 idx 를 0부터 시작하여 2까지 늘려주고, 다시 0으로 만들어주는 작업을 통해서 알파벳이 사용되었는지 체크한다. alphabet 리스트를 순회하면서 리스트에 False가 없다면 cnt + 1, 있다면 break를 한다. cnt에 따라 결과값 res를 갱신하고 출력양식에 맞게 출력한다. 🖥 소스 코드 from sys import stdin for i in range(1, int(stdin.readline()) + 1): res = \u0026#39;Not a pangram\u0026#39; string = stdin.readline().rstrip() alphabet = [[False] * 26 for _ in range(3)] for j in string: idx = 0 if not j.isalpha(): continue else: while 1: if not alphabet[idx][ord(j.lower()) - 97]: alphabet[idx][ord(j.lower()) - 97] = True break else: idx += 1 if idx \u0026gt; 2: idx = 0 break cnt = 0 for data in alphabet: if False in data: break else: cnt += 1 if cnt == 1: res = \u0026#39;Pangram!\u0026#39; elif cnt == 2: res = \u0026#39;Double pangram!!\u0026#39; elif cnt == 3: res = \u0026#39;Triple pangram!!!\u0026#39; print(\u0026#39;Case {}: {}\u0026#39;.format(i, res)) 💾 느낀점 dict로도 풀수 있지 않을까? 라는 생각이 든다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10384-%ED%8C%AC%EA%B7%B8%EB%9E%A8-with-python/","summary":"📌 BOJ 10384 팬그램 💡 조건 팬그램은 모든 알파벳을 적어도 한 번씩을 사용한 영어 문장을 말한다. 더블 팬그램은 모든 알파벳을 적어도 두 번씩은 사용한 문장을 말하고, 트리플 팬그램은 모든 알파벳을 적어도 세 번씩은 사용한 문장을 말한다. 입력은 여러 줄의 테스트케이스들로 이루어진다.\n첫째 줄에 테스트케이스의 수 n이 주어진다.\n각 테스트케이스는 영어 소문자와 대문자, 특수기호들로 이루어진다. 팬그램이 아닐 경우 - Not a pangram\n팬그램일 경우 - Pangram!\n더블 팬그램일 경우 - Double pangram!","title":"[BOJ] 10384 팬그램 with Python"},{"content":"\n📌 BOJ 9742 순열 💡 조건 집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하는 문제 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 235 4 bein 20 123456 700 mnpqr 130 tuvwxyz 4000 실행결과 235 4 = 352 bein 20 = nbie 123456 700 = 651342 mnpqr 130 = No permutation tuvwxyz 4000 = ywuxvzt ⌨️ 문제 풀이 입력받은 순열 집합의 길이의 제곱이 구하고자하는 순서의 숫자보다 작을 경우, No permutation 을 출력하면 됩니다. (1)번에 해당하지 않을 경우, 재귀호출을 통해 순열을 구하면 됩니다. 테스트 케이스가 여러 개이기 때문에 while 문으로 감싼 뒤, 입력받은 문자가 2개로 나누어지지 않을 경우 break 를 해주면 됩니다. 재귀호출에서 cnt 의 개수가 재귀 호출을 통해 만들어진 순열의 개수와 같아지면 그대로 문자열을 반환시키면 됩니다. 🖥 소스 코드 from sys import stdin from math import factorial def solve(string, i): global cnt if i == len(a): cnt += 1 if cnt == b: return string else: for k in a: if k not in string: res = solve(string + k, i + 1) if res: return res return while 1: cnt = 0 input_data = stdin.readline().rstrip().split() if len(input_data) != 2: break a, b = input_data b = int(b) if factorial(len(a)) \u0026lt; b: print(a, b, \u0026#39;=\u0026#39;, \u0026#39;No permutation\u0026#39;) else: print(a, b, \u0026#39;=\u0026#39;, solve(\u0026#39;\u0026#39;, 0)) 💾 느낀점 입력 받은 순열 집합의 길이의 제곱이 구하고자하는 n번째, 즉 n보다 작을 경우 DFS를 돌리지 않아도 되는 사실을 몰랐다 (1)번을 잘 몰랐기에 당연히 시간초과가 떠서 고생을 했던 문제이다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9742-%EC%88%9C%EC%97%B4-with-python/","summary":"📌 BOJ 9742 순열 💡 조건 집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하는 문제 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.","title":"[BOJ] 9742 순열 with Python"},{"content":"\n📌 BOJ 6443 애너그램 💡 조건 첫째 줄에 단어의 개수 N 이, 둘째 줄부터 N개의 영단어가 들어온다. 영단어는 소문자로 이루어져 있다. 단어의 길이는 20보다 작거나 같고, 애너그램의 수가 100,000개 이하인 단어만 입력으로 주어진다. 애너그램 프로그램이란, 입력받은 영단어의 철자들로 만들 수 있는 모든 단어를 출력하는 것이다. 입력받은 단어내에 몇몇 철자가 중복될 수 있다. 이 경우 같은 단어가 여러 번 만들어 질 수 있는데, 한 번만 출력해야 한다. 또한 출력할 때에 알파벳 순서로 출력해야 한다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 2 abc acba 실행결과 abc acb bac bca cab cba aabc aacb abac abca acab acba baac baca bcaa caab caba cbaa ⌨️# 문제 풀이 string 이라는 변수에 문자열을, 각 알파벳이 몇 개 나왔는지 개수를 저장할 alpha 라는 변수를 만든다 입력받은 문자열을 순회하면서 arr에 각 알파벳의 개수를 기록해준다. solve() 함수에 string의 길이와 빈 문자열을 매개변수로 주고 실행합니다. solve() 함수에서 alpha 배열의 값이 0보다 클 때 매개변수로 문자열에 알파벳을 붙이고 매개변수로 넣는다.\n그리고 문자열의 길이를 -1 해준다. 매개변수로 받는 문자열의 길이가 0이 되었을 때, visited 에 넣어줍니다. visited 를 리스트로 변환하고, 정렬한 뒤, 순서대로 출력한다. 🖥 소스 코드 from sys import stdin def solve(l, s): if l == 0: visited.add(s) return for i in range(26): if alpha[i] \u0026gt;= 1: alpha[i] -= 1 solve(l - 1, s + chr(i + 97)) alpha[i] += 1 for _ in range(int(stdin.readline())): visited = set() alpha = [0 for _ in range(26)] string = stdin.readline().rstrip() for i in string: alpha[ord(i)-97] += 1 solve(len(string), \u0026#39;\u0026#39;) for s in sorted(list(visited)): print(s) 💾 느낀점 골드문제치고 시간초과가 나지 않는 쉬운 문제였습니다. 재귀함수를 통해서 백트래킹으로 간단히 풀 수 있는 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-6443-%EC%95%A0%EB%84%88%EA%B7%B8%EB%9E%A8-with-python/","summary":"📌 BOJ 6443 애너그램 💡 조건 첫째 줄에 단어의 개수 N 이, 둘째 줄부터 N개의 영단어가 들어온다. 영단어는 소문자로 이루어져 있다. 단어의 길이는 20보다 작거나 같고, 애너그램의 수가 100,000개 이하인 단어만 입력으로 주어진다. 애너그램 프로그램이란, 입력받은 영단어의 철자들로 만들 수 있는 모든 단어를 출력하는 것이다. 입력받은 단어내에 몇몇 철자가 중복될 수 있다. 이 경우 같은 단어가 여러 번 만들어 질 수 있는데, 한 번만 출력해야 한다. 또한 출력할 때에 알파벳 순서로 출력해야 한다.","title":"[BOJ] 6443 애너그램 with Python"},{"content":"\n📌 BOJ 8394 악수 💡 조건 회의가 끝났고, 이제 악수를 하는 시간이다. 모든 사람은 직사각형 탁자 하나의 한 면에 앉아있다. 자리를 벗어나지 않고 악수를 하는 방법의 수를 구하는 문제 각 사람들은 자신의 왼쪽이나 오른쪽에 있는 사람들과 악수를 할 수 있다. (안 할 수도 있다) 첫째 줄에 회의에 참석한 사람의 수 n (1 ≤ n ≤ 10,000,000)이 주어진다. 수가 매우 커질 수 있기 때문에, 마지막 자리만 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 실행결과 5 ⌨️ 문제 풀이 n 이 1일 때는 악수를 안하는 경우, n이 2일 때는 악수를 안하는 경우와 둘이 악수를 하는 경우가 있다. n 이 3일 때는 세번째 사람이 악수를 안할경우, 이 때는 두명이 있을 경우와 같기 때문에 dp[i-1] 과 같다고 할 수 있다. 세번째 사람이 악수를 할 경우, 첫번째 사람이 혼자 남기 때문에 dp[n-2]와 같다고 할 수 있다. dp[n] = dp[n-2] + dp[n-1] 이는 피보나치 수열의 점화식과 같으나, 맨 마지막 숫자만 출력하면 된다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [0 for _ in range(n + 1)] arr[0], arr[1] = 1, 1 for i in range(2, n + 1): arr[i] = (arr[i-1] + arr[i - 2]) % 10 print(arr[n]) 💾 느낀점 나는 피보나치 수열의 점화식과 같은지 모르고, 전수조사를 통해서 문제를 파악하고 규칙을 찾았다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-8394-%EC%95%85%EC%88%98-with-python/","summary":"📌 BOJ 8394 악수 💡 조건 회의가 끝났고, 이제 악수를 하는 시간이다. 모든 사람은 직사각형 탁자 하나의 한 면에 앉아있다. 자리를 벗어나지 않고 악수를 하는 방법의 수를 구하는 문제 각 사람들은 자신의 왼쪽이나 오른쪽에 있는 사람들과 악수를 할 수 있다. (안 할 수도 있다) 첫째 줄에 회의에 참석한 사람의 수 n (1 ≤ n ≤ 10,000,000)이 주어진다. 수가 매우 커질 수 있기 때문에, 마지막 자리만 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 실행결과 5 ⌨️ 문제 풀이 n 이 1일 때는 악수를 안하는 경우, n이 2일 때는 악수를 안하는 경우와 둘이 악수를 하는 경우가 있다.","title":"[BOJ] 8394 악수 with Python"},{"content":"\n📌 BOJ 1342 행운의 문자열 💡 조건 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다. 첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 abcdefghij 실행결과 3628800 ⌨️ 문제 풀이 브루트포스 알고리즘으로 해결하는 문제였습니다. arr 에 입력받은 문자열을 저장한 뒤, 순차적으로 순회하면서 point 배열에 점수를 부여합니다. solve() 함수는 재귀함수입니다. arr 에 있는 중복되지 않는 문자를 하니씩 넣으면서 만들 수 있는 문자열마다 cnt를 하나씩 늘려줍니다. cnt를 출력합니다. 🖥 소스 코드 from sys import stdin arr = stdin.readline().rstrip() cnt = 0 point = [0 for _ in range(26)] for i in arr: point[ord(i) - 97] += 1 def solve(goal, p): global cnt if goal == 0: cnt += 1 return for c in set(list(arr)): if point[ord(c) - 97] \u0026gt; 0 and c != p: point[ord(c) - 97] -= 1 solve(goal - 1, c) point[ord(c) - 97] += 1 solve(len(arr), \u0026#39;\u0026#39;) print(cnt) 💾 느낀점 재귀함수를 통해서 브루트포스를 구현했습니다. 파이썬에서는 pypy로 채점이 가능했습니다. 시간을 단축할 수 있는 방법을 생각해보는 것도 좋겠습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1342-%ED%96%89%EC%9A%B4%EC%9D%98-%EB%AC%B8%EC%9E%90%EC%97%B4-with-python/","summary":"📌 BOJ 1342 행운의 문자열 💡 조건 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다. 첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 abcdefghij 실행결과 3628800 ⌨️ 문제 풀이 브루트포스 알고리즘으로 해결하는 문제였습니다.","title":"[BOJ] 1342 행운의 문자열 with Python"},{"content":"\n📌 BOJ 18243 Small World Network 💡 조건 첫 번째 줄에 지구에 있는 사람의 수 N과 친구 관계의 개수 K.\n(1 ≤ N ≤ 100, 0 ≤ K ≤ N×(N-1)/2) 모든 사람은 1부터 N까지 번호가 매겨져 있다. 두 번째 줄부터 K+1번째 줄까지 친구 관계를 나타내는 A B가 한 줄에 하나씩 주어진다.\n(1 ≤ A, B ≤ N) A와 B가 친구면 B와 A도 친구다. 자기 자신과 친구인 경우는 없다.\nA와 B의 친구 관계는 중복되어 입력되지 않는다. 해당 네트워크가 작은 세상 네트워크를 만족하면\n\u0026ldquo;Small World!\u0026ldquo;를, 만족하지 않는다면 \u0026ldquo;Big World!\u0026ldquo;를 출력 BFS, 그래프 이론 유형의 문제 🔖 예제 및 실행결과 예제 10 8 1 2 2 3 3 4 4 5 6 7 7 8 8 9 9 10 실행결과 Big World! ⌨️ 문제 풀이 네트워크 상의 친구 사이는 양방향 간선이라고 볼 수 있다. 그래프로 사용할 network 라는 리스트를 만들고, 그래프에 입력한다. 1번 노드부터 bfs() 알고리즘을 수행하면서 q 에 (노드번호, dist)를 넣어 수행한다.\ndist = 0 부터 시작한다. bfs가 수행되면서 dist가 6을 초과하면, False를 반환한다. visited (방문 처리 set)의 길이가 만약 노드 총 개수 n과 같지 않다면 False 를 반환. 반환받은 bfs 의 결과값이 False라면 \u0026ldquo;Big World!\u0026rdquo;\n반환받은 bfs 의 결과값이 True라면 \u0026ldquo;Small World!\u0026rdquo; 🖥 소스 코드 from sys import stdin from collections import deque n, k = map(int, stdin.readline().split()) network = [[] for _ in range((n + 1))] tf = True for i in range(k): a, b = map(int, stdin.readline().split()) network[a].append(b) network[b].append(a) def bfs(root): visited = set() visited.add(root) q = deque() q.append((root, 0)) while q: now, dist = q.popleft() if dist \u0026gt; 6: return False for node in network[now]: if node not in visited: visited.add(node) q.append((node, dist + 1)) if len(visited) == n: return True else: return False for i in range(1, n + 1): if not bfs(i): tf = False break if tf: print(\u0026#34;Small World!\u0026#34;) else: print(\u0026#34;Big World!\u0026#34;) 💾 느낀점 BFS로는 풀이를 가능했지만, 플로이드-와샬 알고리즘에서는 실패했었다. (1)번 의 이유는 dist \u0026gt; 6 의 조건을 처리하지 못해서였다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-18243-small-world-network-with-python/","summary":"📌 BOJ 18243 Small World Network 💡 조건 첫 번째 줄에 지구에 있는 사람의 수 N과 친구 관계의 개수 K.\n(1 ≤ N ≤ 100, 0 ≤ K ≤ N×(N-1)/2) 모든 사람은 1부터 N까지 번호가 매겨져 있다. 두 번째 줄부터 K+1번째 줄까지 친구 관계를 나타내는 A B가 한 줄에 하나씩 주어진다.\n(1 ≤ A, B ≤ N) A와 B가 친구면 B와 A도 친구다. 자기 자신과 친구인 경우는 없다.\nA와 B의 친구 관계는 중복되어 입력되지 않는다.","title":"[BOJ] 18243 Small World Network with Python"},{"content":"\n📌 BOJ 1855 암호 💡 조건 먼저 암호화 할 문자열을 1,1부터 위에서 아래 순서대로 채운다. 그리고 가장 밑의 행을 채운 후에는 오른쪽 열에서 다시 같은 과정을 반복한다. 암호화 된 문자열과 몇 개의 열로 암호화를 하였는지 주어져 있을 때 원래의 문자열을 구하는 프로그램을 작성하는 문제. 열의 개수 K(1 ≤ K ≤ 20)가 주어진다.\n두 번째 줄에는 암호화 된 문자열(모두 영소문자)이 주어진다. (문자열의 길이는 200 이하이며 K의 배수이다.) 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 3 aeijfbcgklhd 실행결과 abcdefghijkl ⌨️ 문제 풀이 열의 개수와 문자열을 입력받고, 열의 개수에 맞게 문자열을 쪼개서 arr 리스트에 저장한다. arr의 행의 개수만큼 순회하면서 i를 2로 나누었을 때, 0인 경우 arr[i] 을 뒤집어 arr에 다시 저장한다. 결과값을 담을 res 변수에 arr 배열을 차례대로 순회하면서 res에 문자열을 추가해준다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) s = stdin.readline().rstrip() arr = [] for i in range(0, len(s), n): arr.append(list(s[i:i+n])) for i in range(len(arr)): if i % 2 != 0: data = list(reversed(arr[i])) arr[i] = data res = \u0026#39;\u0026#39; for j in range(n): for i in range(len(arr)): res += arr[i][j] print(res) 💾 느낀점 친절하고 재미있는 문자열 + 구현 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1855-%EC%95%94%ED%98%B8-with-python/","summary":"📌 BOJ 1855 암호 💡 조건 먼저 암호화 할 문자열을 1,1부터 위에서 아래 순서대로 채운다. 그리고 가장 밑의 행을 채운 후에는 오른쪽 열에서 다시 같은 과정을 반복한다. 암호화 된 문자열과 몇 개의 열로 암호화를 하였는지 주어져 있을 때 원래의 문자열을 구하는 프로그램을 작성하는 문제. 열의 개수 K(1 ≤ K ≤ 20)가 주어진다.\n두 번째 줄에는 암호화 된 문자열(모두 영소문자)이 주어진다. (문자열의 길이는 200 이하이며 K의 배수이다.) 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 3 aeijfbcgklhd 실행결과 abcdefghijkl ⌨️ 문제 풀이 열의 개수와 문자열을 입력받고, 열의 개수에 맞게 문자열을 쪼개서 arr 리스트에 저장한다.","title":"[BOJ] 1855 암호 with Python"},{"content":"\n📌 BOJ 2697 다음수 구하기 💡 조건 A의 다음수는 A와 구성이 같으면서, A보다 큰 수 중에서 가장 작은 수. A와 B의 구성이 같다는 말은 A를 이루고 있는 각 자리수의 등장 횟수가, B를 이루는 각 자리수의 등장 횟수와 같을 때. 첫째 줄에 테스트 케이스의 개수 T(1\u0026lt;=T\u0026lt;=1,000)가 주어진다.\n둘째 줄부터 T개 줄에는 각 테스트 케이스가 주어진다. 테스트 케이스는 한 줄로 이루어져 있으며, 수 A이다. A는 최대 80자리 자연수이다. 어떤 수 A가 주어졌을 때, A의 다음수를 구하는 프로그램을 작성하는 문제.\n만약, A의 다음수가 없을 때는 BIGGEST를 출력한다. 구현, 문자열, 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 123 279134399742 987 실행결과 132 279134423799 BIGGEST ⌨️ 문제 풀이 입력받은 숫자를 역순으로 탐색합니다. 왼쪽에 있는 값이 오른쪽보다 작아질 경우, idx에 해당 인덱스 값을 넣어줍니다. 숫자를 a 와 b 로 나누는데, 그 기준은 idx 값으로 나눌 수 있습니다. 나누어진 두 숫자 중 하나라도 비어있다면, BIGGEST 를 출력합니다. (4)번의 경우가 아니라면, b 를 오름차순으로 정렬하고, b의 길이만큼 순회합니다. 원래 입력 받았던 숫자의 idx 번째 숫자보다 b를 순회하는 중 i번째 숫자가 크다면,\ni번째 숫자를 뽑아서 a에 붙이고, 나머지 b를 그대로 이어붙여줍니다. a를 문자열로 출력합니다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): data = list(map(int, list(stdin.readline().rstrip()))) length, idx = len(data), 0 for i in range(length - 1, 0, -1): if data[i] \u0026gt; data[i - 1]: if i == length - 1: idx = length - 2 else: idx = i - 1 break a = data[:idx] b = data[idx:] if not a or not b: print(\u0026#39;BIGGEST\u0026#39;) else: b.sort() for i in range(len(b)): if b[i] \u0026gt; data[idx]: a.append(b.pop(i)) a.extend(b) break print(\u0026#39;\u0026#39;.join(map(str, a))) 💾 느낀점 문제를 한참보고도 헤맸던 문제였다. 원래 이런 규칙이 있는 것처럼 모두 풀이를 써놔서 일단 풀이를 외웠던 것으로 기억했다. 글을 쓰면서 다시 한번 풀이를 상기해보려고 했으나, 어려웠던 문제 중 하나인 것 같다. 이러한 문제를 만나면 천천히 풀이를 생각해보자. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2697-%EB%8B%A4%EC%9D%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 2697 다음수 구하기 💡 조건 A의 다음수는 A와 구성이 같으면서, A보다 큰 수 중에서 가장 작은 수. A와 B의 구성이 같다는 말은 A를 이루고 있는 각 자리수의 등장 횟수가, B를 이루는 각 자리수의 등장 횟수와 같을 때. 첫째 줄에 테스트 케이스의 개수 T(1\u0026lt;=T\u0026lt;=1,000)가 주어진다.\n둘째 줄부터 T개 줄에는 각 테스트 케이스가 주어진다. 테스트 케이스는 한 줄로 이루어져 있으며, 수 A이다. A는 최대 80자리 자연수이다. 어떤 수 A가 주어졌을 때, A의 다음수를 구하는 프로그램을 작성하는 문제.","title":"[BOJ] 2697 다음수 구하기 with Python"},{"content":"\n📌 BOJ 14425 문자열 집합 💡 조건 N개의 문자열로 이루어진 집합 S 입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 문제 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000) 어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다. 문자열, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 5 11 baekjoononlinejudge startlink codeplus sundaycoding codingsh baekjoon codeplus codeminus startlink starlink sundaycoding codingsh codinghs sondaycoding startrink icerink 실행결과 4 ⌨️ 문제 풀이 n개의 문자열을 dictionary 자료형 변수에 넣는다 m 개의 문자열을 입력 받으면서 만약 입력 받은 문자열이 만들어둔 dictionary 변수에 있다면\n그 키에 해당하는 value 값을 + 1 해준다. dictionary 의 values 값을 모두 더해준다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) strings = {} for _ in range(n): strings[stdin.readline().rstrip()] = 0 for i in range(m): s = stdin.readline().rstrip() if s in strings: strings[s] += 1 print(sum(strings.values())) 💾 느낀점 해시맵, dict 자료구조를 이용하는 문제인데, 문제 태그에 트라이라고 되어 있었습니다. 트라이까지 필요한지는 모르겠으나, N 과 M 의 최대 크기가 10000 이라서\ndict 안에 입력 받은 m개의 문자열이 있는지 검사시켰습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14425-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 14425 문자열 집합 💡 조건 N개의 문자열로 이루어진 집합 S 입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 문제 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000) 어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다. 문자열, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 5 11 baekjoononlinejudge startlink codeplus sundaycoding codingsh baekjoon codeplus codeminus startlink starlink sundaycoding codingsh codinghs sondaycoding startrink icerink 실행결과 4 ⌨️ 문제 풀이 n개의 문자열을 dictionary 자료형 변수에 넣는다 m 개의 문자열을 입력 받으면서 만약 입력 받은 문자열이 만들어둔 dictionary 변수에 있다면","title":"[BOJ] 14425 문자열 집합 with Python"},{"content":"\n📌 BOJ 15722 빙글빙글 스네일 💡 조건 달팽이는 원점에서 시작하여 1초에 한 칸 씩, 시계방향으로 아래 그림과 같이 움직인다. 1초일 때 달팽이의 위치는 (0, 1)이다. 몇 초가 지났는지가 입력으로 주어질 때, 현재 달팽이의 위치를 좌표로 출력하는 문제 달팽이가 움직인 시간이 n초로 주어진다. (0 ≤ n ≤ 1000, n은 0이상의 정수) 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 9 실행결과 -1 2 ⌨️ 문제 풀이 달팽이의 첫 위치를 [0, 0]으로 지정한다. cnt 가 n 과 같아질 때까지 반복을 할 것. i가 0일 때는 좌표 값을 더해주고, 1일 때는 좌표 값을 빼줄 것. 좌표를 더해주거나 빼줄 때, cnt 를 1씩 증가시키고, i 를 순회할 때마다 length를 늘려준다\n늘려준 length 는 좌표를 반복적으로 빼주고 더해줄 때 사용하는 변수 mode 는 1 일 때 0으로, 0일 때 1로 변경해주는데, x, y 를 각각 더하고 빼줄 때 사용하는 것. 함수가 반복적으로 좌표를 빼주고 더해주는 작업을 하다가, cnt가 n과 같아지면 좌표 pos 를 리턴한다. 🖥 소스 코드 from sys import stdin def solve(): n = int(stdin.readline()) pos = [0, 0] mode, length = 0, 1 cnt = 0 while 1: for i in range(2): for _ in range(2): # Add if i == 0: if mode == 0: for _ in range(length): pos[1] += 1 cnt += 1 if n == cnt: return pos else: for _ in range(length): pos[0] += 1 cnt += 1 if n == cnt: return pos # Sub if i == 1: if mode == 0: for _ in range(length): pos[1] -= 1 cnt += 1 if n == cnt: return pos else: for _ in range(length): pos[0] -= 1 cnt += 1 if n == cnt: return pos mode = 1 if mode == 0 else 0 length += 1 print(*solve()) 💾 느낀점 문제에서 설명해주는 대로 달팽이가 움직이는 방향을 잘 생각해서 구현해야 합니다. 스스로 구현 실력이 부족하다고 생각했던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-15722-%EB%B9%99%EA%B8%80%EB%B9%99%EA%B8%80-%EC%8A%A4%EB%84%A4%EC%9D%BC-with-python/","summary":"📌 BOJ 15722 빙글빙글 스네일 💡 조건 달팽이는 원점에서 시작하여 1초에 한 칸 씩, 시계방향으로 아래 그림과 같이 움직인다. 1초일 때 달팽이의 위치는 (0, 1)이다. 몇 초가 지났는지가 입력으로 주어질 때, 현재 달팽이의 위치를 좌표로 출력하는 문제 달팽이가 움직인 시간이 n초로 주어진다. (0 ≤ n ≤ 1000, n은 0이상의 정수) 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 9 실행결과 -1 2 ⌨️ 문제 풀이 달팽이의 첫 위치를 [0, 0]으로 지정한다.","title":"[BOJ] 15722 빙글빙글 스네일 with Python"},{"content":"\n📌 BOJ 10546 배부른 마라토너 💡 조건 참가자 수 N이 주어진다. (1 ≤ N ≤ 105) N개의 줄에는 참가자의 이름이 주어진다. N-1개의 줄에는 완주한 참가자의 이름이 쓰여져 있다. 참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다.\n참가자들 중엔 동명이인이 있을 수도 있다. 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른 참가자 한 명은 누굴까? 해시맵 자료구조 응용 유형의 문제 🔖 예제 및 실행결과 예제 4 mislav stanko mislav ana stanko ana mislav 실행결과 mislav ⌨️ 문제 풀이 동명이인이 있다는 것이 중요합니다. {key: value} 형식으로 저장되는 데이터를 사용하는 Dictionary 자료구조를 사용합니다. n 을 입력받고, n만큼 반복문을 진행하면서 대회에 참가한 인원들을 dictionary 자료구조에 넣습니다.\n{참가자 이름 : 인원 수}, 인원 수는 dictionary 에 이름이 없을 땐 1로 초기화해서 넣습니다. n-1 만큼 반복문을 진행하면서 완주한 사람들의 이름에 해당하는 값을 dictionary에서 -1 해줍니다. dictionary.item() 을 통해서 key, value 값을 순회하면서 value 가 0보다 큰 키 값을 찾습니다. 참가자 한명을 찾는 것이기 때문에 출력한 뒤 바로 break 를 걸어 멈춰줍니다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) mara_tang = {} for _ in range(n): name = stdin.readline().rstrip() if name not in mara_tang: mara_tang[name] = 1 else: mara_tang[name] += 1 for _ in range(n - 1): mara_tang[stdin.readline().rstrip()] -= 1 for key, item in mara_tang.items(): if item != 0: print(key) break 💾 느낀점 파이썬 딕셔너리 만세 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10546-%EB%B0%B0%EB%B6%80%EB%A5%B8-%EB%A7%88%EB%9D%BC%ED%86%A0%EB%84%88-with-python/","summary":"📌 BOJ 10546 배부른 마라토너 💡 조건 참가자 수 N이 주어진다. (1 ≤ N ≤ 105) N개의 줄에는 참가자의 이름이 주어진다. N-1개의 줄에는 완주한 참가자의 이름이 쓰여져 있다. 참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다.\n참가자들 중엔 동명이인이 있을 수도 있다. 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른 참가자 한 명은 누굴까? 해시맵 자료구조 응용 유형의 문제 🔖 예제 및 실행결과 예제 4 mislav stanko mislav ana stanko ana mislav 실행결과 mislav ⌨️ 문제 풀이 동명이인이 있다는 것이 중요합니다.","title":"[BOJ] 10546 배부른 마라토너 with Python"},{"content":"\n📌 BOJ 11501 주식 💡 조건 홍준이는 요즘 주식에 빠져있다. 아래 세가지 중 하나의 행동을 한다. 주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다. 테스트케이스 수를 나타내는 자연수 T. 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고,\n둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다. 최대 이익이 얼마나 되는지 계산을 해 출력하는 문제. 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 3 10 7 6 3 3 5 9 5 1 1 3 1 2 실행결과 0 10 5 ⌨️ 문제 풀이 이 문제의 키포인트는, 주식의 예측 값이 떨어질 때 주식을 모두 팔아 이익을 챙기는 것이 아닌,\n현재 가격의 주식을 언제 팔아서 최대 이익을 낼 것이냐? 입니다. 그러므로 입력을 받은 데이터를 역순회하면서, 현재 순회하고 있는 주가가 주가 최댓값보다 크다면 갱신합니다. 순회하고 있는 주가가 주가 최댓값보다 작아지면 출력할 변수(money) 에 (주가 최댓값 - 현재 순회 하고 있는 주가)를 더해줍니다. 🖥 소스 코드 from sys import stdin for tc in range(int(stdin.readline())): n = int(stdin.readline()) days = list(map(int, stdin.readline().split())) m_val, money = 0, 0 for i in range(n - 1, -1, -1): if m_val \u0026lt; days[i]: m_val = days[i] elif m_val \u0026gt; days[i]: money += (m_val - days[i]) print(money) 💾 느낀점 그리디라고 무지성으로 그냥 더했다 팔았다 하는게 아니라 역순으로도 생각해볼 수 있게 도와준 문제였습니다. 그리디도 쉽게 볼게 아니었습니다. 생각이 많이 열려있지 않다는 걸 느꼈습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11501-%EC%A3%BC%EC%8B%9D-with-python/","summary":"📌 BOJ 11501 주식 💡 조건 홍준이는 요즘 주식에 빠져있다. 아래 세가지 중 하나의 행동을 한다. 주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다. 테스트케이스 수를 나타내는 자연수 T. 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고,\n둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다. 최대 이익이 얼마나 되는지 계산을 해 출력하는 문제.","title":"[BOJ] 11501 주식 with Python"},{"content":"\n📌 BOJ 2628 종이 자르기 💡 조건 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 칼로 잘라야하는 점선의 개수가 주어진다.\n셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다.\n가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 점선을 따라 이 종이를 칼로 자르려고 한다.\n가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다. 가장 큰 종이 조각의 넓이가 몇 ㎠인지를 구하는 프로그램 정렬 유형의 문제 🔖 예제 및 실행결과 예제 10 8 3 0 3 1 4 0 2 실행결과 30 ⌨️ 문제 풀이 가로와 세로 처음의 길이를 ga, se 리스트에 각각 넣은 후 시작한다. 가로인 경우와 세로인 경우를 나누어 각각의 리스트에 담는다. 담긴 가로, 세로 리스트를 정렬합니다. max_x, max_y 값을 정렬된 리스트의 가장 첫번째 값으로 초기화 합니다. 정렬된 가로, 세로 리스트를 순회하면서 잘린 종이의 크기가 가장 큰 값을 찾습니다.\nga[i + 1] - ga[i] 의 값이 더 크다면 갱신합니다.\nse[i + 1] - se[i] 의 값이 더 크다면 갱신합니다. ga * se 의 값을 출력합니다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) ga, se = [n], [m] for i in range(int(stdin.readline())): sep, line = map(int, stdin.readline().split()) if sep == 1: ga.append(line) else: se.append(line) ga.sort() se.sort() max_x, max_y = ga[0], se[0] for x in range(len(ga)-1): max_x = max(max_x, ga[x + 1] - ga[x]) for y in range(len(se)-1): max_y = max(max_y, se[y + 1] - se[y]) print(max_x * max_y) 💾 느낀점 잘린 종이의 크기를 어떻게 구할지 고민을 했습니다. 가로세로 리스트에 자르기 전의 종이 크기를 넣는 아이디어를 떠올리지 못했습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2628-%EC%A2%85%EC%9D%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0-with-python/","summary":"📌 BOJ 2628 종이 자르기 💡 조건 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 칼로 잘라야하는 점선의 개수가 주어진다.\n셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다.\n가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 점선을 따라 이 종이를 칼로 자르려고 한다.\n가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다.","title":"[BOJ] 2628 종이 자르기 with Python"},{"content":"\n📌 BOJ 9372 상근이의 여행 💡 조건 N개국을 여행할 상근이에게 가장 적은 비행기를 타고 여행할 수 있게 도와주자. 테스트 케이스의 수 T(T ≤ 100) 첫 번째 줄에는 국가의 수 N(2 ≤ N ≤ 1 000)과 비행기의 종류 M(1 ≤ M ≤ 10 000) 가 주어진다.\n이후 M개의 줄에 a와 b 쌍들이 입력된다. a와 b를 왕복하는 비행기가 있다는 것을 의미한다. (1 ≤ a, b ≤ n; a ≠ b)\n주어지는 비행 스케줄은 항상 연결 그래프를 이룬다. 그래프 이론, 유니온-파인드 유형의 문제 🔖 예제 및 실행결과 예제 2 3 3 1 2 2 3 1 3 5 4 2 1 2 3 4 3 4 5 실행결과 2 4 ⌨️ 문제 풀이 Union-Find 알고리즘을 사용하면 쉽게 풀 수 있습니다. parent 리스트에서 각 국은 본인의 번호를 가지고 있다.\n만약 상근이가 a국가에서 b 국가를 간다고 입력을 받았으면, a와 b 국가의 parent 를 찾고, 만약 서로 같지 않다면 같은 부모에 속하도록 변경한다. (2)번 작업을 마친 뒤, res + 1 res 를 출력한다. 🖥 소스 코드 from sys import stdin def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union_parent(a, b, parent): a = find_parent(parent, a) b = find_parent(parent, b) if a \u0026lt; b: parent[a] = b else: parent[b] = a for test_case in range(int(stdin.readline())): n, m = map(int, stdin.readline().split()) nations = [x for x in range(n + 1)] res = 0 for _ in range(m): a, b = map(int, stdin.readline().split()) if find_parent(nations, a) != find_parent(nations, b): union_parent(a, b, nations) res += 1 print(res) 💾 느낀점 공항이라는 문제를 풀었던 기억이 있고, 유니온-파인드 알고리즘을 이용해 시도해 봤었던 기억이 있습니다. 유파로 한번에 풀었던 문제입니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9372-%EC%83%81%EA%B7%BC%EC%9D%B4%EC%9D%98-%EC%97%AC%ED%96%89-with-python/","summary":"📌 BOJ 9372 상근이의 여행 💡 조건 N개국을 여행할 상근이에게 가장 적은 비행기를 타고 여행할 수 있게 도와주자. 테스트 케이스의 수 T(T ≤ 100) 첫 번째 줄에는 국가의 수 N(2 ≤ N ≤ 1 000)과 비행기의 종류 M(1 ≤ M ≤ 10 000) 가 주어진다.\n이후 M개의 줄에 a와 b 쌍들이 입력된다. a와 b를 왕복하는 비행기가 있다는 것을 의미한다. (1 ≤ a, b ≤ n; a ≠ b)\n주어지는 비행 스케줄은 항상 연결 그래프를 이룬다.","title":"[BOJ] 9372 상근이의 여행 with Python"},{"content":"\n📌 BOJ 2075 N번째 큰 수 💡 조건 N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데,\n모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. 표에 채워진 수는 모두 다르다. N(1 ≤ N ≤ 1,500) 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다. 자료구조 응용, 우선순위 큐 활용, 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 12 7 9 15 5 13 8 11 19 6 21 10 26 31 16 48 14 28 35 25 52 20 32 41 49 실행결과 35 ⌨️ 문제 풀이 q 라는 리스트를 만든다. 이 리스트는 표의 셀마다의 숫자를 넣을 것이며, 우선순위 큐로 사용된다. 각 숫자를 cnt 변수가 입력 받은 n과 같을 때까지 cnt + 1을 해주며 q 에 넣는다. 만약 q[0]의 값보다 방금 순회하고 있는 값이 크다면\n우선순위가 가장 높은 것을 꺼내고, 순회하고 있는 값을 넣는다. 모든 데이터를 순회했다면, q 를 정렬하고 가장 첫번째에 있는 값을 출력한다. 🖥 소스 코드 from sys import stdin import heapq n = int(stdin.readline()) q = [] cnt = 0 for _ in range(n): data = list(map(int, stdin.readline().split())) for j in data: if cnt != n: heapq.heappush(q, j) cnt += 1 else: if q[0] \u0026lt; j: heapq.heappop(q) heapq.heappush(q, j) q.sort() print(q[0]) 💾 느낀점 우선순위 큐의 성질을 이용하는 문제였습니다. 자료구조의 강의를 듣기 전, 우선순위큐는 대충 이런 느낌이지~ 라는 생각으로 풀었는데\n자료구조 강의를 보고 문제를 다시 보니 이런 꿀 골드문제가 없습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2075-n%EB%B2%88%EC%A7%B8-%ED%81%B0-%EC%88%98-with-python/","summary":"📌 BOJ 2075 N번째 큰 수 💡 조건 N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데,\n모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. 표에 채워진 수는 모두 다르다. N(1 ≤ N ≤ 1,500) 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다. 자료구조 응용, 우선순위 큐 활용, 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 12 7 9 15 5 13 8 11 19 6 21 10 26 31 16 48 14 28 35 25 52 20 32 41 49 실행결과 35 ⌨️ 문제 풀이 q 라는 리스트를 만든다.","title":"[BOJ] 2075 N번째 큰 수 with Python"},{"content":"\n📌 BOJ 2168 터널 위의 대각선 💡 조건 한 변의 길이가 1cm인 정사각형 모양의 타일이 있다.\n이 타일들을 가로가 xcm, 세로가 ycm인 직사각형 모양의 벽에 빈틈없이 붙였다. x와 y는 정수이다. 직사각형에 붙어 있는 x*y개의 타일 중에는 대각선이 그려진 타일도 있고, 그렇지 않은 타일도 있다. x*y개의 타일 중에서 대각선이 그려져 있는 타일의 개수를 구하는 문제. x와 y는 1,000,000,000 이하의 자연수 수학, 정수론, 유클리드 호제법유형의 문제 🔖 예제 및 실행결과 예제 8 12 실행결과 16 ⌨️ 문제 풀이 유클리드 호제법과 관련된 문제입니다. 대각선이 꼭지점을 지나가지 않는 직사각형의 개수는 x + y + 1\n대각선이 꼭지점을 지나가는 직사각형의 개수는 x + y - (점의 개수) - 1\n입니다. 점의 개수는 gcd(x, y) - 1개 입니다. 우리는 대각선이 꼭지점을 지나가는 직사각형의 개수를 구해야하기 때문에\n(2)번의 두번째 공식을 이용해야하며, x + y - gcd(x + y) 가 성립한다. x + y - gcd(x + y) 를 출력한다. 🖥 소스 코드 from sys import stdin from math import gcd x, y = map(int, stdin.readline().split()) print(x + y - gcd(x, y)) 💾 느낀점 수학적인 지식이 부족해 어려웠습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2168-%ED%84%B0%EB%84%90-%EC%9C%84%EC%9D%98-%EB%8C%80%EA%B0%81%EC%84%A0-with-python/","summary":"📌 BOJ 2168 터널 위의 대각선 💡 조건 한 변의 길이가 1cm인 정사각형 모양의 타일이 있다.\n이 타일들을 가로가 xcm, 세로가 ycm인 직사각형 모양의 벽에 빈틈없이 붙였다. x와 y는 정수이다. 직사각형에 붙어 있는 x*y개의 타일 중에는 대각선이 그려진 타일도 있고, 그렇지 않은 타일도 있다. x*y개의 타일 중에서 대각선이 그려져 있는 타일의 개수를 구하는 문제. x와 y는 1,000,000,000 이하의 자연수 수학, 정수론, 유클리드 호제법유형의 문제 🔖 예제 및 실행결과 예제 8 12 실행결과 16 ⌨️ 문제 풀이 유클리드 호제법과 관련된 문제입니다.","title":"[BOJ] 2168 터널 위의 대각선 with Python"},{"content":"\n📌 BOJ 15970 화살표 그리기 💡 조건 부분 점수가 있는 문제. 점들의 개수를 나타내는 정수 N N개의 줄 각각에는 점의 좌표와 색깔을 나타내는 두 정수 x와 y가 주어진다. 모든 점에서 시작하는 화살표들의 길이 합을 출력하는 문제. 각 점은 N개의 색깔 중 하나를 가진다. 각 점 p에 대해서, p에서 시작하는 직선 화살표를 이용해서 다른 점 q에 연결하려고 한다.\n여기서, 점 q는 p와 같은 색깔의 점들 중 p와 거리가 가장 가까운 점이어야 한다.\n만약 가장 가까운 점이 두 개 이상이면 아무거나 하나를 선택한다. 브루트포스유형의 문제 🔖 예제 및 실행결과 예제 5 0 1 1 2 3 1 4 2 5 1 실행결과 13 ⌨️ 문제 풀이 n을 입력 받은 뒤, n개의 점의 위치화 색의 번호를 입력 받는다. 입력 받은 각 점의 위치와 색의 번호는 arr 리스트에 저장한다. arr 리스트를 순회한다.\n점의 색깔이 0이 아닌 경우, solve(색, 위치) 에 넘겨준다. solve 함수 내부에서 다시 arr 리스트를 순회하면서, 점의 위치는 같지 않으나 색깔이 같은 점을 찾는다. 같은 색깔의 점이 있다면 가장 작은 점의 거리를 min_cost 에 저장하고 반환한다. 반환값을 res 에 더해 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] for _ in range(n): x, y = map(int, stdin.readline().split()) arr.append((x, y)) def solve(color, idx): min_cost = int(1e9) for t_idx, t_color in arr: if t_idx != idx and t_color == color: if abs(idx - t_idx) \u0026lt; min_cost: min_cost = abs(idx - t_idx) return min_cost res = 0 for idx, color in arr: if color != 0: res += solve(color, idx) print(res) 💾 느낀점 자칫 잘못생각하면 어렵게 느껴질 문제였던 것 같습니다. 입력받은 n의 크기를 보고 시간초과가 나지 않을 것이라고 판단하고 풀이해서 쉽게 풀었습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-15970-%ED%99%94%EC%82%B4%ED%91%9C-%EA%B7%B8%EB%A6%AC%EA%B8%B0-with-python/","summary":"📌 BOJ 15970 화살표 그리기 💡 조건 부분 점수가 있는 문제. 점들의 개수를 나타내는 정수 N N개의 줄 각각에는 점의 좌표와 색깔을 나타내는 두 정수 x와 y가 주어진다. 모든 점에서 시작하는 화살표들의 길이 합을 출력하는 문제. 각 점은 N개의 색깔 중 하나를 가진다. 각 점 p에 대해서, p에서 시작하는 직선 화살표를 이용해서 다른 점 q에 연결하려고 한다.\n여기서, 점 q는 p와 같은 색깔의 점들 중 p와 거리가 가장 가까운 점이어야 한다.","title":"[BOJ] 15970 화살표 그리기 with Python"},{"content":"\n📌 BOJ 19941 햄버거 분배 💡 조건 식탁의 길이가 N이다.\n사람들(P)은 자신의 위치에서 거리가 K 이하인 햄버거를 먹을 수 있다.\n1 \u0026lt;= N \u0026lt;= 20,000\n1 \u0026lt;= K \u0026lt;= 10 햄버거를 먹을 수 있는 사람의 최대 수를 구하는 프로그램을 작성. 그리디 알고리즘 유형의 문제 🖥 소스 코드 from sys import stdin n, k = map(int, stdin.readline().split()) arr = list(stdin.readline().rstrip()) res = 0 for i in range(n): if arr[i] == \u0026#39;P\u0026#39;: for j in range(i - k, i + k + 1): if -1 \u0026lt; j \u0026lt; n: if arr[j] == \u0026#39;H\u0026#39;: arr[j] = \u0026#39;-\u0026#39; res += 1 break print(res) 🔖 예제 및 실행결과 예제 20 1 HHPHPPHHPPHPPPHPHPHP 실행결과 8 ⌨️ 문제 풀이 식탁의 길이 N과 햄버거를 먹을 수 있는 거리 K 를 입력받는다. N 길이의 햄버거와 사람의 위치의 정보가 담긴 문자열을 입력받아 arr 리스트에 저장한다. n 만큼 arr 리스트를 순회하면서 arr[i]가 사람일 때, i - k 부터 i + k + 1 까지 순회한다\ni번째에 위치한 사람이 i - k 부터 i + k + 1 거리의 햄버거를 먹을 수 있기 때문에. 0 \u0026lt;= j \u0026lt; n 의 조건을 만족하고 arr[j]가 햄버거라면 arr의 해당 번호를 이미 먹은 표시로 - 로 변경하고 res + 1, break 💾 느낀점 그리디는 개념자체로는 이해가 쉬우나 막상 문제를 풀면 머리안에서 꼬여버리는 경우가 많다. 앞으로 그리디를 풀 때는 마음을 내려놓고 천천히 생각해보는 습관을 길러야겠다 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-19941-%ED%96%84%EB%B2%84%EA%B1%B0-%EB%B6%84%EB%B0%B0-with-python/","summary":"📌 BOJ 19941 햄버거 분배 💡 조건 식탁의 길이가 N이다.\n사람들(P)은 자신의 위치에서 거리가 K 이하인 햄버거를 먹을 수 있다.\n1 \u0026lt;= N \u0026lt;= 20,000\n1 \u0026lt;= K \u0026lt;= 10 햄버거를 먹을 수 있는 사람의 최대 수를 구하는 프로그램을 작성. 그리디 알고리즘 유형의 문제 🖥 소스 코드 from sys import stdin n, k = map(int, stdin.readline().split()) arr = list(stdin.readline().rstrip()) res = 0 for i in range(n): if arr[i] == \u0026#39;P\u0026#39;: for j in range(i - k, i + k + 1): if -1 \u0026lt; j \u0026lt; n: if arr[j] == \u0026#39;H\u0026#39;: arr[j] = \u0026#39;-\u0026#39; res += 1 break print(res) 🔖 예제 및 실행결과 예제 20 1 HHPHPPHHPPHPPPHPHPHP 실행결과 8 ⌨️ 문제 풀이 식탁의 길이 N과 햄버거를 먹을 수 있는 거리 K 를 입력받는다.","title":"[BOJ] 19941 햄버거 분배 with Python"},{"content":"\n📌 BOJ 11048 이동하기 💡 조건 N×M 크기의 미로 (1 ≤ N, M ≤ 1,000) (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동가능. 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하는 문제 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 3 1 2 3 6 5 4 7 8 9 12 11 10 실행결과 47 ⌨️ 문제 풀이 다이나믹 프로그래밍 유형의 문제입니다. 준규가 이동하면서 사탕을 모두 가져갈 수 있습니다. arr 리스트에 각 사탕이 놓여져 있는 숫자를 입력받습니다. candy 리스트는 준규가 챙긴 숫자의 최댓값을 저장할 리스트 입니다. candy[0][0] 은 arr[0][0] 이 되겠습니다.\n왜냐하면 준규는 (1, 1)에 위치하고 있기 때문입니다. 1부터 각각 n, m 만큼 이중 반복문으로 순회해줍니다.\ncandy[i][j] 의 숫자를 최댓값으로 갱신합니다. 준규가 움직일 수 있는 방향은 (0, 1), (1, 0), (1, 1) 이며\n이동 방향에 따라서 최댓값을 선택해서 candy를 갱신하고 (n - 1, m - 1) 인덱스에 있는 값을 출력합니다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [] candy = [[0] * m for _ in range(n)] res = 0 for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) candy[0][0] = arr[0][0] for i in range(1, m): candy[0][i] = arr[0][i] + candy[0][i - 1] for i in range(1, n): candy[i][0] = arr[i][0] + candy[i - 1][0] for i in range(1, n): for j in range(1, m): candy[i][j] = max(candy[i - 1][j], candy[i][j - 1], candy[i - 1][j - 1]) + arr[i][j] print(candy[n - 1][m - 1]) 💾 느낀점 실버 수준의 다이나믹프로그래밍 유형의 문제였는데, 이 유형을 풀어본 적이 있다면 풀 수 있는 문제였습니다. 그리디 문제도 이런 문제가 비슷하게 있는데, 입력받은 N과 M의 값을 보고 쎄한 느낌을 느끼고 그리디가 아닐 것이라는 생각을 했습니다. 점화식을 짜는게 아직 어렵습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11048-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 11048 이동하기 💡 조건 N×M 크기의 미로 (1 ≤ N, M ≤ 1,000) (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동가능. 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하는 문제 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 3 1 2 3 6 5 4 7 8 9 12 11 10 실행결과 47 ⌨️ 문제 풀이 다이나믹 프로그래밍 유형의 문제입니다.","title":"[BOJ] 11048 이동하기 with Python"},{"content":"\n📌 BOJ 13565 침투 💡 조건 격자의 크기를 나타내는 M (2 ≤ M ≤ 1,000) 과 N (2 ≤ N ≤ 1,000) M줄에 걸쳐서, N개의 0 또는 1 이 공백 없이 주어진다. 0은 전류가 잘 통하는 흰색, 1은 전류가 통하지 않는 검은색 격자임을 뜻한다. 맨 윗줄에서 받은 전기가 맨 밑 줄까지 갈 수 있다면 True, 아니면 False BFS 유형의 문제 🔖 예제 및 실행결과 예제 5 6 010101 010000 011101 100011 001011 실행결과 NO ⌨️ 문제 풀이 전류판을 board 리스트에 입력받아 저장합니다.\n방문처리를 할 visited 를 set() 자료형으로 생성합니다. bfs 함수는 너비우선탐색의 로직을 기본적으로만 구현한 형태입니다.\n상하좌우로 움직이면서 큐에 다음 이동할 좌표를 넣으며, 이동할 수 있는 좌표를 큐에 넣었을 땐 visited 에 넣어줍니다.\n만약 n - 1 과 현재 큐에서 뽑은 x 좌표의 값이 같다면 맨 밑으로 전류가 전달 된 것이니 true 를 반환합니다.\n아니라면 None 이 반환됩니다. 가장 윗줄을 볼 것이기 때문에 m만큼 순회를 시작합니다.(j)\nborad[0][i] 가 0이고 (0, j) 좌표가 이미 검사한 좌표가 아니라면 bfs에 넣습니다. bfs의 결과 값이 true가 반환되었다면 res_tf 를 true로 갱신하고 순회를 종료합니다. res_tf 가 true 라면 YES, 아니라면 NO 를 출력합니다 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) board = [] visited = set() for _ in range(n): board.append(list(map(int, list(stdin.readline().rstrip())))) dx, dy = [0, 0, -1, 1], [1, -1, 0, 0] res_tf = False def bfs(x, y): q = deque() q.append((x, y)) visited.add((x, y)) while q: x, y = q.popleft() if x == n - 1: return True for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m and (nx, ny) not in visited: if board[nx][ny] == 0: q.append((nx, ny)) visited.add((nx, ny)) for j in range(m): if board[0][j] == 0 and (0, j) not in visited: if bfs(0, j) is True: res_tf = True break print(\u0026#39;YES\u0026#39;) if res_tf else print(\u0026#39;NO\u0026#39;) 💾 느낀점 간단한 너비우선탐색의 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-13565-%EC%B9%A8%ED%88%AC-with-python/","summary":"📌 BOJ 13565 침투 💡 조건 격자의 크기를 나타내는 M (2 ≤ M ≤ 1,000) 과 N (2 ≤ N ≤ 1,000) M줄에 걸쳐서, N개의 0 또는 1 이 공백 없이 주어진다. 0은 전류가 잘 통하는 흰색, 1은 전류가 통하지 않는 검은색 격자임을 뜻한다. 맨 윗줄에서 받은 전기가 맨 밑 줄까지 갈 수 있다면 True, 아니면 False BFS 유형의 문제 🔖 예제 및 실행결과 예제 5 6 010101 010000 011101 100011 001011 실행결과 NO ⌨️ 문제 풀이 전류판을 board 리스트에 입력받아 저장합니다.","title":"[BOJ] 13565 침투 with Python"},{"content":"\n📌 BOJ 2477 참외밭 💡 조건 m2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1 ≤ K ≤ 20) 참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여\n반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다. 참외밭은 ㄱ-자 모양이거나 ㄱ-자를 90도, 180도, 270도 회전한 모양(┏, ┗, ┛ 모양)의 육각형이다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 7 4 50 2 160 3 30 1 60 3 20 1 100 실행결과 47600 ⌨️ 문제 풀이 6개의 방향과 변의 길이를 각각 direction, length 라는 변수에 입력받는다\n동시에, 변의 길이는 nums 리스트에 저장해주고, direction이 1 이거나 2 일 때 x 리스트에, 아닐 경우에는 y 리스트에 저장한다. x 축으로 움직이는 변의 길이 중 가장 긴 것을 max_x 에 저장한다.\ny 축으로 움직이는 변의 길이 중 가장 긴 것을 max_y 에 저장한다. (2)에서 구한 max_x, max_y 값이 x 리스트, y 리스트에서 인덱스 값이 몇인지 구한다. 가장 긴 가로변(xi) 양측에 있는 가로 변의 길이 의 차이가 전체 사각형 길이에서 내가 빼줄 사각형의 가로 길이\n만약 xi + i 가 6보다 크거나 같으면 nums[xi-1] - nums[0] 가장 긴 세로변(xi) 양측에 있는 세로 변의 길이 의 차이가 전체 사각형 길이에서 내가 빼줄 사각형의 세로 길이\n만약 yi + i 가 6보다 크거나 같으면 nums[yi-1] - nums[0] 사각형 최대 넓이 - 작은 사각형의 넓이를 구한다. 사각형 최대 넓이 : max_x * max_y 작은 사각형 넓이 : x * y 면적 당 참외의 개수를 출력해야하니, (6)에서 구한 면적에 * n 을 해준 값을 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) nums = [] x, y = [], [] for _ in range(6): direction, length = map(int, stdin.readline().split()) nums.append(length) if direction == 1 or direction == 2: x.append(length) else: y.append(length) max_x = max(x) max_y = max(y) xi = nums.index(max_x) yi = nums.index(max_y) if xi + 1 \u0026gt;= 6: x = abs(nums[xi - 1] - nums[0]) else: x = abs(nums[xi - 1] - nums[xi + 1]) if yi + 1 \u0026gt;= 6: y = abs(nums[yi - 1] - nums[0]) else: y = abs(nums[yi - 1] - nums[yi + 1]) print(((max_x * max_y) - (x * y)) * n) 💾 느낀점 문제 풀이에 써놓은 4, 5번 을 떠올리지 못해서 헤맸던 문제였다. 블로그를 쓰려고 다시 보는데 또 헷갈려서 다시 풀었다. 이런 수학적인 사고를 하는 문제, DP 문제는 아직도 어렵다. 연습만이 살길이다. 다시 한 번 쓰면서 생각해보고 풀어서 다행이라고 생각한다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2477-%EC%B0%B8%EC%99%B8%EB%B0%AD-with-python/","summary":"📌 BOJ 2477 참외밭 💡 조건 m2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1 ≤ K ≤ 20) 참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여\n반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다. 참외밭은 ㄱ-자 모양이거나 ㄱ-자를 90도, 180도, 270도 회전한 모양(┏, ┗, ┛ 모양)의 육각형이다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 7 4 50 2 160 3 30 1 60 3 20 1 100 실행결과 47600 ⌨️ 문제 풀이 6개의 방향과 변의 길이를 각각 direction, length 라는 변수에 입력받는다","title":"[BOJ] 2477 참외밭 with Python"},{"content":"\n📌 BOJ 9663 N-Queen 💡 조건 N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제. 1 \u0026lt;= N \u0026lt; 15 브루트포스, 백트래킹 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 8 실행결과 92 ⌨️ 문제 풀이 퀸은 각 줄마다 반드시 하나씩 들어가야한다.\n퀸이 있는 자리 기준으로 대각선, 세로선에는 다른 퀸이 존재할 수 없다.\n퀸의 좌표를 하나하나 확인하면서 문제를 해결하려고 하면 시간초과가 난다.\ndfs 함수에서 퀸을 놓은 개수가 n개가 되었으면 res + 1 후 return한다.\n(2)번의 기준에 따라, a는 세로줄, b, c는 대각선을 체크해주는 리스트이다.\nn의 길이만큼 순회하면서 a, b, c 리스트의 인덱스에 해당하는 값이 하나라도 True 일 경우\n퀸을 놓지 못하는 자리이기 때문에 continue\na, b, c 리스트의 인덱스에 해당하는 값이 모두 False 인 경우, 모두 True 로 갱신한 뒤 dfs(x + 1) 재귀호출\n빠져나온 후에는 백트래킹을 위해 a, b, c 리스트의 인덱스에 해당하는 부부을 False로 갱신\n🖥 소스 코드 from sys import stdin a, b, c = [False for _ in range(15)], [False for _ in range(30)], [False for _ in range(30)] n = int(stdin.readline()) res = 0 def dfs(x): global res if x == n: res += 1 return for y in range(n): if a[y] or b[x + y] or c[x + (n - y)]: continue a[y] = True b[x + y] = True c[x + (n - y)] = True dfs(x + 1) a[y] = False b[x + y] = False c[x + (n - y)] = False dfs(0) print(res) 💾 느낀점 백트래킹의 대표적인 문제라고 하지만, 대표적으로 어려운 문제라고 하는게 맞는 것 같다. 대각선과 세로의 각 좌표를 일일히 검사하려고 해서 시간초과를 피하지 못했다. 풀이를 보고 일차원 리스트를 세 개 만들어 검사하는 것을 보고, 놀랐던 기억이 있다. 문제를 포스팅하면서 다시 한 번 풀이를 생각해보는 것이 큰 도움이 되었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9663-n-queen-with-python/","summary":"📌 BOJ 9663 N-Queen 💡 조건 N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제. 1 \u0026lt;= N \u0026lt; 15 브루트포스, 백트래킹 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 8 실행결과 92 ⌨️ 문제 풀이 퀸은 각 줄마다 반드시 하나씩 들어가야한다.\n퀸이 있는 자리 기준으로 대각선, 세로선에는 다른 퀸이 존재할 수 없다.\n퀸의 좌표를 하나하나 확인하면서 문제를 해결하려고 하면 시간초과가 난다.\ndfs 함수에서 퀸을 놓은 개수가 n개가 되었으면 res + 1 후 return한다.","title":"[BOJ] 9663 N-Queen with Python"},{"content":"\n📌 BOJ 1759 암호 만들기 💡 조건 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과\n최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것.\n즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성.\n각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 문자들은 알파벳 소문자이며, 중복되는 것은 없다. 브루트포스, 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 4 6 a t c i s w 실행결과 acis acit aciw acst acsw actw aist aisw aitw astw cist cisw citw istw ⌨️ 문제 풀이 L, C 를 입력받고, C 개의 암호로 사용되었을 법한 문자를 리스트로 입력받는다. C 개의 암호로 사용되었을 법한 문자를 순회하면서, 모음 (a, e, i, o, u) 가 있는지 확인하여\nmo_um 리스트에 저장한다. 결과를 저장할 res 변수를 중복을 방지하기 위해 set() 자료형으로 생성한다. combinations 함수를 사용해 l의 길이로 된 조합을 만든다. set() 으로 감싸서 중복을 제거해준다. length 변수에 l을 저장해주고, 만들어진 조합을 순회한다.(i)\nmo_um을 순회하면서 i에 해당 모음이 있는지 확인하고, 있다면 length - 1 해준다. 암호는 최소 한 개의 모음을 가지고 있고, 두 개 이상의 자음을 가지고 있어야 한다.\nlength 가 2보다 작거나 l과 같을 경우 continue 해주고, 아니라면 res에 저장한다. res 를 한줄씩 출력한다. 🖥 소스 코드 from sys import stdin from itertools import combinations mo_um = [] l, c = map(int, stdin.readline().split()) alpha = list(stdin.readline().rstrip().split()) for i in alpha: if i in (\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;): mo_um.append(i) res = set() for i in list(set(combinations(alpha, l))): length = l for k in mo_um: if k in i: length -= 1 if length \u0026lt; 2 or length == l: continue else: res.add(tuple(sorted(list(i)))) for i in list(sorted(res)): print(\u0026#39;\u0026#39;.join(i)) 💾 느낀점 약 7회 시도 끝에 정답을 맞췄습니다.\n조건문이 잘못되어 틀렸습니다. length 변수를 만들어 조건을 사용할 생각을 하지 못해서 틀린 경우가 많았습니다. 다른 골드 난이도보다는 조금 쉬운 난이도의 문제였던 것 같습니다. 브루트포스, 백트래킹 문제를 더 많이 풀어보고 경험해봐야할 것 같습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1759-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-with-python/","summary":"📌 BOJ 1759 암호 만들기 💡 조건 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과\n최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것.\n즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성.\n각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력 두 정수 L, C가 주어진다.","title":"[BOJ] 1759 암호 만들기 with Python"},{"content":"\n📌 BOJ 2422 한윤정이 이탈리아에 가서 아이스크림을 사먹는데 💡 조건 아이스크림 가게에는 N종류의 아이스크림이 있다.\n모든 아이스크림은 1부터 N까지 번호가 매겨져있다.\n어떤 종류의 아이스크림을 함께먹으면, 맛이 아주 형편없어진다. 정수 N과 M이 주어진다. (1 ≤ N ≤ 200, 0 ≤ M ≤ 10,000)\nN은 아이스크림 종류의 수이고, M은 섞어먹으면 안 되는 조합의 개수이다. 같은 조합은 두 번 이상 나오지 않는다. 브루트포스 알고리즘, 그래프 이론유형의 문제 🔖 예제 및 실행결과 예제 5 3 1 2 3 4 1 3 실행결과 3 ⌨️ 문제 풀이 저는 브루트포스 알고리즘 보다 그래프 이론으로 풀이하는게 쉬웠습니다. 그래프로 사용할 nope dict 자료형 변수를 생성합니다.\n키 값은 각 아이스크림의 번호이며, value는 set()으로 설정했습니다.\n아이스크림의 번호가 매겨져 있는 ice_cream set() 자료형 변수를 생성합니다. 섞이면 안되는 각 아이스크림의 번호를 입력받아 처리를 해줍니다.\na 와 b 가 섞이면 안되는 조합이라면, nope[a]에 b를 넣어주고, nope[b]에 a 를 넣어줍니다. 1번부터 N번까지 아이스크림에서 세가지 조합을 찾아야하기에, combinations 함수를 사용하여 조합을 만들어줍니다.\n중복방지를 위해서 set()으로 둘러싸주고 순회를 시작합니다. 조합으로 선택된 세 개의 번호를 가진 아이스크림을 nope 자료구조에 키값으로 넣었을 때, 번호가 해당하는 곳에 없다면\n섞여도 되는 조합이기에 결과를 저장할 res 변수에 +1 을 해줍니다.\ndict 자료형에 섞이면 안되는 조합을 양방향으로 저장해두었기에, nope[x] 에서 x의 값은 소스코드마다 달라질 수 있습니다. res를 출력합니다. 🖥 소스 코드 from sys import stdin from itertools import combinations n, m = map(int, stdin.readline().split()) ice_cream = set(x for x in range(1, n + 1)) nope = {x: set() for x in range(1, n + 1)} for _ in range(m): a, b = map(int, stdin.readline().split()) nope[a].add(b) nope[b].add(a) res = 0 for comb in list(set(combinations(ice_cream, 3))): if comb[1] not in nope[comb[0]] and comb[2] not in nope[comb[0]] and comb[1] not in nope[comb[2]]: res += 1 print(res) 💾 느낀점 해시맵 자료구조(dict) 를 통해서 문제해결을 할 때 기분이 좋습니다. 브루트포스 알고리즘이라고 되어있는데, 사실 그래프 이론 문제로 들어가야하는게 아닌가 싶습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2422-%ED%95%9C%EC%9C%A4%EC%A0%95%EC%9D%B4-%EC%9D%B4%ED%83%88%EB%A6%AC%EC%95%84%EC%97%90-%EA%B0%80%EC%84%9C-%EC%95%84%EC%9D%B4%EC%8A%A4%ED%81%AC%EB%A6%BC%EC%9D%84-%EC%82%AC%EB%A8%B9%EB%8A%94%EB%8D%B0-with-python/","summary":"📌 BOJ 2422 한윤정이 이탈리아에 가서 아이스크림을 사먹는데 💡 조건 아이스크림 가게에는 N종류의 아이스크림이 있다.\n모든 아이스크림은 1부터 N까지 번호가 매겨져있다.\n어떤 종류의 아이스크림을 함께먹으면, 맛이 아주 형편없어진다. 정수 N과 M이 주어진다. (1 ≤ N ≤ 200, 0 ≤ M ≤ 10,000)\nN은 아이스크림 종류의 수이고, M은 섞어먹으면 안 되는 조합의 개수이다. 같은 조합은 두 번 이상 나오지 않는다. 브루트포스 알고리즘, 그래프 이론유형의 문제 🔖 예제 및 실행결과 예제 5 3 1 2 3 4 1 3 실행결과 3 ⌨️ 문제 풀이 저는 브루트포스 알고리즘 보다 그래프 이론으로 풀이하는게 쉬웠습니다.","title":"[BOJ] 2422 한윤정이 이탈리아에 가서 아이스크림을 사먹는데 with Python"},{"content":"\n📌 BOJ 11655 ROT13 💡 조건 ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.\n\u0026ldquo;Baekjoon Online Judge\u0026quot;를 ROT13으로 암호화하면 \u0026ldquo;Onrxwbba Bayvar Whqtr\u0026quot;가 된다.\nROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. S를 ROT13으로 암호화한 내용을 출력하는 문제 구현, 문자열유형의 문제 🔖 예제 및 실행결과 예제 Baekjoon Online Judge 실행결과 Onrxwbba Bayvar Whqtr ⌨️ 문제 풀이 각 문자열을 순회하면서 아스키코드에 해당하는 숫자를 대문자일 경우와 소문자일 경우를 나눠 처리를 하고\n각 아스키코드 숫자에 +13을 해주어 바꾸어주고 출력하면 된다. 만약 아스키코드 숫자가 알파벳 문자 범위를 넘어간다면, -26을 해주어 다시 그 범위안으로 들어가주게 한 뒤 출력한다. 🖥 소스 코드 from sys import stdin for i in list(stdin.readline().rstrip()): if i == \u0026#39; \u0026#39;: print(\u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) elif i.isnumeric(): print(i, end=\u0026#39;\u0026#39;) else: if i.isupper(): temp = ord(i) + 13 if temp \u0026gt; 90: print(chr(temp - 26), end=\u0026#39;\u0026#39;) else: print(chr(temp), end=\u0026#39;\u0026#39;) else: temp = ord(i) + 13 if temp \u0026gt; 122: print(chr(temp - 26), end=\u0026#39;\u0026#39;) else: print(chr(temp), end=\u0026#39;\u0026#39;) 💾 느낀점 재미있는 문자열, 구현 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11655-rot13-with-python/","summary":"📌 BOJ 11655 ROT13 💡 조건 ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.\n\u0026ldquo;Baekjoon Online Judge\u0026quot;를 ROT13으로 암호화하면 \u0026ldquo;Onrxwbba Bayvar Whqtr\u0026quot;가 된다.\nROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. S를 ROT13으로 암호화한 내용을 출력하는 문제 구현, 문자열유형의 문제 🔖 예제 및 실행결과 예제 Baekjoon Online Judge 실행결과 Onrxwbba Bayvar Whqtr ⌨️ 문제 풀이 각 문자열을 순회하면서 아스키코드에 해당하는 숫자를 대문자일 경우와 소문자일 경우를 나눠 처리를 하고","title":"[BOJ] 11655 ROT13 with Python"},{"content":"\n📌 BOJ 1236 성 지키기 💡 조건 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다.\n영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다. 성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 문제 0 \u0026lt;= N, M \u0026lt;= 50 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다. 구현, 시뮬레이션유형의 문제 🔖 예제 및 실행결과 예제 4 4 .... .... .... .... 실행결과 4 ⌨️ 문제 풀이 각 열과 행에 모두 경비원이 있었으면 좋겠다고 생각을 했으니, 열과 행에 경비원이 있는지 체크할 col, row 리스트를 생성한다.\n이 리스트는 각 원소를 False 로 초기화 한 상태로 생성한다. 경비원의 값을 저장할 r1, r2 변수를 생성한다. 성의 크기만큼 순회하면서 (i, j) 에 X 가 있을 경우, row[i], col[j] 를 각각 True로 갱신한다. 각 성의 가로 크기(i -\u0026gt; n), 세로 크기(j -\u0026gt; m)만큼 순회하면서 row[i], col[j] 가 각각 False 일 경우\nr1, r2 에 각각 + 1을 더해준다. r1, r2 중 가장 큰 값을 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [] col = [False] * m row = [False] * n r1, r2 = 0, 0 for i in range(n): data = list(stdin.readline().rstrip()) arr.append(data) for i in range(n): for j in range(m): if arr[i][j] == \u0026#39;X\u0026#39;: row[i] = True col[j] = True for i in range(n): if not row[i]: r1 += 1 for j in range(m): if not col[j]: r2 += 1 print(max(r1, r2)) 💾 느낀점 구현 문제이지만, 어디에 경비원이 있어야 각 열과 행이 모두 True 값을 가지는지 생각하는 것이 헷갈렸다. 브론즈라고 했지만, 구현은 역시 그 이상의 티어로 봐야하는 것 같다. 논리적인 사고력이 약하다는 것을 다시 한 번 느끼게 해주는 문제였다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1236-%EC%84%B1-%EC%A7%80%ED%82%A4%EA%B8%B0-with-python/","summary":"📌 BOJ 1236 성 지키기 💡 조건 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다.\n영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다. 성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 문제 0 \u0026lt;= N, M \u0026lt;= 50 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다. 구현, 시뮬레이션유형의 문제 🔖 예제 및 실행결과 예제 4 4 .","title":"[BOJ] 1236 성 지키기 with Python"},{"content":"\n📌 BOJ 14248 점프 점프 💡 조건 돌다리의 돌 개수 n이 주어진다.(1≤n≤100,000) 그 위치에서 점프할 수 있는 거리 Ai (1≤Ai≤100,000) 현재위치에서 다른 돌을 적절히 밟아 해당하는 위치로 이동이 가능하다고 할 때, 영우가 방문 가능한 돌들의 개수를 구하는 문제. 탐색 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 5 1 4 2 2 1 3 실행결과 5 ⌨️ 문제 풀이 입력으로 받은 점프할 수 있는 거리를 그래프에 넣어준다.\n인덱스 에러를 방지하기 위해 arr 리스트의 크기는 n + 1로 해준다. (1) 번 작업에서, 현재 위치에서 이동할 수 있는 거리를 빼거나 더했을 때, 리스트 인덱스의 범위인지 확인하고 넣는다. BFS 알고리즘을 이용하여 방문처리 배열을 만들고 방문해준다. 정답은 영우가 방문 할 수 있는 돌들의 개수이니, visited 리스트의 길이 + 1을 출력한다. 영우가 처음 밟은 돌도 포함이니까 + 1 해준다.\n시작하는 돌을 visited에 먼저 넣어주고 시작했다면 + 1을 굳이 하지 않아도 된다. 🖥 소스 코드 from sys import stdin from collections import deque n = int(stdin.readline()) arr = [0] + list(map(int, stdin.readline().split())) graph = [[] for _ in range(n + 1)] s = int(stdin.readline()) for i in range(1, n + 1): if 0 \u0026lt; i + arr[i] \u0026lt; n + 1: graph[i].append(i + arr[i]) if 0 \u0026lt; i - arr[i] \u0026lt; n + 1: graph[i].append(i - arr[i]) def solve(s): q = deque() q.append(s) visited = set() while q: now = q.popleft() for x in graph[now]: if x not in visited: visited.add(x) q.append(x) return len(visited) print(solve(s) + 1) 💾 느낀점 재미있는 BFS 문제였습니다. 개굴 개굴 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14248-%EC%A0%90%ED%94%84-%EC%A0%90%ED%94%84-with-python/","summary":"📌 BOJ 14248 점프 점프 💡 조건 돌다리의 돌 개수 n이 주어진다.(1≤n≤100,000) 그 위치에서 점프할 수 있는 거리 Ai (1≤Ai≤100,000) 현재위치에서 다른 돌을 적절히 밟아 해당하는 위치로 이동이 가능하다고 할 때, 영우가 방문 가능한 돌들의 개수를 구하는 문제. 탐색 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 5 1 4 2 2 1 3 실행결과 5 ⌨️ 문제 풀이 입력으로 받은 점프할 수 있는 거리를 그래프에 넣어준다.\n인덱스 에러를 방지하기 위해 arr 리스트의 크기는 n + 1로 해준다.","title":"[BOJ] 14248 점프 점프 with Python"},{"content":"\n📌 BOJ 6603 로또 💡 조건 집합 S에서 K개의 숫자를 골라 뽑아 낼 수 있는 경우의 수를 모두 출력하는 문제 입력이 여러개 들어오며, 0이 들어왔을 때 종료 백트래킹, 재귀, 조합유형의 문제 🔖 예제 및 실행결과 예제 7 1 2 3 4 5 6 7 8 1 2 3 5 8 13 21 34 0 실행결과 1 2 3 4 5 6 1 2 3 4 5 7 1 2 3 4 6 7 1 2 3 5 6 7 1 2 4 5 6 7 1 3 4 5 6 7 2 3 4 5 6 7 1 2 3 5 8 13 1 2 3 5 8 21 1 2 3 5 8 34 1 2 3 5 13 21 1 2 3 5 13 34 1 2 3 5 21 34 1 2 3 8 13 21 1 2 3 8 13 34 1 2 3 8 21 34 1 2 3 13 21 34 1 2 5 8 13 21 1 2 5 8 13 34 1 2 5 8 21 34 1 2 5 13 21 34 1 2 8 13 21 34 1 3 5 8 13 21 1 3 5 8 13 34 1 3 5 8 21 34 1 3 5 13 21 34 1 3 8 13 21 34 1 5 8 13 21 34 2 3 5 8 13 21 2 3 5 8 13 34 2 3 5 8 21 34 2 3 5 13 21 34 2 3 8 13 21 34 2 5 8 13 21 34 3 5 8 13 21 34 ⌨️ 문제 풀이 조합을 이용하여 S 수열에 있는 K개의 숫자를 뽑아낸 조합의 경우의 수를 구하되, 가능한 조합을 모두 출력하는 문제. combinations 를 사용하여 조합을 모두 뽑아내고, res 라는 리스트에 넣어 출력했다. 🖥 소스 코드 from sys import stdin from itertools import combinations while 1: data = list(map(int, stdin.readline().split())) if len(data) == 1 and data[0] == 0: break else: a, arr = data[0], data[1:] res = [] for x in list(set(combinations(arr, 6))): if len(set(x)) == 6: temp = sorted(list(x)) if temp not in res: res.append(temp) for x in sorted(list(res)): print(*x) print() 💾 느낀점 백트래킹 문제는 재귀로 풀어보는 것이 도움이 된다. N과 M 시리즈를 풀면서 재귀로 백트래킹을 연습하는 것도 좋을 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-6603-%EB%A1%9C%EB%98%90-with-python/","summary":"📌 BOJ 6603 로또 💡 조건 집합 S에서 K개의 숫자를 골라 뽑아 낼 수 있는 경우의 수를 모두 출력하는 문제 입력이 여러개 들어오며, 0이 들어왔을 때 종료 백트래킹, 재귀, 조합유형의 문제 🔖 예제 및 실행결과 예제 7 1 2 3 4 5 6 7 8 1 2 3 5 8 13 21 34 0 실행결과 1 2 3 4 5 6 1 2 3 4 5 7 1 2 3 4 6 7 1 2 3 5 6 7 1 2 4 5 6 7 1 3 4 5 6 7 2 3 4 5 6 7 1 2 3 5 8 13 1 2 3 5 8 21 1 2 3 5 8 34 1 2 3 5 13 21 1 2 3 5 13 34 1 2 3 5 21 34 1 2 3 8 13 21 1 2 3 8 13 34 1 2 3 8 21 34 1 2 3 13 21 34 1 2 5 8 13 21 1 2 5 8 13 34 1 2 5 8 21 34 1 2 5 13 21 34 1 2 8 13 21 34 1 3 5 8 13 21 1 3 5 8 13 34 1 3 5 8 21 34 1 3 5 13 21 34 1 3 8 13 21 34 1 5 8 13 21 34 2 3 5 8 13 21 2 3 5 8 13 34 2 3 5 8 21 34 2 3 5 13 21 34 2 3 8 13 21 34 2 5 8 13 21 34 3 5 8 13 21 34 ⌨️ 문제 풀이 조합을 이용하여 S 수열에 있는 K개의 숫자를 뽑아낸 조합의 경우의 수를 구하되, 가능한 조합을 모두 출력하는 문제.","title":"[BOJ] 6603 로또 with Python"},{"content":"\n📌 BOJ 2535 아시아 정보올림피아드 💡 조건 대회참가 학생 수를 나타내는 N, 3 ≤ N ≤ 100. N개의 줄에는 각 줄마다 한 학생의 소속 국가 번호, 학생 번호, 그리고 성적이 하나의 빈칸을 사이에 두고 주어진다. 국가 번호는 1부터 순서대로 하나의 정수로 주어지며, 각 학생번호는 각 나라별로 1부터 순서대로 하나의 정수로 주어진다. 점수는 0 이상 1000 이하의 정수이고, 동점자는 없다고 가정한다. 정렬, 구현유형의 문제. 🔖 예제 및 실행결과 예제 9 1 1 230 1 2 210 1 3 205 2 1 100 2 2 150 3 1 175 3 2 190 3 3 180 3 4 195 실행결과 1 1 1 2 3 4 ⌨️ 문제 풀이 입력을 받아 리스트에 저장할 때, 점수, 참가국, 학생번호 순으로 저장한다.\n이후, sort 를 해주면 점수순으로 정렬이 된다. 수상을 한 이력을 담을 h 딕셔너리 변수를 하나만들고, 정렬된 grade 리스트를 순회한다.\ngrade 리스트를 순회하면서\n만약 해당 국가 (grade[i][1])가 수상 이력이 없으면 수상한 국가의 수 cnt + 1\n수상 이력에 grade[i][1] 를 추가하고 값을 1로 한다. 만약 해당 국가 (grade[i][1])가 수상 이력이 있고, 수상 이력의 수가 2 미만이면 수상한 국가의 수 cnt + 1\n수상 이력에 해당 국가에 + 1 한다. 만약 수상한 국가가 3이라면 반복문을 멈춘다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) grade = [] for i in range(n): a,b,c = map(int, stdin.readline().split()) grade.append((c, a, b)) h = {} grade.sort(reverse=True) cnt = 0 for i in range(n): if cnt == 3: break if grade[i][1] not in h: print(*grade[i][1:]) cnt += 1 h[grade[i][1]] = 1 else: if h[grade[i][1]] \u0026lt; 2: print(*grade[i][1:]) h[grade[i][1]] += 1 cnt += 1 else: continue 💾 느낀점 정렬을 하고 약간의 조건문만 추가해주면 쉽게 풀 수 있는 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2535-%EC%95%84%EC%8B%9C%EC%95%84-%EC%A0%95%EB%B3%B4%EC%98%AC%EB%A6%BC%ED%94%BC%EC%95%84%EB%93%9C-with-python/","summary":"📌 BOJ 2535 아시아 정보올림피아드 💡 조건 대회참가 학생 수를 나타내는 N, 3 ≤ N ≤ 100. N개의 줄에는 각 줄마다 한 학생의 소속 국가 번호, 학생 번호, 그리고 성적이 하나의 빈칸을 사이에 두고 주어진다. 국가 번호는 1부터 순서대로 하나의 정수로 주어지며, 각 학생번호는 각 나라별로 1부터 순서대로 하나의 정수로 주어진다. 점수는 0 이상 1000 이하의 정수이고, 동점자는 없다고 가정한다. 정렬, 구현유형의 문제. 🔖 예제 및 실행결과 예제 9 1 1 230 1 2 210 1 3 205 2 1 100 2 2 150 3 1 175 3 2 190 3 3 180 3 4 195 실행결과 1 1 1 2 3 4 ⌨️ 문제 풀이 입력을 받아 리스트에 저장할 때, 점수, 참가국, 학생번호 순으로 저장한다.","title":"[BOJ] 2535 아시아 정보올림피아드 with Python"},{"content":"\n📌 BOJ 1940 주몽 💡 조건 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 문제 정렬, 투 포인터 유형의 문제 🔖 예제 및 실행결과 예제 6 9 2 7 4 1 5 3 실행결과 2 ⌨️ 문제 풀이 정렬을 해서 투포인터를 사용해 문제를 푸는 것이 이 문제의 요점인 것 같다. 나는 파이썬 bisect 라이브러리의 bisect_left 를 써서 쉽게 풀수 있었다. 재료들의 각 고유번호를 입력받아 놓은 arr이라는 변수를 정렬하고 순회한다. (3)번을 통해 순회하는 값인 i가 있다.\n갑옷이 만들어지기 위한 값 m 에서 i를 뺀 값이 arr 리스트에 위치하고 있는지\nbisect_left 를 통해 이분탐색해준 결과를 f 변수에 저장한다.\nf 가 n 보다 작고, arr[f]가 i와 같지 않다면, i + f는 m이다. (4)에서 나온 결과 값이 참인지 확인하고, (arr[f], i) 의 쌍이 한번도 나온적 없는 조합이라면\nres + 1을 해주고, (arr[f], i), (i, arr[f]) 를 visited에 저장해 이미 나온 조합이라고 표시해둔다. (1)~(5) 과정을 거치고 난 후, res를 출력해준다. 🖥 소스 코드 from sys import stdin from bisect import bisect_left n = int(stdin.readline()) m = int(stdin.readline()) arr = sorted(list(map(int, stdin.readline().split()))) res = 0 visited = set() arr.sort() for i in arr: f = bisect_left(arr, m-i) if f \u0026lt; n and arr[f] != i: temp = arr[f] if temp + i == m and (temp, i) not in visited: visited.add((temp, i)) visited.add((i, temp)) res += 1 print(res) 💾 느낀점 투포인터로 풀면 훨씬 쉬웠을 것 같은데, 3달 전의 나는 왜 bisect 라이브러리를 사용했을까? 투포인터를 연습하기 매우 좋은 문제인 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1940-%EC%A3%BC%EB%AA%BD-with-python/","summary":"📌 BOJ 1940 주몽 💡 조건 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 문제 정렬, 투 포인터 유형의 문제 🔖 예제 및 실행결과 예제 6 9 2 7 4 1 5 3 실행결과 2 ⌨️ 문제 풀이 정렬을 해서 투포인터를 사용해 문제를 푸는 것이 이 문제의 요점인 것 같다.","title":"[BOJ] 1940 주몽 with Python"},{"content":"\n📌 BOJ 1292 쉽게 푸는 문제 💡 조건 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고\n어느 일정한 구간을 주면 그 구간의 합을 구하는 문제 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다.\n수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다. 다이나믹 프로그래밍, 수학, 구현유형의 문제 🔖 예제 및 실행결과 예제 3 7 실행결과 15 ⌨️ 문제 풀이 리스트에 구간합에 대해 값을 저장하여 arr[m] - arr[n-1]을 하여 출력하면 된다. 구간합의 값을 가진 리스트 arr 에서는 arr[m] - arr[n-1]을 아래와 같이 말할 수 있다.\n(첫번째부터 m번째 숫자까지의 합) - (첫번째부터 n-1번째 숫자까지의 합)과 같다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [0, 1] for i in range(2, m + 1): for j in range(i): arr.append(arr[-1] + i) print(arr[m] - arr[n - 1]) 💾 느낀점 문제 제목대로 쉽게 푸는 문제였고, 매우 친절한 구간합 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1292-%EC%89%BD%EA%B2%8C-%ED%91%B8%EB%8A%94-%EB%AC%B8%EC%A0%9C-with-python/","summary":"📌 BOJ 1292 쉽게 푸는 문제 💡 조건 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고\n어느 일정한 구간을 주면 그 구간의 합을 구하는 문제 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다.\n수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다. 다이나믹 프로그래밍, 수학, 구현유형의 문제 🔖 예제 및 실행결과 예제 3 7 실행결과 15 ⌨️ 문제 풀이 리스트에 구간합에 대해 값을 저장하여 arr[m] - arr[n-1]을 하여 출력하면 된다.","title":"[BOJ] 1292 쉽게 푸는 문제 with Python"},{"content":"\n📌 BOJ 16234 인구 이동 💡 조건 N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다.\nN, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100) 인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다. 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다. 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 연합을 해체하고, 모든 국경선을 닫는다. 각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성해야한다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100) BFS 알고리즘, 구현유형의 문제 🔖 예제 및 실행결과 예제 2 20 50 50 30 30 40 실행결과 1 ⌨️ 문제 풀이 board 리스트에 각 국가의 인구수를 입력 받고, 인구 이동 횟수를 저장할 cnt 변수를 0으로 초기화. 인구 이동이 일어나지 않을 때까지 while 반복을 통해서 체크를 해줄 것. 인구 이동이 일어났을 때, 인구 이동 후의 인구 수와 인구 이동이 일어난 도시의 좌표를 담을 리스트 변수 tf를 생성한다. board 를 순회하면서, 각 좌표에서 연합이 될 수 있는 국가를 체크하여 반환된 값을 temp에 저장한다.\n만약, temp 가 False라면 인구이동이 일어나지 않은 것이다.\n반대로 False 가 아니라면 인구이동이 일어난 것이다. board 전체를 순회했음에도 인구이동이 일어나지 않아 tf가 비어있다면, 그대로 while 문 밖으로 나온다. tf가 비어있지 않다면, 인구이동 횟수(cnt)를 + 1 해준 뒤,\ntf 를 순차적으로 순회하면서, 연합끼리의 인구 이동을 한 좌표에 해당하는 인구 수로 board 값을 갱신한다. check() 함수의 로직은 아래와 같다. BFS 알고리즘을 이용하여 매개변수로 받은 좌표와 연합이 될 수 있는 모든 국가를 찾는다. 다음 이동하려는 좌표가 방문하지 않았어야하고,\n그 좌표에 해당하는 board의 값이 l \u0026lt;= 국경을 공유하는 국가들의 인구 차이 \u0026lt;= r 의 조건을 지켜야한다. 또한 (1), (2) 의 조건을 지킨 경우, 연합들의 각 인구수는 vals 리스트에 저장해 평균 인구수를 계산할 수 있게 한다. check 함수 내의 인구이동 판별 변수인 tf 에 인구이동을 했을 시, True 값을 저장한다. 🖥 소스 코드 from sys import stdin from collections import deque n, l, r = map(int, stdin.readline().split()) if l \u0026gt; r: l, r = r, l board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) dx, dy = [1, 0, 0, -1], [0, -1, 1, 0] def check(x, y): visited = set() q = deque() visited.add((x, y)) q.append((x, y, board[x][y])) vals = [board[x][y]] tf = False while q: x, y, cost = q.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; n: if l \u0026lt;= abs(cost - board[nx][ny]) \u0026lt;= r and (nx, ny) not in visited: visited.add((nx, ny)) q.append((nx, ny, board[nx][ny])) vals.append(board[nx][ny]) tf = True if not tf: return False else: res = int(sum(vals) / len(vals)) return [res, visited] cnt = 0 while 1: tf = [] for i in range(n): for j in range(n): temp = check(i, j) if temp is not False: tf.append(temp) if not tf: break else: cnt += 1 for val, visited in tf: for x, y in visited: board[x][y] = val print(cnt) 💾 느낀점 국경선을 공유하는 두 국가의 인구 차이 조건을 넣는 것에서 한번 헤맸다. 연합으로 구성된 국가들의 인구 평균 수를 구하는 방법에서 고민을 했었다. 모든 연합을 따로 구해서 연합끼리의 평균 인구 수로 갱신하는 부분이 한번에 이루어져야 한다. 하지만 (3)의 방식이 아닌 연합이 생길때마다 변경해주어 예제 결과도 다르게 나오는 대참사가 있었다. BFS 알고리즘 중에서도 조건이 꽤 있어서 구현이 조금 묻어나온 문제 같았고, 풀기 조금 힘이 들었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-16234-%EC%9D%B8%EA%B5%AC-%EC%9D%B4%EB%8F%99-with-python/","summary":"📌 BOJ 16234 인구 이동 💡 조건 N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다.\nN, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100) 인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.","title":"[BOJ] 16234 인구 이동 with Python"},{"content":"\n📌 BOJ 14500 테트로미노 💡 조건 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다. 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 해야한다. 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다. 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500) N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다.\n입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다. S의 문제 🔖 예제 및 실행결과 예제 5 5 1 2 3 4 5 5 4 3 2 1 2 3 4 5 6 6 5 4 3 2 1 2 1 2 1 실행결과 19 ⌨️ 문제 풀이 테트로미노가 될 수 있는 모든 경우의 좌표를 tetro 라는 딕셔너리에 저장한다. 종이의 크기와 종이에 써있는 숫자를 입력받아 각 변수 및 리스트에 저장한다. 각 테트로미노가 위치할 수 있는 모양에 대해서 순회하면서, 각 좌표에서 놓을 수 있는 테트로미노 모양이 가질 수 있는 값 중 최댓값을 구한다.\n테트로미노의 좌표는 tetro 라는 변수에서 이미 가지고 있기 때문에, 기준이 되는 좌표 (i, j)에서 놓을 수 있는지 없는지도 구분할 수 있다.\nres 라는 변수가 최종적으로 답을 출력할 변수, value 가 좌표 (i, j) 의 위치에서 놓을 수 있는 테트로미노 모양에서의 값을 의미한다. 각 테트로미노, 좌표값을 순회하고 갱신한 값 중 최댓값을 가지고 있는 res 를 출력한다. 🖥 소스 코드 from sys import stdin tetro = { # ㅁ 0: [[(0, 0), (0, 1), (1, 0), (1, 1)]], # ㄱ,ㄴ 1: [[(0, 0), (0, 1), (0, 2), (-1, 0)], [(0, 0), (0, 1), (0, 2), (1, 0)], [(0, 0), (0, 1), (0, 2), (1, 2)], [(0, 0), (0, 1), (0, 2), (-1, 2)], [(0, 0), (-1, 0), (-2, 0), (0, 1)], [(0, 0), (-1, 0), (-2, 0), (0, -1)], [(0, 0), (1, 0), (2, 0), (0, -1)], [(0, 0), (1, 0), (2, 0), (0, 1)]], # ㅡ, ㅣ 2: [[(0, 0), (0, 1), (0, 2), (0, 3)], [(0, 0), (1, 0), (2, 0), (3, 0)]], # ㅗ, ㅓ 3: [[(0, 0), (1, -1), (1, 0), (1, 1)], [(0, 0), (-1, -1), (-1, 0), (-1, 1)], [(0, 0), (0, 1), (-1, 1), (1, 1)], [(0, 0), (0, -1), (-1, -1), (1, -1)]], # ㄹ - = 4: [[(0, 0), (1, 0), (1, 1), (2, 1)], [(0, 0), (0, 1), (-1, 1), (-1, 2)], [(0, 0), (1, 0), (1, -1), (2, -1)], [(0, 0), (0, 1), (1, 1), (1, 2)]] } n, m = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) def get_value(x, y, blocks): global res for block in blocks: value = 0 for i, j in block: nx, ny = i + x, j + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: value += board[nx][ny] else: break res = max(res, value) res = -int(1e9) for x in range(5): blocks = tetro[x] for i in range(n): for j in range(m): get_value(i, j, blocks) print(res) 💾 느낀점 테트로미노 모양을 일일히 좌표로 정해두고 풀어야한다고 생각하지 못했다. (1)번과 같은 생각을 해야하는 문제가 아닌, 시작점부터 bfs로 테트로미노 모양을 계산해서 풀어야한다고 생각했다가 큰 코 다칠뻔했다. 테트로미노 모양을 좌표로 정해두고 나서는 그리 어려운 문제가 아니었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8-with-python/","summary":"📌 BOJ 14500 테트로미노 💡 조건 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다. 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 해야한다. 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다. 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500) N개의 줄에 종이에 쓰여 있는 수가 주어진다.","title":"[BOJ] 14500 테트로미노 with Python"},{"content":"\n📌 BOJ 15658 연산자 끼워넣기 (2) 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN\nN(2 ≤ N ≤ 11), (1 ≤ Ai ≤ 100) 입력 값중 셋째 줄에 4N보다 작거나 같은 4개의 정수가 주어지는데,\n차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다. 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다. 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 나눗셈은 정수 나눗셈으로 몫만 취한다. 또한 음수를 나눌 때에는 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾸어야 한다. 백트래킹, DFS 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 2 3 4 5 6 3 2 1 1 실행결과 72 -48 ⌨️ 문제 풀이 DFS 알고리즘과 백트래킹을 이용한 문제 풀이를 했다. DFS에 매개변수로 들어가는 val 의 값은 수열의 순서를 바꾸면 안되기 때문에 무슨 짓을 해도 수열[0] 의 값과 같다. DFS에 매개변수로 들어가는 num은 입력받은 수열의 index 1번부터 들어가면 된다. DFS가 종료되는 시점은 num 이라는 리스트가 비어있을 때이며 이 때, 최댓값과 최솟값을 갱신하면서 종료된다.\n최댓값은 -int(1e9), 최솟값은 int(1e9)이다. arr 리스트는 각각 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)의 개수이며, 입력으로 받는다. 만약 DFS가 넘겨받는 num 리스트가 비어있지 않다면, 반복문을 0부터 3까지 반복을 한다.\n반복하면서, 각 i 의 숫자에 따라 arr[i]의 값이 0보다 클 때, val 변수에 해당하는 연산을 해준 뒤, 재귀호출을 한다. 재귀호출을 할 때, num[1:] 을 매개변수로 넘겨주어 중복 계산을 방지한다.\n이렇게 재귀호출을 하게 되면 넘겨주는 리스트는 길이가 앞에서부터 하나씩 없어지게 되는데,\n재귀 호출 전, arr[i]를 -1 해주고 재귀 호출 후 +1 해준다. 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) n = int(stdin.readline()) n_num = list(map(int, stdin.readline().split())) arr = list(map(int, stdin.readline().split())) def dfs(num, val): global max_res, min_res if not num: max_res = max(val, max_res) min_res = min(val, min_res) return else: for i in range(4): if i == 0: if arr[i] \u0026gt; 0: arr[i] -= 1 dfs(num[1:], val + num[0]) arr[i] += 1 else: continue if i == 1: if arr[i] \u0026gt; 0: arr[i] -= 1 dfs(num[1:], val - num[0]) arr[i] += 1 else: continue if i == 2: if arr[i] \u0026gt; 0: arr[i] -= 1 dfs(num[1:], val * num[0]) arr[i] += 1 else: continue if i == 3: if arr[i] \u0026gt; 0: arr[i] -= 1 if val \u0026lt; 0: temp = abs(val) // num[0] * -1 else: temp = val // num[0] dfs(num[1:], temp) arr[i] += 1 else: continue max_res = -int(1e9) min_res = int(1e9) dfs(n_num[1:], n_num[0]) print(max_res, min_res, sep=\u0026#39;n\u0026#39;) 💾 느낀점 단순히 permutations 혹은 combinations 로 풀지 않았고,\n정확하게 DFS 및 백트래킹을 활용하여 풀이했는데, 이것이 N과 M 시리즈를 푸는데에 좋은 연습이 됐다. 조건이 크게 없었지만, division error를 조심해야 했고,\n음수일 경우에 나눗셈의 방식이 조금 다르기 때문에 간단한 조건 추가하는 것만 조심하면 되는 문제였던 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-15658-%EC%97%B0%EC%82%B0%EC%9E%90-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-2-with-python/","summary":"📌 BOJ 15658 연산자 끼워넣기 (2) 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN\nN(2 ≤ N ≤ 11), (1 ≤ Ai ≤ 100) 입력 값중 셋째 줄에 4N보다 작거나 같은 4개의 정수가 주어지는데,\n차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다. 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다. 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다.","title":"[BOJ] 15658 연산자 끼워넣기 (2) with Python"},{"content":"\n📌 BOJ 1904 01타일 💡 조건 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다. 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다.\n결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다. N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.)\n또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다. N이 주어진다.\n(1 ≤ N ≤ 1,000,000) 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다. DP 유형의 문제 🔖 예제 및 실행결과 예제 4 실행결과 5 ⌨️ 문제 풀이 N이 100만까지 들어올 수 있다. 그러므로, DP 리스트의 크기는 1000001 이 되어야한다. N의 값이 3일 때까지 직접 계산을 해보면 dp[3] 까지의 값은 아래와 같다. 1, 2, 3 dp[i] = (dp[i-1] + dp[i-2]) % 15746\n위와 같은 점화식을 만들 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) dp = [0 for _ in range(1000001)] dp[1], dp[2], dp[3], dp[4] = 1, 2, 3, 5 for i in range(5, n + 1): num = ((dp[i-1] + dp[i-2]) % 15746) dp[i] = num print(dp[n]) 💾 느낀점 다이나믹프로그래밍을 이용해 문제를 풀이할 수 있는 문제였습니다. 다른 DP 문제와 다르게 친절하고, 쉽고 재미있었습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1904-01%ED%83%80%EC%9D%BC-with-python/","summary":"📌 BOJ 1904 01타일 💡 조건 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다. 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다.\n결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다. N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.)\n또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.","title":"[BOJ] 1904 01타일 with Python"},{"content":"\n📌 BOJ 9933 민균이의 비밀번호 💡 조건 민균이의 비밀번호가 \u0026ldquo;tulipan\u0026quot;인 경우에 목록에는 \u0026ldquo;napilut\u0026quot;도 존재해야 한다. 민균이의 파일에 적혀있는 단어가 모두 주어졌을 때, 비밀번호의 길이와 가운데 글자를 출력하는 프로그램을 작성하라. 단어의 수 N (2 ≤ N ≤ 100)이 주어진다. 단어는 알파벳 소문자로만 이루어져 있으며, 길이는 2보다 크고 14보다 작은 홀수이다. 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 4 las god psala sal 실행결과 3 a ⌨️ 문제 풀이 data 리스트에 입력되는 n개의 비밀번호를 저장한다. temp 변수에 data 리스트의 i번째 비밀번호를 복사한다.\ntemp에 있는 리스트를 뒤집어준다. temp가 만약 data 안에 있다면, data 의 가운데 글자와 비밀번호의 길이를 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) data = [] for _ in range(n): data.append(list(stdin.readline().rstrip())) def solve(): for i in range(n): temp = data[i][:] temp.reverse() if temp in data: length = len(temp) mid = data[i][length // 2] return length, mid print(*solve()) 💾 느낀점 간단한 구현 및 문자열 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9933-%EB%AF%BC%EA%B7%A0%EC%9D%B4%EC%9D%98-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-with-python-copy/","summary":"📌 BOJ 9933 민균이의 비밀번호 💡 조건 민균이의 비밀번호가 \u0026ldquo;tulipan\u0026quot;인 경우에 목록에는 \u0026ldquo;napilut\u0026quot;도 존재해야 한다. 민균이의 파일에 적혀있는 단어가 모두 주어졌을 때, 비밀번호의 길이와 가운데 글자를 출력하는 프로그램을 작성하라. 단어의 수 N (2 ≤ N ≤ 100)이 주어진다. 단어는 알파벳 소문자로만 이루어져 있으며, 길이는 2보다 크고 14보다 작은 홀수이다. 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 4 las god psala sal 실행결과 3 a ⌨️ 문제 풀이 data 리스트에 입력되는 n개의 비밀번호를 저장한다.","title":"[BOJ] 9933 민균이의 비밀번호 with Python"},{"content":"\n📌 BOJ 1058 친구 💡 조건 어떤 사람 A가 또다른 사람 B의 2-친구가 되기 위해선, 두 사람이 친구이거나, A와 친구이고, B와 친구인 C가 존재해야 된다. 여기서 가장 유명한 사람은 2-친구의 수가 가장 많은 사람이다. 가장 유명한 사람의 2-친구의 수를 출력하는 프로그램을 작성하시오. A와 B가 친구면, B와 A도 친구이고, A와 A는 친구가 아니다. 사람의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.\n둘째 줄부터 N개의 줄에 각 사람이 친구이면 Y, 아니면 N이 주어진다.\n가장 유명한 사람의 2-친구의 수를 출력한다. 플로이드-와샬 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 10 NNNNYNNNNN NNNNYNYYNN NNNYYYNNNN NNYNNNNNNN YYYNNNNNNY NNYNNNNNYN NYNNNNNYNN NYNNNNYNNN NNNNNYNNNN NNNNYNNNNN 실행결과 8 ⌨️ 문제 풀이 플로이드-와샬 알고리즘 알고리즘을 사용하여 문제를 풀이한다. Y를 1로, N을 0으로 변환한 뒤, arr에 입력받은 데이터를 저장한다. test 배열에 arr배열을 복사한 뒤, 플로이드-와샬 알고리즘을 돌리기 위한 3중 반복문을 순회한다. arr[i][k] 와 arr[k][j] 가 1이라면, test[i][j]에 1을 저장한다.\ni와 j 가 한다리 건너서 친구인지 확인하는 구간이다. test 배열을 순회하면서 test[i]의 합이 최댓값인 것을 찾아서 결과값을 저장할 res 변수에 저장하고, 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] for i in range(n): temp = stdin.readline().rstrip().replace(\u0026#34;N\u0026#34;, \u0026#39;0\u0026#39;).replace(\u0026#34;Y\u0026#34;, \u0026#39;1\u0026#39;) data = list(map(int, list(temp))) arr.append(data) res = [0] * n test = [item[:] for item in arr] for k in range(n): for i in range(n): for j in range(n): if i != j: if arr[i][k] and arr[k][j]: test[i][j] = 1 res = 0 for i in range(n): friends = sum(test[i]) if res \u0026lt; friends: res = friends print(res) 💾 느낀점 플로이드-와샬 알고리즘의 응용문제였다. 모든 노드에서의 최단거리를 찾는 방식이 아닌,\n모든 노드에서 친구가 될 수 있는 경우를 찾아 test 배열에 저장하는 방식으로 풀이했다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1058-%EC%B9%9C%EA%B5%AC-with-python/","summary":"📌 BOJ 1058 친구 💡 조건 어떤 사람 A가 또다른 사람 B의 2-친구가 되기 위해선, 두 사람이 친구이거나, A와 친구이고, B와 친구인 C가 존재해야 된다. 여기서 가장 유명한 사람은 2-친구의 수가 가장 많은 사람이다. 가장 유명한 사람의 2-친구의 수를 출력하는 프로그램을 작성하시오. A와 B가 친구면, B와 A도 친구이고, A와 A는 친구가 아니다. 사람의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.\n둘째 줄부터 N개의 줄에 각 사람이 친구이면 Y, 아니면 N이 주어진다.","title":"[BOJ] 1058 친구 with Python"},{"content":"\n📌 BOJ 1094 막대기 💡 조건 64cm인 막대를 가지고 있다.\n지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다. 아래는 막대를 자르는 방법이다. 지민이가 가지고 있는 막대의 길이를 모두 더한다.\n처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.\n1-1) 가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.\n1-2) 만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면,2) 이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다. 위에서 자른 막대의 절반 중 하나를 버린다. X는 64보다 작거나 같은 자연수 DFS, 수학, 비트마스킹 유형의 문제 🔖 예제 및 실행결과 예제 23 실행결과 4 ⌨️ 문제 풀이 DFS 알고리즘을 사용해서 풀이했다. 결과값을 저장할 res 변수와 분리되지 않은 막대기 64가 들어가있는 sticks 리스트를 생성한다. solve() 함수의 로직은 아래와 같습니다. sticks 리스트의 합이 입력받은 값 x 보다 클 경우,\nsticks 에서 heapq.heappop() 함수를 통해 가장 작은 값을 빼낸다.\n빼낸 값을 2로 나눈 몫을 다시 heapq.heappush()로 다시 넣어준다. 만약, sticks 리스트의 합에서 heapq.heappop() 함수를 통해 가장 작은 값을 뺀 값이 x보다 크거나 같다면\nheapq.heappop() 함수를 통해 가장 작은 값을 빼낸다.\nsolve() 함수를 재귀호출한다. 위의 조건에 해당하지 않고, sticks의 리스트의 합이 x보다 크거나 같다면 다시 solve() 함수를 재귀호출한다. sticks 리스트의 길이를 출력한다. 🖥 소스 코드 from sys import stdin, setrecursionlimit import heapq setrecursionlimit(10 ** 6) x = int(stdin.readline()) res = 0 sticks = [64] def solve(sticks): global res val = sum(sticks) if val \u0026gt; x: temp = heapq.heappop(sticks) heapq.heappush(sticks, temp // 2) heapq.heappush(sticks, temp // 2) if sum(sticks) - (temp // 2) \u0026gt;= x: heapq.heappop(sticks) solve(sticks) elif sum(sticks) \u0026gt;= x: solve(sticks) solve(sticks) print(len(sticks)) 💾 느낀점 heapq를 사용하여 재귀호출을 통해 답을 구하는 문제였습니다. 막대기를 자르는 방법을 충실히 구현하여 재귀호출하는 방법을 사용한다면 어렵지 않게 풀 수 있는 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1094-%EB%A7%89%EB%8C%80%EA%B8%B0-with-python/","summary":"📌 BOJ 1094 막대기 💡 조건 64cm인 막대를 가지고 있다.\n지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다. 아래는 막대를 자르는 방법이다. 지민이가 가지고 있는 막대의 길이를 모두 더한다.\n처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.\n1-1) 가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.\n1-2) 만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면,2) 이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다.","title":"[BOJ] 1094 막대기 with Python"},{"content":"\n📌 BOJ 1021 회전하는 큐 💡 조건 N개의 원소를 포함하고 있는 양방향 순환 큐 1 \u0026lt;= N \u0026lt;= 50 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, \u0026hellip;, ak이었던 것이 a2, \u0026hellip;, ak와 같이 된다. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 a2, \u0026hellip;, ak, a1이 된다. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 ak, a1, \u0026hellip;, ak-1이 된다. 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 문제. Queue, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 32 6 27 16 30 11 6 23 실행결과 59 ⌨️ 문제 풀이 큐의 크기만큼 1부터 N까지의 수를 포함한 리스트를 만들어준다. 결과값을 저장할 res 변수를 0으로 초기화해준다. 추출하려고 하는 수를 저장한 arr 를 순회하면서 break 명령이 떨어질 때 까지 while 반복한다. 만약 큐의 첫번째 원소가 뽑아내려는 수와 일치 하는 경우, 바로 원소를 뽑아낸 뒤 while을 종료한다 만약 큐의 첫번째 원소가 뽑아내려는 수와 일치 하지 않는 경우, 큐의 길이를 2로 나눈 몫이 큐에서 뽑아 내려는 값의 인덱스보다 크거나 같다면 왼쪽에서 원소를 뽑아 오른쪽에 붙인다. 큐의 길이를 2로 나눈 몫이 큐에서 뽑아 내려는 값의 인덱스보다 작다면 오른쪽에서 원소를 뽑아 왼쪽에 붙인다. 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) q = deque() for i in range(1, n + 1): q.append(i) res = 0 for i in arr: while 1: if q[0] != i: if len(q) // 2 \u0026gt;= q.index(i): temp = q.popleft() q.append(temp) res += 1 else: q.appendleft(q.pop()) res += 1 else: q.popleft() break print(res) 💾 느낀점 python 의 deque 는 매우 강력하다. appendleft는 두고두고 쓸 함수일 것 같다는 생각이 들었습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1021-%ED%9A%8C%EC%A0%84%ED%95%98%EB%8A%94-%ED%81%90-with-python/","summary":"📌 BOJ 1021 회전하는 큐 💡 조건 N개의 원소를 포함하고 있는 양방향 순환 큐 1 \u0026lt;= N \u0026lt;= 50 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, \u0026hellip;, ak이었던 것이 a2, \u0026hellip;, ak와 같이 된다. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 a2, \u0026hellip;, ak, a1이 된다. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 ak, a1, \u0026hellip;, ak-1이 된다.","title":"[BOJ] 1021 회전하는 큐 with Python"},{"content":"\n📌 BOJ 1026 보물 💡 조건 길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자. S = A[0] × B[0] + ... + A[N-1] × B[N-1] S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다. 정렬, 사칙연산 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 1 6 0 2 7 8 3 1 실행결과 18 ⌨️ 문제 풀이 가장 큰 수와 가장 작은 수를 곱하여 더하면 최솟값이 나온다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) a = sorted(list(map(int, stdin.readline().split()))) b = sorted(list(map(int, stdin.readline().split())), reverse=True) print(sum([a * b for a, b in zip(a, b)])) 💾 느낀점 정렬하여 쉽게 풀었던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1026-%EB%B3%B4%EB%AC%BC-with-python/","summary":"📌 BOJ 1026 보물 💡 조건 길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자. S = A[0] × B[0] + ... + A[N-1] × B[N-1] S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다. 정렬, 사칙연산 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 1 6 0 2 7 8 3 1 실행결과 18 ⌨️ 문제 풀이 가장 큰 수와 가장 작은 수를 곱하여 더하면 최솟값이 나온다.","title":"[BOJ] 1026 보물 with Python"},{"content":"\n📌 BOJ 14916 거스름돈 💡 조건 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈 액수 n(1 ≤ n ≤ 100,000) DP, 수학 유형의 문제 🔖 예제 및 실행결과 예제 13 실행결과 5 ⌨️ 문제 풀이 5원 동전이 몇 개 일때 최소인지 구하면 된다. int(1e9)로 결과값을 초기하화 해두고, n // 5 개부터 한개씩 5원짜리를 줄여가며 최소 갯수를 구한다. 5원 개수에 해당하는 금액만큼 n에서 뺀 후, 2 로 나누어 떨어지지 않을 경우 continue 5월 개수에 해당하는 금액만큼 n에서 뺀 나머지 금액이 2로 나누어 떨어지면 res 갱신 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) res = int(1e9) for i in range(n // 5, -1, -1): money = n - i * 5 cnt = i if money % 2 != 0: continue else: cnt += money // 2 res = min(cnt, res) print(res) if res != int(1e9) else print(-1) 💾 느낀점 분류에는 DP라고 되어 있었지만, 메모이제이션은 필요가 없고, 식만 세우면 풀이가 가능한 문제였다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14916-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-with-python/","summary":"📌 BOJ 14916 거스름돈 💡 조건 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈 액수 n(1 ≤ n ≤ 100,000) DP, 수학 유형의 문제 🔖 예제 및 실행결과 예제 13 실행결과 5 ⌨️ 문제 풀이 5원 동전이 몇 개 일때 최소인지 구하면 된다. int(1e9)로 결과값을 초기하화 해두고, n // 5 개부터 한개씩 5원짜리를 줄여가며 최소 갯수를 구한다. 5원 개수에 해당하는 금액만큼 n에서 뺀 후, 2 로 나누어 떨어지지 않을 경우 continue 5월 개수에 해당하는 금액만큼 n에서 뺀 나머지 금액이 2로 나누어 떨어지면 res 갱신 🖥 소스 코드 from sys import stdin n = int(stdin.","title":"[BOJ] 14916 거스름돈 with Python"},{"content":"\n📌 BOJ 20291 파일 정리 💡 조건 바탕화면에 있는 파일의 개수 N (1 \u0026lt;= N \u0026lt;= 50000) 파일의 이름은 알파벳 소문자와 점(.)으로만 구성되어 있다.\n점은 정확히 한 번 등장하며, 파일 이름의 첫 글자 또는 마지막 글자로 오지 않는다.\n각 파일의 이름의 길이는 최소 3, 최대 100이다. 확장자의 이름과 그 확장자 파일의 개수를 한 줄에 하나씩 출력한다.\n확장자가 여러 개 있는 경우 확장자 이름의 사전순으로 출력한다. 해시맵 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 8 sbrus.txt spc.spc acm.icpc korea.icpc sample.txt hello.world sogang.spc example.txt 실행결과 icpc 2 spc 2 txt 3 world 1 ⌨️ 문제 풀이 확장자의 이름과 개수를 저장할 dict 자료형 변수 하나를 만든다. split() 함수를 사용해 \u0026lsquo;.\u0026lsquo;을 기준으로 분리한 후 확장자 명이 dict에 있을 경우 + 1, 없으면 새로 추가한 후 1값을 넣는다. dict_name.items() 함수를 사용하여, key, value 쌍을 res 리스트에 넣고 정렬한 뒤 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) file_name = {} for i in range(n): data = stdin.readline().rstrip().split(\u0026#39;.\u0026#39;) if data[1] in file_name: file_name[data[1]] += 1 else: file_name[data[1]] = 1 res = [] for key, item in file_name.items(): res.append((key, item)) res.sort() for i in res: print(*i) 💾 느낀점 해시맵을 사용해 간단하게 풀었던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20291-%ED%8C%8C%EC%9D%BC-%EC%A0%95%EB%A6%AC-with-python/","summary":"📌 BOJ 20291 파일 정리 💡 조건 바탕화면에 있는 파일의 개수 N (1 \u0026lt;= N \u0026lt;= 50000) 파일의 이름은 알파벳 소문자와 점(.)으로만 구성되어 있다.\n점은 정확히 한 번 등장하며, 파일 이름의 첫 글자 또는 마지막 글자로 오지 않는다.\n각 파일의 이름의 길이는 최소 3, 최대 100이다. 확장자의 이름과 그 확장자 파일의 개수를 한 줄에 하나씩 출력한다.\n확장자가 여러 개 있는 경우 확장자 이름의 사전순으로 출력한다. 해시맵 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 8 sbrus.","title":"[BOJ] 20291 파일 정리 with Python"},{"content":"\n📌 BOJ 14502 연구소 💡 조건 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8) 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다. DFS + BFS, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 7 7 2 0 0 0 1 1 0 0 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 실행결과 27 ⌨️ 문제 풀이 맵의 정보를 입력받으면서, 바이러스의 위치를 virus_xy 리스트에 저장한다. 안전 영역의 최댓값을 담을 변수 score 를 -int(1e9)로 초기화한다. 이 문제의 풀이를 위해서 사용할 함수는 총 3개이다. get_score(board) : 안전 영역의 크기를 계산하여 최댓값일 경우 score 갱신 insfection(x, y, board) : 벽을 세우고, 바이러스가 이동하며 감염. 보드를 갱신. BFS 알고리즘을 사용. solutions(cnt) : 3개의 벽을 세울 수 있게 cnt를 파라미터로 사용. DFS 알고리즘을 사용. 설치한 벽의 개수가 3개가 될 때까지 DFS 알고리즘을 사용해 맵을 갱신한다.\n벽이 3개가 설치 되었다면, 새로운 보드를 만들고 감염을 시켜준다. 새로운 보드를 감염시킨 후, score 계산을 한다.\n계산한 score 값이 최댓값일 경우, 갱신한다. 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) board = [] virus_xy = [] for i in range(n): data = list(map(int, stdin.readline().split())) board.append(data) for j in range(len(data)): if data[j] == 2: virus_xy.append((i, j)) score = -1e9 dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] def get_score(board): global score cnt = 0 for x in range(n): for y in range(m): if board[x][y] == 0: cnt += 1 score = max(score, cnt) def insfection(x, y, board): q = deque() q.append((x, y)) while q: a, b = q.popleft() for i in range(4): nx, ny = a + dx[i], b + dy[i] if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: if board[nx][ny] == 0: board[nx][ny] = 2 q.append((nx, ny)) def solutions(cnt): if cnt == 3: new_board = [item[:] for item in board] for x, y in virus_xy: insfection(x, y, new_board) get_score(new_board) else: for x in range(n): for y in range(m): if board[x][y] == 0: board[x][y] = 1 cnt += 1 solutions(cnt) cnt -= 1 board[x][y] = 0 solutions(0) print(score) 💾 느낀점 PyPy3 로 채점하여 통과했다. DFS를 사용하여 벽을 3개 설치한 후, BFS를 사용하여 감염, score 계산하는 로직을 이해하는 것이 처음엔 어려웠다. 문제를 풀고서 매우 뒤늦게 블로그 포스팅을 하는 것인데, 로직을 이해하니 비슷한 유형의 문제를 푸는 것이 확실히 수월해졌다. 여기서 조금 더 응용을 하자면, 벽을 설치했는지 안했는지의 state를 저장할\ndp 배열을 만들면 메모리제이션을 통해 시간복잡도를 줄일 수 있는 유사문제도 있었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14502-%EC%97%B0%EA%B5%AC%EC%86%8C-with-python/","summary":"📌 BOJ 14502 연구소 💡 조건 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8) 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.","title":"[BOJ] 14502 연구소 with Python"},{"content":"\n📌 BOJ 14888 연산자 끼워넣기 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자\n연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 수의 개수 N(2 ≤ N ≤ 11)\nA1, A2, \u0026hellip;, AN이 주어진다. (1 ≤ Ai ≤ 100) 첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 6 0 0 1 0 실행결과 30 30 ⌨️ 문제 풀이 permutations 라이브러리 import 연산자를 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷) 순서대로 담은 gi 리스트 선언. 연산자의 개수 리스트를 입력받아 각 연산자의 개수만큼 곱하여 cg 리스트에 extend 해준다. cg 리스트의 길이는 입력받은 수열의 길이 - 1이다.\npermutaions 함수를 통해 순열을 통해 연산자의 경우를 뽑아 calculation 함수에 넣고 계산한다. calculation 함수에서 zero division 에러를 조심해야한다. calculation 함수에서 계산한 결과값으로 최솟값과 최댓값을 갱신해준다. 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.readline().rstrip()) num = list(map(int, stdin.readline().split())) cal_ = list(map(int, stdin.readline().split())) gi = [\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;/\u0026#39;] cg = [] vmax = -1e9 vmin = 1e9 def calculation(sign, num): global vmax, vmin calc_num = num[0] for idx in range(1, len(num)): if sign[idx - 1] == \u0026#39;+\u0026#39;: calc_num += num[idx] elif sign[idx - 1] == \u0026#39;-\u0026#39;: calc_num -= num[idx] elif sign[idx - 1] == \u0026#39;*\u0026#39;: calc_num *= num[idx] elif sign[idx - 1] == \u0026#39;/\u0026#39;: if num[idx] \u0026lt; 0 or calc_num \u0026lt; 0: calc_num = abs(calc_num) // abs(num[idx]) * -1 else: calc_num //= num[idx] vmax = max(vmax, calc_num) vmin = min(vmin, calc_num) for i in range(4): cg.extend([gi[i]] * cal_[i]) for sign in list(set(permutations(cg, n - 1))): calculation(sign, num) print(vmax) print(vmin) 💾 느낀점 permutations 함수를 사용하여 간단하게 풀 수 있어 매우 착한 문제였다고 생각합니다. 시간초과가 안나게 하기 위해서 permutations 함수 결과를 set() 으로 둘러싸서 중복을 제거했습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14888-%EC%97%B0%EC%82%B0%EC%9E%90-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-with-python/","summary":"📌 BOJ 14888 연산자 끼워넣기 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자\n연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 수의 개수 N(2 ≤ N ≤ 11)\nA1, A2, \u0026hellip;, AN이 주어진다. (1 ≤ Ai ≤ 100) 첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 6 0 0 1 0 실행결과 30 30 ⌨️ 문제 풀이 permutations 라이브러리 import 연산자를 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷) 순서대로 담은 gi 리스트 선언.","title":"[BOJ] 14888 연산자 끼워넣기 with Python"},{"content":"\n📌 BOJ 10819 차이를 최대로 💡 조건 N개의 정수로 이루어진 배열 A N (3 ≤ N ≤ 8) 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다. 다음 식의 최댓값을 구하는 프로그램을 작성. |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]| 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 20 1 15 8 4 10 실행결과 62 ⌨️ 문제 풀이 최댓값을 저장할 res 정수 생성 itertools 의 permutaions 함수로 가능한 수를 모두 계산하여 v에 저장하고, res 갱신 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) res = -int(1e9) for arr2 in permutations(arr, n): v = 0 for i in range(n-1): v += abs(arr2[i] - arr2[i + 1]) res = max(res, v) print(res) 💾 느낀점 배열의 크기가 최대 8개 밖에 안되기에 permutaions를 썼다. 만약 배열의 크기가 컸다면? ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10819-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%B5%9C%EB%8C%80%EB%A1%9C-with-python/","summary":"📌 BOJ 10819 차이를 최대로 💡 조건 N개의 정수로 이루어진 배열 A N (3 ≤ N ≤ 8) 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다. 다음 식의 최댓값을 구하는 프로그램을 작성. |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]| 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 20 1 15 8 4 10 실행결과 62 ⌨️ 문제 풀이 최댓값을 저장할 res 정수 생성 itertools 의 permutaions 함수로 가능한 수를 모두 계산하여 v에 저장하고, res 갱신 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.","title":"[BOJ] 10819 차이를 최대로 with Python"},{"content":"\n📌 BOJ 11504 돌려 돌려 돌림판! 💡 조건 첫 번째 줄에 테스트케이스의 개수 T 테스트케이스의 첫 줄에는 돌림판을 N등분할 정수 N (1 ≤ N ≤ 100)\nX, Y의 길이 M (1 ≤ M ≤ 9, M ≤ N)\n다음 3개의 줄에 X의 각 자리수, Y의 각 자리수, 돌림판의 상태 돌림판에서 X ≤ Z ≤ Y를 만족하는 M자리의 수 Z가 몇 개가 있는 지를 출력 X와 Y사이에 있는 수가 123 밖에 없는 데 돌림판에서 2번 나온다면, 1이 아닌 2를 출력 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 8 3 2 0 0 3 1 1 3 7 8 3 1 9 2 7 5 2 8 8 9 9 1 3 2 5 4 6 3 0 0 0 9 9 9 1 2 3 4 5 6 실행결과 1 0 6 ⌨️ 문제 풀이 돌림판의 숫자를 입력받아, m개의 개수만큼 이어붙여 새로운 숫자를 만든다. x 와 y 사이에 있는 숫자인지 확인한 후, res를 갱신한다. res 출력 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): n, m = map(int, stdin.readline().split()) x = int(\u0026#39;\u0026#39;.join(list(stdin.readline().split()))) y = int(\u0026#39;\u0026#39;.join(list(stdin.readline().split()))) data = list(map(int, stdin.readline().split())) data += data[:m] res = 0 for i in range(n): check = int(\u0026#39;\u0026#39;.join(map(str, data[i:i+m]))) if x \u0026lt;= check \u0026lt;= y: res += 1 print(res) 💾 느낀점 구현 \u0026amp; 시뮬레이터 문제 중 브론즈인만큼 매우 쉬운 문제. 문제가 길어서 읽기 귀찮아도 막상 읽어보면 별거 아닌 문제. 구현과 시뮬레이션이라기보다, 문제 읽고 압축하는 연습은 됐다고 생각합니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11504-%EB%8F%8C%EB%A0%A4-%EB%8F%8C%EB%A0%A4-%EB%8F%8C%EB%A6%BC%ED%8C%90-with-python/","summary":"📌 BOJ 11504 돌려 돌려 돌림판! 💡 조건 첫 번째 줄에 테스트케이스의 개수 T 테스트케이스의 첫 줄에는 돌림판을 N등분할 정수 N (1 ≤ N ≤ 100)\nX, Y의 길이 M (1 ≤ M ≤ 9, M ≤ N)\n다음 3개의 줄에 X의 각 자리수, Y의 각 자리수, 돌림판의 상태 돌림판에서 X ≤ Z ≤ Y를 만족하는 M자리의 수 Z가 몇 개가 있는 지를 출력 X와 Y사이에 있는 수가 123 밖에 없는 데 돌림판에서 2번 나온다면, 1이 아닌 2를 출력 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 8 3 2 0 0 3 1 1 3 7 8 3 1 9 2 7 5 2 8 8 9 9 1 3 2 5 4 6 3 0 0 0 9 9 9 1 2 3 4 5 6 실행결과 1 0 6 ⌨️ 문제 풀이 돌림판의 숫자를 입력받아, m개의 개수만큼 이어붙여 새로운 숫자를 만든다.","title":"[BOJ] 11504 돌려 돌려 돌림판! with Python"},{"content":"\n📌 BOJ 1535 안녕 💡 조건 첫째 줄에 사람의 수 N(≤ 20). 둘째 줄에 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 입력. 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 입력. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0. 세준이가 얻을 수 있는 최대 기쁨을 출력. 브루트포스 알고리즘, 배낭 알고리즘 유형 문제 🔖 예제 및 실행결과 예제 3 1 21 79 20 30 25 실행결과 50 ⌨️ 문제 풀이 브루트포스 알고리즘 혹은 냅색 알고리즘 으로 풀이할 수 있다.\n나는 냅색 알고리즘을 사용했다. 인사를 할 때 사용하는 스테미너 소모하는 리스트를 stamina_consum 에 [0]에 연결하여 저장한다.\n인사를 할 때 얻을 수 있는 기쁨 리스트를 get_pleasure 에 [0]에 연결하여 저장한다. dp 배열을 만든다. 1명부터 n명까지 인사를 했을 때, 얻을 수 있는 최대의 기쁨의 값을 저장할 배열. i번째 사람에게 인사를 하고, 스테미너 소모량보다 체력 j가 클 때 인사를 해서 얻을 수 있는 기쁨의 양을 계산하여 dp에 저장한다. 체력이 1이 기준이며, 출력할 때 dp[n][100]을 출력하면 세준이가 인사를 하다 죽어버린 경우이니 오답이다. dp[n][99]를 출력한다. 만약 stamina[i] 보다 체력 j 가 적을 경우, dp[i][j] 는 dp[i-1][j]의 값을 가져다 넣는다. 그렇지 않은 경우에는 dp[i-1][j] 와 dp[i-1][j - stamina_consum[i]] 에 get_pleasure[i] 값 중 큰 걸 집어 넣는다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) stamina_consum = [0] + list(map(int, stdin.readline().split())) get_pleasure = [0] + list(map(int, stdin.readline().split())) dp = [[0] * 101 for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, 101): if stamina_consum[i] \u0026lt;= j: dp[i][j] = max(dp[i-1][j], dp[i-1][j - stamina_consum[i]] + get_pleasure[i]) else: dp[i][j] = dp[i-1][j] print(dp[n][99]) 💾 느낀점 냅색 알고리즘은 풀어도 풀어도 헷갈린다. 알고리즘을 알고서 풀어도 어렵고, 까먹으면 답도 없는 것 같다. 냅색 알고리즘 문제를 정리해서 풀어봐야할 것 같다. 문제 풀이 해설을 쓰면서도 헷갈려서 다시 인터넷을 보고 찾아서 이해하고 문제를 해석해서 썼다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1535-%EC%95%88%EB%85%95-with-python/","summary":"📌 BOJ 1535 안녕 💡 조건 첫째 줄에 사람의 수 N(≤ 20). 둘째 줄에 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 입력. 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 입력. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0. 세준이가 얻을 수 있는 최대 기쁨을 출력. 브루트포스 알고리즘, 배낭 알고리즘 유형 문제 🔖 예제 및 실행결과 예제 3 1 21 79 20 30 25 실행결과 50 ⌨️ 문제 풀이 브루트포스 알고리즘 혹은 냅색 알고리즘 으로 풀이할 수 있다.","title":"[BOJ] 1535 안녕 with Python"},{"content":"\n📌 BOJ 9461 파도반 💡 조건 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다.\n(1 ≤ N ≤ 100) 파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 각 테스트 케이스마다 정수 N을 입력받아 P(N)을 출력. Dynamic Programming 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 6 12 실행결과 3 16 ⌨️ 문제 풀이 문제에서 이미 점화식을 짜라고 P(1)부터 P(10)까지 제공해주었다.\n규칙을 찾아 점화식을 세워보자면, dp[i] = dp[i - 3] + dp[i - 2] 이 될 것이다.\n여기서 N의 범위를 살펴보면 1부터 100까지 이다.\n배열의 크기를 101개로 둔 뒤, 문제에서 제공해준 값을 다 넣어도 좋고, 앞의 세개만 넣어 점화식을 통해\n101개의 배열을 채우는 것도 좋다.\n배열을 채우는데에는 큰 시간이 걸리지 않으니, 미리 모두 구해놓고 테스트케이스마다 입력을 받아 처리했다.\n여기서, dp 리스트의 N-1번째를 출력하지 않으면 엉뚱한 답이 나오거나, index에러를 뱉고 죽어버릴 수 있으니 조심하자. 🖥 소스 코드 from sys import stdin dp = [0 for _ in range(101)] dp[0], dp[1], dp[2] = 1, 1, 1 for i in range(3, 101): dp[i] = dp[i - 3] + dp[i - 2] for _ in range(int(stdin.readline())): print(dp[int(stdin.readline()) - 1]) 💾 느낀점 너무나도 상냥하고 친절한 DP문제였다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9461-%ED%8C%8C%EB%8F%84%EB%B0%98-%EC%88%98%EC%97%B4-with-python/","summary":"📌 BOJ 9461 파도반 💡 조건 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다.\n(1 ≤ N ≤ 100) 파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 각 테스트 케이스마다 정수 N을 입력받아 P(N)을 출력. Dynamic Programming 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 6 12 실행결과 3 16 ⌨️ 문제 풀이 문제에서 이미 점화식을 짜라고 P(1)부터 P(10)까지 제공해주었다.","title":"[BOJ] 9461 파도반 수열 with Python"},{"content":"\n📌 BOJ 1063 킹 💡 조건 체스판의 크기는 8*8\n체스판에서의 말의 위치는 알파벳 하나와 숫자 하나로 구성되어 있다.\n알파벳은 열(column), 숫자는 행(row)을 상징한다.\n알파벳은 A\n~H, 숫자는 1~\n8까지이다.\n킹이 움직일 수 있는 방법은 8가지가 있으며, 문제에 제시되어 있다.\n체스판에 있는 돌은 킹이 움직인 방향으로 같이 움직인다.\n체스판이나 돌이 입력에서 주어진대로 움직이다가 밖으로 나갈 경우, 그 이동은 건너 뛴다.\n첫째 줄에 킹의 마지막 위치, 둘째 줄에 돌의 마지막 위치를 출력한다.\n구현, 시뮬레이션의 문제\n🔖 예제 및 실행결과 예제 A1 A2 5 B L LB RB LT 실행결과 A1 A2 ⌨️ 문제 풀이 첫 위치를 입력 받고, 주어진 입력의 횟수만큼 이동명령을 받아 처리하면 된다. 대문자 A~H 는 아스키 코드 숫자를 사용하여 처리를 하는 것이 훨씬 편하다. 각 커맨드마다 움직이는 좌표를 수정해주면서 아래의 확인사항을 체크한다. 킹은 움직이지 못하는데 돌이 움직일 수 있는 경우는 그냥 넘어간다. 돌은 움직이지 못하는데 킹이 움직일 수 있는 경우는 그냥 넘어간다. 움직이지 못하는 곳이라면 가볍게 무시하고 다음으로 넘어간다. 🖥 소스 코드 from sys import stdin k, s, n = stdin.readline().rstrip().split() pos_k = [ord(k[0]), int(k[1])] pos_s = [ord(s[0]), int(s[1])] for _ in range(int(n)): com = stdin.readline().rstrip() if com == \u0026#39;R\u0026#39;: if 64 \u0026lt; pos_k[0] + 1 \u0026lt; 73: pos_k[0] += 1 if pos_k == pos_s: if 64 \u0026lt; pos_s[0] + 1 \u0026lt; 73: pos_s[0] += 1 else: pos_k[0] -= 1 elif com == \u0026#39;L\u0026#39;: if 64 \u0026lt; pos_k[0] - 1 \u0026lt; 73: pos_k[0] -= 1 if pos_k == pos_s: if 64 \u0026lt; pos_s[0] - 1 \u0026lt; 73: pos_s[0] -= 1 else: pos_k[0] += 1 elif com == \u0026#39;B\u0026#39;: if 0 \u0026lt; pos_k[1] - 1 \u0026lt; 9: pos_k[1] -= 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] - 1 \u0026lt; 9: pos_s[1] -= 1 else: pos_k[1] += 1 elif com == \u0026#39;T\u0026#39;: if 0 \u0026lt; pos_k[1] + 1 \u0026lt; 9: pos_k[1] += 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] + 1 \u0026lt; 9: pos_s[1] += 1 else: pos_k[1] -= 1 elif com == \u0026#39;RT\u0026#39;: if 0 \u0026lt; pos_k[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] + 1 \u0026lt; 73: pos_k[0] += 1 pos_k[1] += 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] + 1 \u0026lt; 73: pos_s[0] += 1 pos_s[1] += 1 else: pos_k[0] -= 1 pos_k[1] -= 1 elif com == \u0026#39;LT\u0026#39;: if 0 \u0026lt; pos_k[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] - 1 \u0026lt; 73: pos_k[0] -= 1 pos_k[1] += 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] - 1 \u0026lt; 73: pos_s[0] -= 1 pos_s[1] += 1 else: pos_k[0] += 1 pos_k[1] -= 1 elif com == \u0026#39;RB\u0026#39;: if 0 \u0026lt; pos_k[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] + 1 \u0026lt; 73: pos_k[0] += 1 pos_k[1] -= 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] + 1 \u0026lt; 73: pos_s[0] += 1 pos_s[1] -= 1 else: pos_k[0] -= 1 pos_k[1] += 1 elif com == \u0026#39;LB\u0026#39;: if 0 \u0026lt; pos_k[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] - 1 \u0026lt; 73: pos_k[0] -= 1 pos_k[1] -= 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] - 1 \u0026lt; 73: pos_s[0] -= 1 pos_s[1] -= 1 else: pos_k[0] += 1 pos_k[1] += 1 print(\u0026#39;{}\u0026#39;.format(chr(pos_k[0]) + str(pos_k[1]))) print(\u0026#39;{}\u0026#39;.format(chr(pos_s[0]) + str(pos_s[1]))) 💾 느낀점 위치를 저장하는 알파벳과, 숫자를 계산하여 상태를 저장하면 되는 문제였다. 열과 행에 해당하는 알파벳과 숫자를 핸들링하여 상태가 변화할 때 가능한 움직임인지 체크하는 부분이 확실히 헷갈리고 어려웠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1063-%ED%82%B9-with-python/","summary":"📌 BOJ 1063 킹 💡 조건 체스판의 크기는 8*8\n체스판에서의 말의 위치는 알파벳 하나와 숫자 하나로 구성되어 있다.\n알파벳은 열(column), 숫자는 행(row)을 상징한다.\n알파벳은 A\n~H, 숫자는 1~\n8까지이다.\n킹이 움직일 수 있는 방법은 8가지가 있으며, 문제에 제시되어 있다.\n체스판에 있는 돌은 킹이 움직인 방향으로 같이 움직인다.\n체스판이나 돌이 입력에서 주어진대로 움직이다가 밖으로 나갈 경우, 그 이동은 건너 뛴다.\n첫째 줄에 킹의 마지막 위치, 둘째 줄에 돌의 마지막 위치를 출력한다.","title":"[BOJ] 1063 킹 with Python"},{"content":"\n📌 BOJ 18511 큰 수 구성하기 💡 조건 N보다 작거나 같은 자연수 중에서, 집합 K의 원소로만 구성된 가장 큰 수를 출력하는 프로그램을 작성.\n(10 ≤ N ≤ 100,000,000, 1 ≤ K의 원소의 개수 ≤ 3) K의 모든 원소는 1부터 9까지의 자연수로만 구성된다. 첫째 줄에 N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수를 출력 브루트포스 알고리즘, 재귀함수 유형의 문제 🔖 예제 및 실행결과 예제 657 3 1 5 7 실행결과 577 ⌨️ 문제 풀이 n을 문자열로 바꾸었을 때의 길이를 le 라는 변수에 저장한다. n보다 같거나 작은 자연수 중에 주어진 수열 arr로 만들 수 있는\n최댓값을 만들기 위해서 solve() 함수 안에서 수행해야할 로직은 다음과 같다. itertools의 product() 함수를 사용하여 수열 arr로 만들 있는 모든 경우의 k자리의 수를 모두 구해 변수 temp에 저장한다. temp의 원소들을 하나씩 순회하면서, 각 원소에 해당하는 t가 n보다 작거나 같은지 확인한다 위의 조건이 만족될 경우, 결과값 res보다 t가 클 경우 res를 갱신한다. 만약 temp를 모두 순회했지만 res가 갱신이 안되어 -int(1e9) 일 경우, le - 1\n갱신이 되었다면 res반환하고 출력 🖥 소스 코드 from sys import stdin from itertools import product n, k = map(str, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) arr.sort(reverse=True) le = len(n) res = -int(1e9) def solve(le): global res while 1: temp = list(product(arr, repeat=le)) for i in temp: t = int(\u0026#39;\u0026#39;.join(map(str, i))) if int(t) \u0026lt;= int(n): res = max(res, t) if res == -int(1e9): le -= 1 else: return res solve(le) print(res) 💾 느낀점 temp를 모두 순회했을 때 res가 갱신이 안된 경우를 처리하지 못해 골치아팠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-18511-%ED%81%B0-%EC%88%98-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 18511 큰 수 구성하기 💡 조건 N보다 작거나 같은 자연수 중에서, 집합 K의 원소로만 구성된 가장 큰 수를 출력하는 프로그램을 작성.\n(10 ≤ N ≤ 100,000,000, 1 ≤ K의 원소의 개수 ≤ 3) K의 모든 원소는 1부터 9까지의 자연수로만 구성된다. 첫째 줄에 N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수를 출력 브루트포스 알고리즘, 재귀함수 유형의 문제 🔖 예제 및 실행결과 예제 657 3 1 5 7 실행결과 577 ⌨️ 문제 풀이 n을 문자열로 바꾸었을 때의 길이를 le 라는 변수에 저장한다.","title":"[BOJ] 18511 큰 수 구성하기 with Python"},{"content":"\n📌 BOJ 20546 🐜 기적의 매매법 🐜 💡 조건 모든 거래는 전량 매수와 전량 매도로 이루어진다. 현재 가지고 있는 현금이 100원이고 주가가 11원이라면 99원어치의 주식을 매수하는 것이다. 단, 현금이 100원 있고 주가가 101원이라면 주식을 살 수 없다. 성민이는 빚을 내서 주식을 하지는 않는다. 3일 연속 가격이 전일 대비 상승하는 주식은 다음날 무조건 가격이 하락한다고 가정한다. 따라서 현재 소유한 주식의 가격이 3일째 상승한다면, 전량 매도한다. 전일과 오늘의 주가가 동일하다면 가격이 상승한 것이 아니다. 3일 연속 가격이 전일 대비 하락하는 주식은 다음날 무조건 가격이 상승한다고 가정한다. 따라서 이러한 경향이 나타나면 즉시 주식을 전량 매수한다. 전일과 오늘의 주가가 동일하다면 가격이 하락한 것이 아니다. 1월 14일의 자산은 (현금 + 1월 14일의 주가 × 주식 수)로 계산한다. 1월 14일 기준 준현이의 자산이 더 크다면 \u0026ldquo;BNP\u0026quot;를, 성민이의 자산이 더 크다면 \u0026ldquo;TIMING\u0026quot;을 출력한다. Stack, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 100 10 20 23 34 55 30 22 19 12 45 23 44 34 38 실행결과 BNP ⌨️ 문제 풀이 문제에서 요구한 33 매매법의 세가지 룰을 먼저 정리하고 구현을 하면 좋습니다. 🖥 소스 코드 from sys import stdin m = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) jm, sm, j, s, status = m, m, 0, 0, [0, \u0026#39;\u0026#39;] yesterday = arr[0] for i in range(14): # 준현 if jm // arr[i] != 0: temp = jm // arr[i] j += (jm // arr[i]) jm -= temp * arr[i] # 성민 change = 0 if yesterday \u0026lt; arr[i]: if status[1] == \u0026#39;-\u0026#39;: change = 1 status[1] = \u0026#39;+\u0026#39; elif yesterday \u0026gt; arr[i]: if status[1] == \u0026#39;+\u0026#39;: change = 1 status[1] = \u0026#39;-\u0026#39; yesterday = arr[i] if change: status[0] = 1 elif status[1] != \u0026#39;\u0026#39;: status[0] += 1 if status[0] \u0026gt;= 3: if status[1] == \u0026#39;+\u0026#39;: if sm // arr[i] != 0: sm += s * arr[i] s = 0 if status[1] == \u0026#39;-\u0026#39;: temp = sm // arr[i] s += (sm // arr[i]) sm -= temp * arr[i] last_day = arr[-1] sm += (s * last_day) jm += (j * last_day) if sm == jm: print(\u0026#34;SAMESAME\u0026#34;) elif sm \u0026gt; jm: print(\u0026#34;TIMING\u0026#34;) else: print(\u0026#34;BNP\u0026#34;) 💾 느낀점 단순한 구현문제였다. 문제를 잘 읽고 문제를 압축하고 정리하는 연습이 필요하겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-20546-%EA%B8%B0%EC%A0%81%EC%9D%98-%EB%A7%A4%EB%A7%A4%EB%B2%95-with-python-copy/","summary":"📌 BOJ 20546 🐜 기적의 매매법 🐜 💡 조건 모든 거래는 전량 매수와 전량 매도로 이루어진다. 현재 가지고 있는 현금이 100원이고 주가가 11원이라면 99원어치의 주식을 매수하는 것이다. 단, 현금이 100원 있고 주가가 101원이라면 주식을 살 수 없다. 성민이는 빚을 내서 주식을 하지는 않는다. 3일 연속 가격이 전일 대비 상승하는 주식은 다음날 무조건 가격이 하락한다고 가정한다. 따라서 현재 소유한 주식의 가격이 3일째 상승한다면, 전량 매도한다. 전일과 오늘의 주가가 동일하다면 가격이 상승한 것이 아니다.","title":"[BOJ] 20546 🐜 기적의 매매법 🐜 with Python"},{"content":"\n📌 BOJ 13900 순서쌍의 곱의 합 💡 조건 N개의 정수 중 서로 다른 위치의 두 수를 뽑는 모든 경우의 두 수의 곱을 구하라. (2 ≤ N ≤ 100,000)\nN개의 정수는 (0 \u0026lt;= x \u0026lt;= 100000) 수학 유형의 문제 🔖 예제 및 실행결과 예제 3 2 3 4 실행결과 26 ⌨️ 문제 풀이 숫자의 개수 N을 입력 받고, N개의 정수를 입력받아 list 에 저장한다.\n결과를 출력할 r 이라는 변수를 생성하고, N개의 정수를 입력받아 저장한 list를 sum() 함수를 사용해\ns에 저장한다. 순서쌍의 곱은 아래와 같이 나타낼 수 있다. 만약 a, b, c, d의 숫자가 있다고 가정한다면\na * b + a * c + a * d로 나타낼 수 있다. 쉽게 표현하자면, ab + ac + ad 로 표현할 수 있다. 2번에서 표현한 식을 결합법칙을 통해 묶어주게 된다면 아래와 같이 변한다.\na(b+c+d) 여기서 (b+c+d) 는 s-a[i]라고 할 수 있다.\n그래서 결국 식은 a[i] * (s - a[i]) 과 같으며, r에 쭉 더해준다. 여기서, ab는 ba와 같은데 표현은 저렇게 할 수 있다는 것을 기억해야한다.\n그러므로 r // 2를 통해 반으로 나누어 주면 답이 출력 될 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) a = list(map(int, stdin.readline().split())) r, s = 0, sum(a) for i in range(n): r += a[i] * (s - a[i]) print(r // 2) 💾 느낀점 결합법칙이 중요합니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-13900-%EC%88%9C%EC%84%9C%EC%8C%8D%EC%9D%98-%EA%B3%B1%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 13900 순서쌍의 곱의 합 💡 조건 N개의 정수 중 서로 다른 위치의 두 수를 뽑는 모든 경우의 두 수의 곱을 구하라. (2 ≤ N ≤ 100,000)\nN개의 정수는 (0 \u0026lt;= x \u0026lt;= 100000) 수학 유형의 문제 🔖 예제 및 실행결과 예제 3 2 3 4 실행결과 26 ⌨️ 문제 풀이 숫자의 개수 N을 입력 받고, N개의 정수를 입력받아 list 에 저장한다.\n결과를 출력할 r 이라는 변수를 생성하고, N개의 정수를 입력받아 저장한 list를 sum() 함수를 사용해","title":"[BOJ] 13900 순서쌍의 곱의 합 with Python"},{"content":"\n📌 BOJ 14620 꽃길 💡 조건 꽃밭은 N * N 의 격자 모양이고, 씨앗을 (1, 1) ~ (N, N)의 지점 중 한곳에 심을 수 있다.\n1년 후 상하좌우로 꽃잎이 펼쳐진다. 어떤 씨앗이 꽃이 핀 뒤, 다른 꽃잎 혹은 꽃술과 닿게 될 경우 꽃이 둘 다 죽어버린다. 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하려고 한다.\n진아가 꽃을 심을 수 있는 최소비용을 구하는 문제이다. 한 변의 길이 N(6 ≤ N ≤ 10) 화단의 지점당 가격(0 ≤ G ≤ 200) 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 0 2 3 3 4 1 1 1 1 1 1 0 0 1 1 1 1 3 9 9 0 1 99 9 11 3 1 0 3 12 3 0 0 0 1 실행결과 12 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n = int(stdin.readline()) arr = [] res = [int(1e9)] visited = set() dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) def solve(cnt, cost, v): if cnt == 3: res[0] = min(res[0], cost) else: for i in range(1, n - 1): for j in range(1, n - 1): temp_visit = set() temp_visit.add((i, j)) tf = 1 temp = arr[i][j] for k in range(4): nx, ny = i + dx[k], j + dy[k] if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; n: if (nx, ny) not in v: temp += arr[nx][ny] temp_visit.add((nx, ny)) else: tf = 0 break else: tf = 0 break if tf and temp_visit: v.update(temp_visit) solve(cnt + 1, cost + temp, v) v -= temp_visit solve(0, 0, visited) print(*res) ⌨️ 문제 풀이 DFS 알고리즘을 사용했다. 심은 씨앗이 3개가 되지 않으면, 계속 씨앗을 심어준다.\n전체 좌표를 순회하면서 작업을 한다. 씨앗을 심은 부분을 기준으로 상하좌우의 좌표를 visited 집합 자료형에 넣어주어서,\nvisited의 좌표들에도 씨앗을 심을 수 없게 한다. solve(심은 씨앗의 갯수, 화단을 빌리는 비용, 꽃잎이 피어 심을 수 없는 구역들) 에 심은 씨앗의 개수를 하나씩 늘려준다. 심은 씨앗이 3개가 된다면 최소비용인지 확인하여 res 값에 저장한다. 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14620-%EA%BD%83%EA%B8%B8-with-python/","summary":"📌 BOJ 14620 꽃길 💡 조건 꽃밭은 N * N 의 격자 모양이고, 씨앗을 (1, 1) ~ (N, N)의 지점 중 한곳에 심을 수 있다.\n1년 후 상하좌우로 꽃잎이 펼쳐진다. 어떤 씨앗이 꽃이 핀 뒤, 다른 꽃잎 혹은 꽃술과 닿게 될 경우 꽃이 둘 다 죽어버린다. 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하려고 한다.\n진아가 꽃을 심을 수 있는 최소비용을 구하는 문제이다. 한 변의 길이 N(6 ≤ N ≤ 10) 화단의 지점당 가격(0 ≤ G ≤ 200) 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 0 2 3 3 4 1 1 1 1 1 1 0 0 1 1 1 1 3 9 9 0 1 99 9 11 3 1 0 3 12 3 0 0 0 1 실행결과 12 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n = int(stdin.","title":"[BOJ] 14620 꽃길 with Python"},{"content":"\n📌 BOJ 1411 비슷한 단어 💡 조건 문자열 A를 숌스럽게 바꾸어 B로 만들었다면, 그 단어는 비슷한 단어라고한다. 숌스럽게 바꾼다는 것은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다. 단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 문제. 단어의 길이는 최대 50\nN은 100보다 작거나 같은 자연수이다.\n모든 단어의 길이는 같고, 중복되지 않는다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 12 cacccdaabc cdcccaddbc dcdddbccad bdbbbaddcb bdbcadbbdc abaadcbbda babcdabbac cacdbaccad dcddabccad cacccbaadb bbcdcbcbdd bcbadcbbca 실행결과 13 ⌨️ 문제 풀이 가능한 각 단어들의 쌍을 combinations 함수를 사용해 만들고 순차적으로 순회한다.\n이미 변환했던 단어를 저장할 집합 자료형 use를 생성하고, 단어의 길이만큼 순회하면서 아래의 조건에 해당하는지 확인한다.\n순회하고 있는 알파벳이 서로 같지않고, a[i]번 째 단어가 사용되지 않고, change에 없다. 2번에 있는 조건이 참일 경우\nchange[a[i]] = b[i] use.add(b[i]) a[i] = b[i] 2번에 있는 조건이 거짓일 경우, a[i]가 change에 있는지 확인한다.\n참일 경우, a[i] = change[a[i]] 4번의 조건이 거짓일 경우, a[i]가 use에 있는지 확인한다.\n있는 경우에 tf를 False로 저장하고, 반복문을 멈춘다.\n없는 경우는 아래의 코드를 실행한다.\nchange[a[i]] = b[i] use.add(b[i]) 순회를 마치면 a와 b가 같은지, tf가 True인지 확인한다.\n참이면, 문자열 쌍을 배열에 저장한다.\n배열의 길이를 출력한다.\n🖥 소스 코드 from sys import stdin from itertools import combinations words = [] res = set() tc = int(stdin.readline()) if tc == 1: print(res) else: for _ in range(tc): words.append(stdin.readline().rstrip()) for pair in list(set(combinations(words, 2))): change = dict() use = set() tf = True x, y = pair a, b = pair a, b = list(a), list(b) n, m = len(a), len(b) if n != m: continue else: for i in range(n): if a[i] != b[i] and b[i] not in use and a[i] not in change: change[a[i]] = b[i] use.add(b[i]) a[i] = b[i] else: if a[i] in change: a[i] = change[a[i]] else: if a[i] in use: tf = False break else: change[a[i]] = b[i] use.add(b[i]) if a == b and tf: res.add((x, y)) print(len(res)) 💾 느낀점 실버 II 티어의 문제인데, 생각보다 조건이 까다로워서 구현하는데에 애를 먹었다. 생각보다 부르트포스 알고리즘 유형이 풀기 까다롭다는 생각을 하게 된 문제였다 ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1411-%EB%B9%84%EC%8A%B7%ED%95%9C-%EB%8B%A8%EC%96%B4-with-python/","summary":"📌 BOJ 1411 비슷한 단어 💡 조건 문자열 A를 숌스럽게 바꾸어 B로 만들었다면, 그 단어는 비슷한 단어라고한다. 숌스럽게 바꾼다는 것은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다. 단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 문제. 단어의 길이는 최대 50\nN은 100보다 작거나 같은 자연수이다.\n모든 단어의 길이는 같고, 중복되지 않는다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 12 cacccdaabc cdcccaddbc dcdddbccad bdbbbaddcb bdbcadbbdc abaadcbbda babcdabbac cacdbaccad dcddabccad cacccbaadb bbcdcbcbdd bcbadcbbca 실행결과 13 ⌨️ 문제 풀이 가능한 각 단어들의 쌍을 combinations 함수를 사용해 만들고 순차적으로 순회한다.","title":"[BOJ] 1411 비슷한 단어 with Python"},{"content":"\n📌 BOJ 1515 수 이어 쓰기 💡 조건 1부터 N까지 모든 수를 차례대로 공백없이 한 줄에 다 썼다. 다솜이가 숫자의 일부를 지웠고, 지워지기 전의 숫자를 다시 쓰려고 하니 N이 기억나지 않는다. 남은 수를 이어 붙인 수가 주어질 경우, N의 최솟값을 구하는 문제. 일부 숫자를 지우고 남은 수를 이어붙인 수가 주어지며, 이 수는 최대 3000자리. 구현, 문자열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 00000000000000000000000000000000000000000000000000000000000000000000000 실행결과 400 ⌨️ 문제 풀이 1부터 수를 늘려가면서 완전탐색을 실행하면 된다.\ni, s 는 각각 1과 '' 로 초기화 한 뒤, while 1: 반복으로 i를 늘려주며 순회한다. s 에 str(i)를 이어 붙이고 check() 함수에서 검사를 실시한다. check 함수에서는 사용자에게 입력받은 data와 while 반복문을 통해서 이어 붙인 숫자의 길이를 검사한다.\n만약, 길이가 같지 않으면 ' '를 리턴해준다.\n만약, 길이가 같다면 data 배열과 이어 붙인 숫자의 각 자리를 검사하여 틀린것은 pop() 으로 빼준다\n길이가 같은 경우, 각 자리가 모두 동일했다면 chk 변수는 0이고 data의 길이만큼 반환\n길이가 다른 경우, 각 자리를 검사하고 pop()을 사용해 숫자를 뺀 이어 붙인 수를 반환 check 함수에서 반환받은 tf 변수는 ' ' 혹은 3번의 결과값을 가지고 있다.\n만약 tf 변수가 data의 길이와 tf의 길이 중 짧은 길이만큼 잘라냈을 때, data의 길이와 같다면\n현재의 i를 출력해주고 while을 종료한다. 4번에서 종료가 안되었고 tf 가 ' '과 다르다면, s는 tf로 저장해주고, i 를 1만큼 증가시켜준다. 이 때 tf는 이어 붙인 수에서 숫자를 지운 상태이다.* 4번에서 종료가 안되었고, tf 가 ' '과 같다면, i 를 1만큼 증가시켜준다. data 변수와 단 한자리도 같지 않아 이어 붙인 수가 pop()에 의해 다 뽑힌 것.* 🖥 소스 코드 from sys import stdin data = stdin.readline().rstrip() s, i = \u0026#39;\u0026#39;, 1 def check(s): t = list(s) k = list(data) while 1: if len(t) \u0026lt; len(data): return \u0026#39; \u0026#39; else: i = 0 chk = 0 while 1: if i \u0026gt;= len(k) or i \u0026gt;= len(t): if chk: return \u0026#39;\u0026#39;.join(t) else: return \u0026#39;\u0026#39;.join(t[:len(data)]) if t[i] != k[i]: t.pop(i) chk = 1 else: i += 1 while 1: s += str(i) # check tf = check(s) if tf[:min(len(tf), len(data))] == data: print(i) break # tf = False if tf != \u0026#39; \u0026#39;: s = tf i += 1 else: i += 1 💾 느낀점 틀렸습니다와 런타임에러가 날 괴롭혔다.\n그 이유는 아래와 같다. 문자열을 이어 붙이다 보면 10의 자리를 붙이게 되는데 그 순간 data 변수의 길이보다 이어 붙인 수의 길이가 길어질 때 검사하다가 오류. 반환할 때도 이미 data 변수와 길이가 같거나 혹은 길이가 길게나와서 답도 제대로 안나왔다. 인덱싱에 매우 약하다. 이를 극복하려면 반복 밖에는 없을 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1515-%EC%88%98-%EC%9D%B4%EC%96%B4-%EC%93%B0%EA%B8%B0-with-python/","summary":"📌 BOJ 1515 수 이어 쓰기 💡 조건 1부터 N까지 모든 수를 차례대로 공백없이 한 줄에 다 썼다. 다솜이가 숫자의 일부를 지웠고, 지워지기 전의 숫자를 다시 쓰려고 하니 N이 기억나지 않는다. 남은 수를 이어 붙인 수가 주어질 경우, N의 최솟값을 구하는 문제. 일부 숫자를 지우고 남은 수를 이어붙인 수가 주어지며, 이 수는 최대 3000자리. 구현, 문자열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 00000000000000000000000000000000000000000000000000000000000000000000000 실행결과 400 ⌨️ 문제 풀이 1부터 수를 늘려가면서 완전탐색을 실행하면 된다.","title":"[BOJ] 1515 수 이어 쓰기 with Python"},{"content":"\n📌 BOJ 2615 오목 💡 조건 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있다. board의 크기는 19 * 19\n검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시\n가로, 세로 또는 대각선 방향 모두 포함해서 같은 색의 바둑돌이 5개 놓여져 있다면 승리한다.\n5개 초과 또는 미만의 개수는 승리할 수 없다\n검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성.\n검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력\n은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알의 가로줄, 세로줄 번호를 출력한다.\n세로로 놓인 경우, 그 중 가장 위에 있는 바둑알의 가로, 세로줄 번호를 출력한다. 브루트포스 알고리즘 \u0026amp; 구현 유형의 문제\n🔖 예제 및 실행결과 예제 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 2 2 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 실행결과 1 3 2 ⌨️ 문제 풀이 바둑판은 19 * 19의 크기로 제한되어 있다. solve() 함수에서 이중 반복문으로 바둑판의 칸을 모두 순회한다.\n순회하면서 검은 바둑돌이 놓여진 곳과 흰 바둑알이 놓여진 곳을 발견하게 된다면, check() 함수를 호출한다.\ncheck(돌의 색, x 좌표, y 좌표)\n의 형식으로 호출하여 반환 받은 결과가 빈 배열이 아니라면, 이긴 바둑 돌의 색의 번호와 바둑돌의 좌표들을 반환한다. check() 함수는 오른쪽, 아래, 좌측 아래, 우측 아래의 네 방향을 검사한다.\n입력받은 좌표를 기준으로 위에서 말한 네 방향을 검사하면서, 넘겨받은 바둑돌의 색깔과 일치하는 돌이 있다면\nres 집합 자료형 변수에 넣어주고, 5개인지 확인하여 맞다면 res를 list로 변환하여 반환, 아니라면 반복문을 종료한다.\nsolve() 함수 호출 후 작업이 끝났다면, code 와 v를 반환받게 되는데,\ncode는 이긴 바둑돌을 뜻하며 v는 바둑돌의 좌표들을 뜻한다.\n세로로 세워진 바둑돌인지 확인 한 후, tf의 값에 따라 v를 정렬하고 이긴 바둑돌의 색과 좌표를 출력한다.\ntf 가 1일 때, 세로로 놓여진 다섯개의 바둑돌이다.\ntf 가 0일 때, 세로가 아닌 방향으로 놓여진 바둑돌이다.\nsolve() 함수에 반환받은 v가 False 라면 무승부이기 때문에 0을 출력한다.\n🖥 소스 코드 from sys import stdin dx, dy = [0, 1, 1, 1], [1, 0, -1, 1] board = [] visited = [set() for _ in range(4)] for i in range(19): board.append(list(map(int, stdin.readline().split()))) def check(code, i, j): for z in range(4): cnt = 1 res = set() res.add((i, j)) nx, ny = i + dx[z], j + dy[z] while 1: if 0 \u0026lt;= nx \u0026lt; 19 and 0 \u0026lt;= ny \u0026lt; 19: if board[nx][ny] == code and ((nx, ny) not in visited[z]): cnt += 1 res.add((nx, ny)) visited[z].add((nx, ny)) nx += dx[z] ny += dy[z] else: if cnt == 5: return list(res) else: break else: if cnt == 5: return list(res) break return [] def solve(): for i in range(19): for j in range(19): if board[i][j] == 1: v = check(1, i, j) if v: return 1, v elif board[i][j] == 2: v = check(2, i, j) if v: return 2, v return 0, False code, v = solve() if v is False: print(0) else: tf = 1 x = v[0][1] for i in range(1, 5): if x != v[i][1]: tf = 0 break if tf: v.sort(key=lambda x: (x[0])) print(code) print(*(v[0][0] + 1, v[0][1] + 1)) else: print(code) v.sort(key=lambda x: (x[1])) print(*(v[0][0] + 1, v[0][1] + 1)) 💾 느낀점 바둑돌이 여섯개 일 때 조건문을 통해 걸러내는 법에서 헤맸다. 구현을 할 때 조금 더 꼼꼼히 생각해보자. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2615-%EC%98%A4%EB%AA%A9-with-python/","summary":"📌 BOJ 2615 오목 💡 조건 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있다. board의 크기는 19 * 19\n검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시\n가로, 세로 또는 대각선 방향 모두 포함해서 같은 색의 바둑돌이 5개 놓여져 있다면 승리한다.\n5개 초과 또는 미만의 개수는 승리할 수 없다\n검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성.\n검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력","title":"[BOJ] 2615 오목 with Python"},{"content":"\n📌 Programmers 블록 이동하기 with Python 💡 조건 board의 한 변의 길이는 5 이상 100 이하.\nboard의 원소는 0(이동가능 블록) 또는 1(이동불가 벽). 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어진다. 로봇은 회전할 수 있다. BFS, 시뮬레이션의 문제 (N, N) 좌표까지 도달하는 최소시간을 구하는 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]])) 실행결과 7 🖥 소스 코드 from collections import deque def get_next_pos(pos, board): next_pos = [] pos = list(pos) pos1_x, pos1_y, pos2_x, pos2_y = pos[0][0], pos[0][1], pos[1][0], pos[1][1] dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1] for i in range(4): pos1_next_x, pos1_next_y, pos2_next_x, pos2_next_y = pos1_x + dx[i], pos1_y + dy[i], pos2_x + dx[i], pos2_y + dy[i] if board[pos1_next_x][pos1_next_y] == 0 and board[pos2_next_x][pos2_next_y] == 0: next_pos.append({(pos1_next_x, pos1_next_y), (pos2_next_x, pos2_next_y)}) if pos1_x == pos2_x: for i in [-1, 1]: if board[pos1_x + i][pos1_y] == 0 and board[pos2_x + i][pos2_y] == 0: next_pos.append({(pos1_x, pos1_y), (pos1_x + i, pos1_y)}) next_pos.append({(pos2_x, pos2_y), (pos2_x + i, pos2_y)}) elif pos1_y == pos2_y: for i in [-1, 1]: if board[pos1_x][pos1_y + i] == 0 and board[pos2_x][pos2_y + i] == 0: next_pos.append({(pos1_x, pos1_y), (pos1_x, pos1_y + i)}) next_pos.append({(pos2_x, pos2_y), (pos2_x, pos2_y + i)}) return next_pos def solution(board): n = len(board) new_board = [[1] * (n + 2) for _ in range(n + 2)] for i in range(n): for j in range(n): new_board[i + 1][j + 1] = board[i][j] q = deque() visited = [] pos = {(1, 1), (1, 2)} q.append((pos, 0)) visited.append(pos) while q: pos, cost = q.popleft() if (n, n) in pos: return cost for next_pos in get_next_pos(pos, new_board): if next_pos not in visited: q.append((next_pos, cost + 1)) visited.append(next_pos) return 0 ⌨️ 문제 풀이 가장 먼저, (n * n) 크기의 맵을 (n + 2) * (n + 2) 맵으로 새로 만들어\n맵 주변을 1로 둘러주어 이동하지 못하는 곳을 확실히 만들어준다. 시작 위치는 {(1, 1), (1, 2)} 로 pos에 저장한 뒤 큐에 넣는다.\n물론 방문한 기록을 남길 visited 리스트에도 저장한다. BFS의 방식으로 Queue가 빌 때까지 순회를 한다.\n단, 현재 위치에서 이동이 가능하거나 회전이 가능한 위치를 큐에 저장한다. 3번에서 말한 이동 및 회전이 가능한 좌표는 함수 get_next_pos()에서 반환하는 좌표값들을 기준으로 한다. get_next_pos 에서는 현재 위치에서 이동 및 가능한 좌표를 반환하는데, 아래의 조건을 잘 확인해야한다. 상하좌우 네 방향으로 이동이 가능한지 현재 로봇이 가로로 놓여져 있는 경우 회전이 가능한지 현재 로봇이 세로로 놓여져 있는 경우 회전이 가능한지 get_next_pos 에서 반환받은 좌표들 중, 이미 방문한 장소가 아니라면 방문처리를 하고 cost(걸린 시간) 을 큐와 함께 넣어준다. 💾 느낀점 로봇이 90도 회전하는 좌표에 대해서 처리하고 반환하는 것이 어려웠다. 좌표 계산이 헷갈려 힘이 들었다. 좌표 및 인덱싱에 대해 연습이 많이 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EB%B8%94%EB%A1%9D-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-with-python/","summary":"📌 Programmers 블록 이동하기 with Python 💡 조건 board의 한 변의 길이는 5 이상 100 이하.\nboard의 원소는 0(이동가능 블록) 또는 1(이동불가 벽). 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어진다. 로봇은 회전할 수 있다. BFS, 시뮬레이션의 문제 (N, N) 좌표까지 도달하는 최소시간을 구하는 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]])) 실행결과 7 🖥 소스 코드 from collections import deque def get_next_pos(pos, board): next_pos = [] pos = list(pos) pos1_x, pos1_y, pos2_x, pos2_y = pos[0][0], pos[0][1], pos[1][0], pos[1][1] dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1] for i in range(4): pos1_next_x, pos1_next_y, pos2_next_x, pos2_next_y = pos1_x + dx[i], pos1_y + dy[i], pos2_x + dx[i], pos2_y + dy[i] if board[pos1_next_x][pos1_next_y] == 0 and board[pos2_next_x][pos2_next_y] == 0: next_pos.","title":"[Programmers] 블록 이동하기 with Python"},{"content":"\n📌 BOJ 11497 통나무 건너뛰기 💡 조건 첫 줄에 통나무의 개수를 나타내는 정수 (5 ≤ N ≤ 10,000)\n둘째 줄에 각 통나무의 높이를 나타내는 정수 (1 ≤ Li ≤ 100,000) 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다.\n가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 그리디 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 3 7 13 10 12 11 10 11 12 5 2 4 5 7 9 8 6 6 6 6 6 6 6 6 실행결과 1 4 0 ⌨️ 문제 풀이 단순히 정렬을 해도 되지만, 첫 통나무와 마지막 통나무가 인접해있다는 조건이 있다. 1번에서 말한 조건 때문에, 가장 큰 값을 기준으로 양쪽에 점점 작게 배치를 하면\n크기의 차이를 가장 많이 줄일 수 있다. 즉, 인덱스 값이 2씩 차이나는 값들 중 가장 큰 값이 최대 높이 차가 된다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() res = 0 for i in range(2, n): res = max(res, abs(arr[i] - arr[i-2])) print(res) 💾 느낀점 문제 풀이에서 2번과 3번에 대해서 이해하지 못해서 힘이 들었다. 이해하고 다시 풀어보기를 반복해야할 문제이다. 2021/12/06 다시 풀어보았는데 또 틀렸다. 해설을 보니 기억이 나긴하는데 또 이해가 안된다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-11497-%ED%86%B5%EB%82%98%EB%AC%B4-%EA%B1%B4%EB%84%88%EB%9B%B0%EA%B8%B0-with-python/","summary":"📌 BOJ 11497 통나무 건너뛰기 💡 조건 첫 줄에 통나무의 개수를 나타내는 정수 (5 ≤ N ≤ 10,000)\n둘째 줄에 각 통나무의 높이를 나타내는 정수 (1 ≤ Li ≤ 100,000) 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다.\n가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 그리디 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 3 7 13 10 12 11 10 11 12 5 2 4 5 7 9 8 6 6 6 6 6 6 6 6 실행결과 1 4 0 ⌨️ 문제 풀이 단순히 정렬을 해도 되지만, 첫 통나무와 마지막 통나무가 인접해있다는 조건이 있다.","title":"[BOJ] 11497 통나무 건너뛰기 with Python"},{"content":"\n📌 Programmers 외벽 점검 with Python 💡 조건 외벽의 총 둘레길이 (1 \u0026lt;= n \u0026lt;= 200)\n취약 지점의 위치가 담긴 배열 (1\u0026lt; = weak \u0026lt;= 15) 서로 다른 두 취약점의 위치가 같을 경우는 없다. 취약지점의 위치는 오름차순이다. (0 \u0026lt;= weak의 원소 \u0026lt;= n-1) 친구가 1시간 동안 이동할 수 있는 거리 (1\u0026lt;= dist \u0026lt;= 8) 친구들을 최소한으로 투입시켜서 외벽 점검을 해야한다.\n만약 친구들이 모두 투입되어도 외벽을 모두 점검할 수 없다면, -1을 출력. 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 print(solution(12, [1, 5, 6, 10], [1, 2, 3, 4], 2)) 실행결과 2 ⌨️ 문제 풀이 점검 해야할 외벽의 길이를 구하기 위해 weak의 길이를 leng 이라는 변수에 담아준다.\n총 n 만큼의 외벽이 있으니, weak 의 길이만큼 순회하면서 weak 의 원소에 n을 더하여\n원형 모양의 외벽을 펼쳐준다고 생각하자.\nanswer의 값은 점검을 투입할 수 있는 친구들의 수(dist의 길이)보다 1 많게 저장한다.\n이 과정이 있어야 모두 투입시켜도 안될 때 -1을 출력하게 할 수 있다.\n취약점 어디서부터 시작할지에 따라서 인원의 수가 적어질 수도, 많아질 수도 있다.\n그렇기 때문에 start(출발지점) 을 weak의 길이만큼 순회시켜 돌게하고,\n친구들이 투입될 순서는 permutations 함수를 통해 변경한다.\ncount = 0으로 초기화 한 뒤, position을 정한다.\n취약점 배열에서 start 번째에서\n친구들의 1시간동안 이동거리를 permutations로 뽑아낸 배열의 count - 1 번째의 값을\n빼준 것이 position 값이다.\n그렇다면, 취약점 시작부분(start) 부터 취약점 시작부분(start) + 취약점의 개수(leng)까지 순회하면서(index)\n현재 포지션 값이 취약점배열의 index에 해당하는 값보다 작다면 count += 1 을 해준다.\ncount 가 혹시 친구의 수를 넘었다면 바로 중단한다.\n그게 아니라면 작업을 한 후, position을 갱신한다.\nanswer 와 count 중에 가장 작은 것을 answer에 담아 갱신한 뒤, answer가 dist의 길이보다 크다면 -1을 반환하고\n그게 아니라면 answer를 반환한다.\n🖥 소스 코드 from itertools import permutations def solution(n, weak, dist): leng = len(weak) for x in range(leng): weak.append(weak[x] + n) answer = len(dist) + 1 for start in range(leng): for friends in list(permutations(dist, len(dist))): count = 0 position = weak[start] - friends[count - 1] for index in range(start, start + leng): if position \u0026lt; weak[index]: count += 1 if count \u0026gt; len(dist): break position = weak[index] + friends[count - 1] answer = min(answer, count) if answer \u0026gt; len(dist): return -1 return answer 💾 느낀점 외벽을 평면으로 펼칠 아이디어를 떠올리지 못하고 해설을 본 후 큰 충격을 받았다. 이후, 외벽 점점을 해야할 취약점 중 한 부분을 골라 취약점의 길이만큼 점검하는 로직을 구현하는데에\n많은 노력과 긴 시간이 필요했다. 스스로 구현이 약하다는 것을 알고 있다. 조금 더 구현할 때 그림을 그리긋 설계하고, 짧아도 구현계획을 써내려가야겠다. 스스로 검증하는 부분에서 큰 약점이 있다는 것을 느꼈다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EC%99%B8%EB%B2%BD-%EC%A0%90%EA%B2%80-with-python/","summary":"📌 Programmers 외벽 점검 with Python 💡 조건 외벽의 총 둘레길이 (1 \u0026lt;= n \u0026lt;= 200)\n취약 지점의 위치가 담긴 배열 (1\u0026lt; = weak \u0026lt;= 15) 서로 다른 두 취약점의 위치가 같을 경우는 없다. 취약지점의 위치는 오름차순이다. (0 \u0026lt;= weak의 원소 \u0026lt;= n-1) 친구가 1시간 동안 이동할 수 있는 거리 (1\u0026lt;= dist \u0026lt;= 8) 친구들을 최소한으로 투입시켜서 외벽 점검을 해야한다.\n만약 친구들이 모두 투입되어도 외벽을 모두 점검할 수 없다면, -1을 출력.","title":"[Programmers] 외벽 점검 with Python"},{"content":"\n📌 BOJ 2841 외계인의 기타 연주 💡 조건 멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생. 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000) 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다. 손가락의 가장 적게 움직이는 회수를 구하는 프로그램을 작성. Stack, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 7 15 1 5 2 3 2 5 2 7 2 4 1 5 1 3 실행결과 9 ⌨️ 문제 풀이 기타의 줄을 의미하는 stack 2차원 리스트를 생성한다.\n스택의 각 원소에 해당하는 리스트에는 누르고 있는 프렛 숫자 데이터가 저장된다. 입력을 받으면서, 프렛 숫자를 각 줄에 해당하는 리스트에 저장한다. 입력받은 줄에 해당하는 리스트에 이미 누르고 있는 프렛에 해당하는 데이터가 있다면,\n입력받은 프렛 번호가 이미 누르고 있는 프렛의 번호보다 작아질 때까지 pop()을 해주면서 res += 1을 해준다.\n만약 pop() 을 할 필요가 없다면 바로 추가해준다. 프렛의 번호가 겹치면 더 해당 줄에 프렛 번호를 추가하지 않고, 겹치지 않는다면 추가하고, res += 1을 해준다. n만큼 반복했다면, res 를 출력한다. 🖥 소스 코드 from sys import stdin import heapq n, p = map(int, stdin.readline().split()) stack = [[] for _ in range(7)] res = 0 for _ in range(n): j, f = map(int, stdin.readline().split()) if not stack[j]: heapq.heappush(stack[j], f) res += 1 elif stack[j][-1] \u0026lt; f: heapq.heappush(stack[j], f) res += 1 elif stack[j][-1] \u0026gt; f: while 1: if not stack[j]: res += 1 stack[j].append(f) break if stack[j][-1] \u0026lt;= f: if stack[j][-1] \u0026lt; f: heapq.heappush(stack[j], f) res += 1 break stack[j].pop() res += 1 print(res) 💾 느낀점 stack 자료구조를 활요하는 문제였다. 아이디어를 떠올리기까지 시간이 꽤 걸린 문제였다. stack 의 개념을 알면, 이를 다양한 방면으로 활용할 수 있다는 것을 알게 해주었다. 자료구조 문제는 좋은 아이디어를 떠올릴 수 있게 많이 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2841-%EC%99%B8%EA%B3%84%EC%9D%B8%EC%9D%98-%EA%B8%B0%ED%83%80-%EC%97%B0%EC%A3%BC-with-python/","summary":"📌 BOJ 2841 외계인의 기타 연주 💡 조건 멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생. 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000) 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다.","title":"[BOJ] 2841 외계인의 기타 연주 with Python"},{"content":"\n📌 BOJ 6118 숨바꼭질 💡 조건 헛간의 개수 (2 \u0026lt;= N \u0026lt;= 20,000), 1부터 세아린다. 모든 헛간은 (1\u0026lt;= M \u0026lt;= 50,000)개의 양방향 길로 이어져 있다. 냄새는 1번 헛간에서의 거리가 멀어질수록 감소한다.\n거리 = 지나야 하는 길의 최소 개수. 숨어야 하는 가장 거리가 먼 헛간 번호, 가장 거리가 먼 헛간까지의 거리, 가장 거리가 먼 헛간과 같은 거리를 가지는 헛간의 수\n를 차례대로 출력하며, 가장 거리가 먼 헛간 번호가 여러개라면 가장 작은 수를 출력한다. **너비 우선 탐색(BFS)**유형의 문제 🔖 예제 및 실행결과 예제 6 7 3 6 4 3 3 2 1 3 1 2 2 4 5 2 실행결과 4 2 3 ⌨️ 문제 풀이 양방향으로 움직일 수 있는 노드들을 연결하기 위해 2차원 리스트인 arr을 생성한 후 데이터를 입력한다. 결과 값을 저장하고, 헛간의 번호를 의미하는 res 2차원 리스트를 생성한다.\n가장 먼 헛간의 거리를 저장할 max_dist 변수도 생성한다. 너비 우선 탐색 알고리즘을 호출하는데, 큐에는 (거리, 노드번호)를 넣어준다.\n큐가 빌 때까지 반복하면서, 해당 헛간과 연결되어 있는 헛간을 순차적으로 방문한다.\n큐에서 데이터를 pop() 하여 나온 거리 데이터가 현재 max_dist 보다 크다면 갱신한다. 방문한 헛간은 이미 방문했던 헛간이라는 정보를 저장하기 위해 visited 집합 자료형에 노드번호를 저장한다. 헛간의 거리는 모두 1씩이기에, 큐에 (현재 헛간과의 거리 + 1, 노드번호) 를 저장한다. res 리스트에 거리 + 1에 해당하는 리스트에 노드 번호를 저장한다.\nres 리스트에는 가장 먼 거리에 해당하는 원소 리스트에 같은 거리를 가진 헛간의 번호들이 저장된다. 문제에서 요구한 것들을 출력한다.\n숨어야 하는 헛간의 번호 = min(res[max_dist])\n숨어야 하는 헛간까지의 거리 = max_dist\n숨어야 하는 헛간까지의 거리와 같은 거리를 가진 헛간들 = len(res[max_dist]) 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) arr = [[] for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) arr[a].append(b) arr[b].append(a) res = [[] for _ in range(20001)] max_dist = -1e9 def bfs(n): global max_dist q = deque() q.append((0, n)) visited = set() visited.add(n) while q: dist, now = q.popleft() max_dist = max(max_dist, dist) for node in arr[now]: if node not in visited: visited.add(node) q.append((dist + 1, node)) res[dist + 1].append(node) bfs(1) print(min(res[max_dist]), max_dist, len(res[max_dist])) 💾 느낀점 BFS 응용 문제이기 때문에 풀이를 하는데에는 오래 걸리지 않았다. 그래프 이론 및 BFS 문제는 조금씩 더 풀어서 내것으로 만들어도 더 좋을 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-6118-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88-with-python/","summary":"📌 BOJ 6118 숨바꼭질 💡 조건 헛간의 개수 (2 \u0026lt;= N \u0026lt;= 20,000), 1부터 세아린다. 모든 헛간은 (1\u0026lt;= M \u0026lt;= 50,000)개의 양방향 길로 이어져 있다. 냄새는 1번 헛간에서의 거리가 멀어질수록 감소한다.\n거리 = 지나야 하는 길의 최소 개수. 숨어야 하는 가장 거리가 먼 헛간 번호, 가장 거리가 먼 헛간까지의 거리, 가장 거리가 먼 헛간과 같은 거리를 가지는 헛간의 수\n를 차례대로 출력하며, 가장 거리가 먼 헛간 번호가 여러개라면 가장 작은 수를 출력한다.","title":"[BOJ] 6118 숨바꼭질 with Python"},{"content":"\n📌 BOJ 2304 창고 다각형 💡 조건 기둥의 개수를 나타내는 정수 (1 \u0026lt;= N \u0026lt;= 1000)\n각 기둥의 왼쪽 면의 위치를 나타내는 정수 (1 \u0026lt;= L \u0026lt;= 1000)\n각 기둥의 높이를 나타내는 정수 (1 \u0026lt;= H \u0026lt;= 1000)\n창고 다각형의 면적을 구하는 문제\n모든 기둥이 들어가는 창고를 지으려고 할 때, 지붕이 될 수 있는 조건은 아래와 같다.\n지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다. 지붕의 가장자리는 땅에 닿아야 한다. 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다. 자료구조, 브루트포스 알고리즘유형의 문제\n🔖 예제 및 실행결과 예제 7 2 4 11 4 15 8 4 6 5 3 8 10 13 6 실행결과 98 ⌨️ 문제 풀이 간단하게 생각하면 매우 좋은 문제이다. 문제에서 제시된 그림에서도 보이듯, 기둥들 중에서 가장 높이 값이 큰 기둥이 있다.\n그 가장 높이가 높은 기둥을 중심으로 나누어서 왼쪽에서 오른쪽으로 면적을 구하고, 오른쪽에서 왼쪽으로 면적을 구해 더한 후 출력하면 된다. index를 잘 구별해서 써야 헷길리지 않을 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) max_pillar = -1e9 idx = 0 arr = [[] for _ in range(1001)] res = 0 last_idx = 0 for _ in range(n): a, b = map(int, stdin.readline().split()) if max_pillar \u0026lt; b: max_pillar = b idx = a arr[a].append(b) last_idx = max(last_idx, a) part1 = arr[:idx+1] part2 = arr[idx+1:last_idx+1] now = 0 for i in part1: if not i: res += now else: if now \u0026gt; i[0]: res += now else: now = i[0] res += now part2.reverse() now = 0 for i in part2: if not i: res += now else: if now \u0026gt; i[0]: res += now else: now = i[0] res += now print(res) 💾 느낀점 푼지 조금 오래된 문제이지만, 바로 바자마자 풀이가 생각이 났다. 지금 소스코드를 다시 작성한다면 더 간결하고 이쁘게 구현할 수 있을 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2304-%EC%B0%BD%EA%B3%A0-%EB%8B%A4%EA%B0%81%ED%98%95-with-python/","summary":"📌 BOJ 2304 창고 다각형 💡 조건 기둥의 개수를 나타내는 정수 (1 \u0026lt;= N \u0026lt;= 1000)\n각 기둥의 왼쪽 면의 위치를 나타내는 정수 (1 \u0026lt;= L \u0026lt;= 1000)\n각 기둥의 높이를 나타내는 정수 (1 \u0026lt;= H \u0026lt;= 1000)\n창고 다각형의 면적을 구하는 문제\n모든 기둥이 들어가는 창고를 지으려고 할 때, 지붕이 될 수 있는 조건은 아래와 같다.\n지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.","title":"[BOJ] 2304 창고 다각형 with Python"},{"content":"\n📌 Programmers 자물쇠와 열쇠 with Python 💡 조건 key는 M x M(3 ≤ M ≤ 20, M은 자연수) 크기 2차원 배열\nlock은 N x N(3 ≤ N ≤ 20, N은 자연수) 크기 2차원 배열\nM은 항상 N 이하, key와 lock의 원소는 0 또는 1 자물쇠는 홈이 있으며, 열쇠도 돌기가 있다. 열쇠는 회전이 가능하다. 자물쇠 부분이 회전할 수 있는 열쇠와 겹쳐져서 모두 1이 된다면 열 수 있으니 True, 열 수 없다면 False를 반환 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0], [1, 0, 0], [0, 1, 1]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0]])) 실행결과 true ⌨️ 문제 풀이 N과 M의 최대 크기가 20이니, 열쇠의 최소크기인 3만큼 자물쇠의 길이에 곱해서 맵을 뻥튀기 시킨다.\n이 작업은 열쇠를 움직이기 편하기 위해서 전체 맵의 크기를 키우는 것.\n맵의 크기를 세배로 넓혔다면, 원래 자물쇠를 가운데 위치에 위치시킨다.\nfor i in range(lock_l): for j in range(lock_l): new_lock[i + lock_l][j + lock_l] = lock[i][j] 열쇠는 총 4방향으로 돌 수 있으니, 열쇠를 미리 한 번 돌리고 이동시키면서 자물쇠가 열리는지 체크하면 된다.\nkey = turn_key(key_l, key) def turn_key(l, key): new_key = [item[:] for item in key] for i in range(l): for j in range(l): new_key[i][j] = key[l - (j + 1)][i] return new_key 열쇠를 0, 0 부터 new_lock 의 크기에서 key의 길이만큼 뺀 값까지 이동시키면서 반복순회를 한다. def check(lock, lock_l): for i in range(lock_l): for j in range(lock_l): if lock[i + lock_l][j + lock_l] != 1: return False return True 🖥 소스 코드 def turn_key(l, key): new_key = [item[:] for item in key] for i in range(l): for j in range(l): new_key[i][j] = key[l - (j + 1)][i] return new_key def check(lock, lock_l): for i in range(lock_l): for j in range(lock_l): if lock[i + lock_l][j + lock_l] != 1: return False return True def solution(key, lock): key_l = len(key) lock_l = len(lock) new_lock = [[0] * (lock_l * 3) for _ in range(lock_l * 3)] new_len = len(new_lock) for i in range(lock_l): for j in range(lock_l): new_lock[i + lock_l][j + lock_l] = lock[i][j] for i in range(4): key = turn_key(key_l, key) for i in range(new_len - key_l): for j in range(new_len - key_l): for k in range(key_l): for p in range(key_l): new_lock[i + k][j + p] += key[k][p] if check(new_lock, lock_l): return True else: for k in range(key_l): for p in range(key_l): new_lock[i + k][j + p] -= key[k][p] return False 💾 느낀점 열쇠를 돌리는 것에서 헤맬뻔했지만, 반복 숙달덕에 잘 할 수 있었다. 자물쇠의 전체 크기를 키워서 하는 방법은 N, M 의 크기가 작은 것을 확인하고 생각해낼 수 있었다. 역시 시뮬레이션 \u0026amp; 구현 문제는 어렵다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EC%9E%90%EB%AC%BC%EC%87%A0%EC%99%80-%EC%97%B4%EC%87%A0-with-python/","summary":"📌 Programmers 자물쇠와 열쇠 with Python 💡 조건 key는 M x M(3 ≤ M ≤ 20, M은 자연수) 크기 2차원 배열\nlock은 N x N(3 ≤ N ≤ 20, N은 자연수) 크기 2차원 배열\nM은 항상 N 이하, key와 lock의 원소는 0 또는 1 자물쇠는 홈이 있으며, 열쇠도 돌기가 있다. 열쇠는 회전이 가능하다. 자물쇠 부분이 회전할 수 있는 열쇠와 겹쳐져서 모두 1이 된다면 열 수 있으니 True, 열 수 없다면 False를 반환 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0], [1, 0, 0], [0, 1, 1]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0]])) 실행결과 true ⌨️ 문제 풀이 N과 M의 최대 크기가 20이니, 열쇠의 최소크기인 3만큼 자물쇠의 길이에 곱해서 맵을 뻥튀기 시킨다.","title":"[Programmers] 자물쇠와 열쇠 with Python"},{"content":"\n📌 Programmers 기둥과 보 설치 with Python 💡 조건 5 \u0026lt;= n \u0026lt;= 100\n1 \u0026lt;= 입력받을 기둥과 보의 개수 \u0026lt;= 1000\n`입력받을 기둥 혹은 보의 정보의 데이터 개수 == 4'\n바닥에 보를 설치하는 경우는 없다.\n벽면을 벗어나게 설치하는 경우는 없다.\n구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제한다.\n구조물이 겹치거나, 없는 것을 삭제하는 경우는 없습니다.\n구현\u0026amp;시뮬레이션 문제\n반환하는 데이터는 x, y, 기둥 순으로 정렬하여 반환한다.\n🔖 예제 및 실행결과 예제 n = 5 build_frame = [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] 실행결과 [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] ⌨️ 문제 풀이 build_frame을 순회하면서, 각 frame에서 x, y, a, b 를 구별하여 시뮬레이션을 합니다.\na 는 기둥과 보의 구별, b는 삽입, 삭제의 구별에 사용합니다. 만약 b가 삽입에 해당할 경우, (x, y, a) 를 answer에 저장하고 check()함수를 호출하여\n방금 세운 구조물이 전체적으로 가능한 구조물인지 확인합니다. check 함수에서 False를 반환한 경우, answer에서 (x, y, a)를 삭제합니다.\ncheck 함수에서 True를 반환한 경우, 넘어갑니다. 만약 b가 삭제에 해당할 경우, (x, y, a) 를 answer에서 삭제합니다.\ncheck 함수에서 False를 반환한 경우, answer에서 (x, y, a)를 다시 추가합니다.\ncheck 함수에서 True를 반환한 경우, 넘어갑니다. check 함수에서는 현재 구조물이 정상인지에 대해 판별합니다. 현재 검사하는 구조물의 종류가 보라면 아래의 조건에 해당하지 않는 경우, False를 반환합니다. if y != 0 and([x + 1, y - 1, 0] in answer or [x, y - 1, 0] in answer or ([x - 1, y, 1] in answer and [x + 1, y, 1] in answer)): 현재 검사하는 구조물의 종류가 기둥이라면 아래의 조건에 해당하지 않는 경우, True를 반환합니다. if y == 0 or [x - 1, y, 1] in answer or [x, y, 1] in answer or [x, y - 1, 0] in answer: 🖥 소스 코드 def check(answer): for x, y, a in answer: if a: # 보 \u0026#34;\u0026#34;\u0026#34;보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.\u0026#34;\u0026#34;\u0026#34; if y != 0 and([x + 1, y - 1, 0] in answer or [x, y - 1, 0] in answer or ([x - 1, y, 1] in answer and [x + 1, y, 1] in answer)): continue else: return False else: # 기둥 \u0026#34;\u0026#34;\u0026#34;기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.\u0026#34;\u0026#34;\u0026#34; if y == 0 or [x - 1, y, 1] in answer or [x, y, 1] in answer or [x, y - 1, 0] in answer: continue else: return False return True def solution(n, build_frame): answer = [] for frame in build_frame: x, y, a, b = frame if b: # install answer.append([x, y, a]) if not check(answer): answer.remove([x, y, a]) else: # remove answer.remove([x, y, a]) if not check(answer): answer.append([x, y, a]) return sorted(answer) 💾 느낀점 check 함수를 구현하는 것이 힘이 들었다. 구현 연습은 반복만이 답이 아닌가 싶다. 더 열심히 풀어야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EA%B8%B0%EB%91%A5%EA%B3%BC-%EB%B3%B4-%EC%84%A4%EC%B9%98-with-python/","summary":"📌 Programmers 기둥과 보 설치 with Python 💡 조건 5 \u0026lt;= n \u0026lt;= 100\n1 \u0026lt;= 입력받을 기둥과 보의 개수 \u0026lt;= 1000\n`입력받을 기둥 혹은 보의 정보의 데이터 개수 == 4'\n바닥에 보를 설치하는 경우는 없다.\n벽면을 벗어나게 설치하는 경우는 없다.\n구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제한다.\n구조물이 겹치거나, 없는 것을 삭제하는 경우는 없습니다.\n구현\u0026amp;시뮬레이션 문제\n반환하는 데이터는 x, y, 기둥 순으로 정렬하여 반환한다.","title":"[Programmers] 기둥과 보 설치 with Python"},{"content":"\n📌 Programmers 후보키 with Python 💡 조건 relation 은 2차원 문자열 배열이다.\n1 \u0026lt;= relation 의 컬럼의 길이 \u0026lt;= 8\n1 \u0026lt;= relation 의 로우의 길이 \u0026lt;= 20\n1 \u0026lt;= relation 의 모든 문자열의 길이 \u0026lt;= 8, 알파벳 소문자와 숫자로만 이루어져 있다.\n중복되는 튜플은 없다. 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.\n즉, 학생들을 구별할 수 있는 유일성과 최소성을 지키는 키의 조합의 개수를 구하면 된다. 조합의 개수를 구하는 문제 🔖 예제 및 실행결과 예제 [[\u0026#34;100\u0026#34;,\u0026#34;ryan\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;200\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;math\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;300\u0026#34;,\u0026#34;tube\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;400\u0026#34;,\u0026#34;con\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;4\u0026#34;],[\u0026#34;500\u0026#34;,\u0026#34;muzi\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;600\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;]] 실행결과 2 ⌨️ 문제 풀이 row와 column 의 개수를 구해 변수로 둔다.\n키값이 될 수 있는 1개부터 column 의 길이의 조합을 각각 구해서 candidates에 저장한다.\n1번에서 구한 조합의 경우의 수를 순회하면서 해당되는 relation 의 데이터를 tmp 에 저장한 후\nset() 으로 자료형을 변경하여 중복을 제거한 후, row의 개수와 비교한다.\n만약 같다면, 후보키가 될 수 있는 것이기에 unique 변수에 저장한다\n추출한 데이터가 유일성을 가지는지에 대해서 검사하는 것.\nanswer 변수에 3번 작업을 통해 나온 unique 변수에 있는 데이터를 set() 자료형으로 중복을 제거한 뒤 저장한다.\nunique 변수의 길이만큼 순회하면서 (i)\ni 이후의 각 키조합에 (j) i가 포함이 되어 있다면, answer에서 j를 제거한다.\ni가 j에 포함이 된다면, j는 원소 하나가 빠져도 최소성을 만족하지 않기에 제거하는 것.\nanswer의 길이를 반환\n🖥 소스 코드 from itertools import combinations def solution(relation): col = len(relation[0]) row = len(relation) candidates = [] for i in range(1, col + 1): candidates.extend(combinations(range(col), i)) unique = [] for candi in candidates: tmp = [tuple([item[i] for i in candi]) for item in relation] if len(set(tmp)) == row: unique.append(candi) answer = set(unique) for i in range(len(unique)): for j in range(i + 1, len(unique)): if len(unique[i]) == len(set(unique[i]) \u0026amp; set(unique[j])): answer.discard(unique[j]) return len(answer) 💾 느낀점 조합을 사용하여 문제에서 제시한 최소성과 유일성을 이해하고 문제를 풀이해야했다. 주어진 데이터의 길이의 크기가 작아서 완전탐색을 통해서 할 수 있었다. set() 자료구조의 성질을 통해서 중복을 제거할 수 있다는 것을 알고 있다면 더 편하게 풀 수 있는 문제였다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%ED%9B%84%EB%B3%B4%ED%82%A4-with-python/","summary":"📌 Programmers 후보키 with Python 💡 조건 relation 은 2차원 문자열 배열이다.\n1 \u0026lt;= relation 의 컬럼의 길이 \u0026lt;= 8\n1 \u0026lt;= relation 의 로우의 길이 \u0026lt;= 20\n1 \u0026lt;= relation 의 모든 문자열의 길이 \u0026lt;= 8, 알파벳 소문자와 숫자로만 이루어져 있다.\n중복되는 튜플은 없다. 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.\n즉, 학생들을 구별할 수 있는 유일성과 최소성을 지키는 키의 조합의 개수를 구하면 된다. 조합의 개수를 구하는 문제 🔖 예제 및 실행결과 예제 [[\u0026#34;100\u0026#34;,\u0026#34;ryan\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;200\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;math\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;300\u0026#34;,\u0026#34;tube\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;400\u0026#34;,\u0026#34;con\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;4\u0026#34;],[\u0026#34;500\u0026#34;,\u0026#34;muzi\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;600\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;]] 실행결과 2 ⌨️ 문제 풀이 row와 column 의 개수를 구해 변수로 둔다.","title":"[Programmers] 후보키 with Python"},{"content":"\n📌 BOJ 14725 개미굴 💡 조건 첫 번째 줄은 로봇 개미가 각 층을 따라 내려오면서 알게 된 먹이의 정보 개수 N \u0026raquo; (1 ≤ N ≤ 1000)\n두 번째 줄부터 N+1 번째 줄까지, 각 줄의 시작은 로봇 개미 한마리가 보내준 먹이 정보 개수 K \u0026raquo; (1 ≤ K ≤ 15)\n다음 K개의 입력은 로봇 개미가 왼쪽부터 순서대로 각 층마다 지나온 방에 있는 먹이 정보이며 먹이 이름 길이 t \u0026raquo; (1 ≤ t ≤ 15) 트라이(Trie) 자료구조를 사용하는 문제. 🔖 예제 및 실행결과 예제 4 2 KIWI BANANA 2 KIWI APPLE 2 APPLE APPLE 3 APPLE BANANA KIWI 실행결과 APPLE --APPLE --BANANA ----KIWI KIWI --APPLE --BANANA ⌨️ 문제 풀이 trie 클래스를 생성하고, 로봇 개미가 보내준 데이터를 Trie 에 담는다.\n클래스 내 insert 함수에서 데이터를 차례대로 넣는다.\ncur_node 변수를 root로 주고, 데이터가 존재한다면 cur_node를 갱신,\n데이터가 존재 하지 않는다면, 추가해준다.\n입력 작업 반복문이 끝이 났다면, 노드의 마지막을 '*' 로 저장해준다.\n마지막 라인에서 클래스 내 출력 함수인, print_trie 를 0 을 넣어 실행해준다.\nl 이 0이라면, cur_node 를 root로 설정해준다.\ncur_node의 키 값을 정렬한 뒤, 반복문을 통해 출력해준다\n여기서 노드의 키 값이 '*' 이라면 출력을 하지 않고, print_trie 함수를 재귀 호출해준다.\n이때, l의 값은 + 1, cur_node는 c노드를 기준으로 넣어준다.\n만약 cur_node 의 키 값이 '*' 이 아니라면 '--' 문자열을 l 만큼 출력한 뒤, 노드를 출력한다\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) class Trie: def __init__(self): self.root = {} def insert(self, s): cur_node = self.root for c in s: if c not in cur_node: cur_node[c] = {} cur_node = cur_node[c] cur_node[\u0026#39;*\u0026#39;] = {} def print_trie(self, l, cur_node=None): if l == 0: cur_node = self.root for c in sorted(cur_node.keys()): if c != \u0026#39;*\u0026#39;: print(\u0026#39;--\u0026#39; * l, c, sep=\u0026#34;\u0026#34;) self.print_trie(l + 1, cur_node[c]) trie = Trie() for _ in range(n): data = list(stdin.readline().split()) trie.insert(data[1:]) trie.print_trie(0) 💾 느낀점 Trie 자료구조를 공부해야 풀 수 있는 문제였다. 처음보는 자료구조이기에 이해하는데에도 시간이 걸렸고, 부족한 점을 알게 되었다. 로직을 보면서 공부해야할 것을 다시 한번 정리하고 공부해야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-14725-%EA%B0%9C%EB%AF%B8%EA%B5%B4-with-python/","summary":"📌 BOJ 14725 개미굴 💡 조건 첫 번째 줄은 로봇 개미가 각 층을 따라 내려오면서 알게 된 먹이의 정보 개수 N \u0026raquo; (1 ≤ N ≤ 1000)\n두 번째 줄부터 N+1 번째 줄까지, 각 줄의 시작은 로봇 개미 한마리가 보내준 먹이 정보 개수 K \u0026raquo; (1 ≤ K ≤ 15)\n다음 K개의 입력은 로봇 개미가 왼쪽부터 순서대로 각 층마다 지나온 방에 있는 먹이 정보이며 먹이 이름 길이 t \u0026raquo; (1 ≤ t ≤ 15) 트라이(Trie) 자료구조를 사용하는 문제.","title":"[BOJ] 14725 개미굴 with Python"},{"content":"\n📌 Programmers 오픈채팅방 with Python 💡 조건 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record\n모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하 모든 유저는 유저 아이디로 구분한다.\n유저 아이디 사용자가 닉네임으로 채팅방에 입장 - \u0026quot;Enter 유저 아이디 닉네임\u0026quot; (ex. \u0026quot;Enter uid1234 Muzi\u0026quot;) 구현 유형의 문제 🔖 예제 및 실행결과 예제 record = [\u0026#34;Enter uid1234 Muzi\u0026#34;, \u0026#34;Enter uid4567 Prodo\u0026#34;,\u0026#34;Leave uid1234\u0026#34;,\u0026#34;Enter uid1234 Prodo\u0026#34;,\u0026#34;Change uid4567 Ryan\u0026#34;] 실행결과 [\u0026#34;Prodo님이 들어왔습니다.\u0026#34;, \u0026#34;Ryan님이 들어왔습니다.\u0026#34;, \u0026#34;Prodo님이 나갔습니다.\u0026#34;, \u0026#34;Prodo님이 들어왔습니다.\u0026#34;] ⌨️ 문제 풀이 문제의 정답을 출력할 배열 answer, (상태, uid) 정보를 저장할 배열 result,\n입장과 퇴장의 문구가 담긴 배열 status, (uid, 닉네임)이 담겨있는 딕셔너리 id_code 를 생성한다.\nrecord를 순회하면서 가장 첫 정보가 Enter 일 경우, id_code 딕셔너리에 uid: 닉네임 형식으로 데이터를 저장한다.\nresult에 (상태코드, uid) 를 저장한다.\n첫 정보가 Leave 일 경우, result에 (상태코드, uid) 를 저장한다.\n첫 정보가 Change 일 경우, id_code의 uid 에 해당하는 닉네임을 변경한다.\nresult 배열을 순회하면서 id_code 딕셔너리의 uid에 해당하는 닉네임과 스테이터스 번호를 함께 answer 배열에 저장한다.\nanswer를 반환한다.\n🖥 소스 코드 def solution(record): result = [] answer = [] status = [\u0026#34;님이 들어왔습니다.\u0026#34;, \u0026#34;님이 나갔습니다.\u0026#34;] id_code = {} for r in record: l = r.split() if l[0] == \u0026#39;Enter\u0026#39;: id_code[l[1]] = l[2] result.append([0, l[1]]) elif l[0] == \u0026#39;Leave\u0026#39;: result.append([1, l[1]]) else: id_code[l[1]] = l[2] for s, uid in result: answer.append(id_code[uid] + status[s]) return answer 💾 느낀점 uid 번호에 따른 상태와, 닉네임을 변경하여 그에 맞게 출력하는 구현문제였다. 상태를 저장을 어떻게 할지에 대해서 고민을 하다가 오래걸렸었는데, 직접 구현을 하고 보니 짧고 간단한 문제였다. 구현 연습을 더 열심히 해야하겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9-with-python/","summary":"📌 Programmers 오픈채팅방 with Python 💡 조건 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record\n모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하 모든 유저는 유저 아이디로 구분한다.\n유저 아이디 사용자가 닉네임으로 채팅방에 입장 - \u0026quot;Enter 유저 아이디 닉네임\u0026quot; (ex. \u0026quot;Enter uid1234 Muzi\u0026quot;) 구현 유형의 문제 🔖 예제 및 실행결과 예제 record = [\u0026#34;Enter uid1234 Muzi\u0026#34;, \u0026#34;Enter uid4567 Prodo\u0026#34;,\u0026#34;Leave uid1234\u0026#34;,\u0026#34;Enter uid1234 Prodo\u0026#34;,\u0026#34;Change uid4567 Ryan\u0026#34;] 실행결과 [\u0026#34;Prodo님이 들어왔습니다.","title":"[Programmers] 오픈채팅방 with Python"},{"content":"\n📌 BOJ 12100 2048(easy) 💡 조건 보드의 크기는 N * N (1 ≤ N ≤ 20)\n0 은 빈칸, 이외의 값은 블록의 값들을 나타낸다.\n블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다.\n블록은 적어도 하나 주어진다. 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 최대 다섯번 이동 시켜서 얻을 수 있는 가장 큰 블록의 값을 출력. 백트래킹 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 2 2 2 4 4 4 8 8 8 실행결과 16 ⌨️ 문제 풀이 백트래킹은 재귀가 가장 핵심.\n백트래킹을 수행하며 재귀를 진행할 recursive함수에 파라미터를 cnt 로 주고, 첫 실행시에는 0을 주고 실행시킨다.\nN의 크기가 작기 때문에 deep copy를 이용한 배열복사가 가능하다.\n이를 통해 방향을 바꾸기 전, 이전 보드의 상태를 기억하기 위한 소스코드를 작성한다.\n움직이기 전 보드의 상황을 기억해두지 않으면, 백트래킹이 수행될 수 없다.\nb = [x[:] for x in arr] 네 방향으로 블록을 움직일 수 있으니, 반복문을 통해 네 방향으로 움직여준다.\nmove() 함수에서 k 의 값에 따라 네 방향으로 움직여 준다.\ndef move(k): # arr[i][j] if k == 0: # 위로 이동, 블락들이 위로 모두 이동하면 row index는 0 for j in range(n): for i in range(n): get(i, j) merge(0, j, 1, 0) # row index 1씩 증가하면서 아래쪽 블락들을 합쳐감 elif k == 1: # 아래로 이동, 블락들이 아래로 모두 이동하면 row index는 n-1 for j in range(n): for i in range(n - 1, -1, -1): get(i, j) merge(n - 1, j, -1, 0) # row 인덱스 1씩 감소하면서 위쪽들을 합쳐감 elif k == 2: # 오른쪽으로 이동, column index는 0 for i in range(n): for j in range(n): get(i, j) merge(i, 0, 0, 1) # column 인덱스 증가 오른쪽으로 이동 else: # 왼쪽으로 이동, column index는 n-1 for i in range(n): for j in range(n - 1, -1, -1): get(i, j) merge(i, n - 1, 0, -1) # column 인덱스 감소 왼쪽으로 이동 get() 함수에서 움직일 보드들의 상태를 확인하면서 순차적으로 순회해주고,\n순회하면서 배열 원소의 값이 0이 아닌 경우, 원소의 값을 큐에 넣어준다.\n배열에 넣은 값이 있던 해당 자리는 0으로 바꿔준다.\ndef get(i, j): if arr[i][j]: # 0이 아닌 값이라면 q.append(arr[i][j]) # queue에 arr의 값을 넣는다. arr[i][j] = 0 # 처리가 된 빈 자리는 0으로 값 업데이트 merge() 함수에서 각 이동하려는 방향에 알맞게 인덱스를 조절하며 큐가 빌때까지 반복하며 합쳐준다.\n움직이려는 값의 블록을 큐에서 꺼내온 후, 놓을 곳의 블럭의 값이 0이라면 그냥 두고,\n값이 일치한다면 2의 제곱 꼴이기에 2배를 해준다.\n값이 일치 하지 않는다면 그 자리에 그대로 둔다.\ndef merge(i, j, di, dj): # row index, column index, y방향, x방향 while q: x = q.popleft() # 움직이려는 블록 값을 가져온다. FIFO if not arr[i][j]: # 0이라면 그대로 놓는다. arr[i][j] = x elif arr[i][j] == x: # 값이 일치한다면 arr[i][j] = x * 2 # 합쳐지므로 2배로 증가 i, j = i + di, j + dj else: # 값이 일치하지 않으면 i, j = i + di, j + dj arr[i][j] = x move() 함수의 처리가 끝났다면, cnt + 1 을 파라미터로 주고, recursive 함수를 재귀호출 해준다.\n3번부터 다시 반복하면서, cnt 값이 5, 즉 다섯번 움직였을 때, 보드판을 순회한다.\n각 배열의 최댓값과 정답으로 출력할 ans 값을 비교하여 갱신한다.\n🖥 소스 코드 from sys import stdin, setrecursionlimit from collections import deque setrecursionlimit(int(1e9)) n = int(stdin.readline()) arr = [list(map(int, stdin.readline().split())) for _ in range(n)] answer, q = 0, deque() def get(i, j): if arr[i][j]: q.append(arr[i][j]) arr[i][j] = 0 def merge(i, j, di, dj): while q: x = q.popleft() if not arr[i][j]: arr[i][j] = x elif arr[i][j] == x: arr[i][j] = x * 2 i, j = i + di, j + dj else: i, j = i + di, j + dj arr[i][j] = x def move(k): if k == 0: for j in range(n): for i in range(n): get(i, j) merge(0, j, 1, 0) elif k == 1: for j in range(n): for i in range(n - 1, -1, -1): get(i, j) merge(n - 1, j, -1, 0) elif k == 2: for i in range(n): for j in range(n): get(i, j) merge(i, 0, 0, 1) else: for i in range(n): for j in range(n - 1, -1, -1): get(i, j) merge(i, n - 1, 0, -1) def recursive(count): global arr, answer if count == 5: for i in range(n): answer = max(answer, max(arr[i])) return b = [x[:] for x in arr] for k in range(4): move(k) recursive(count + 1) arr = [x[:] for x in b] recursive(0) print(answer) 💾 느낀점 재귀함수를 얼마나 응용을 할 수 있는지에 대한 문제였다. get(), move() 함수를 구현하는 것이 가장 어려웠으며, 이 부분은 다른 블로그에서 아이디어를 얻어 해결했다. 몇 번이고 다시 풀어보기 좋은 문제인 것 같다. 주말에 다시 한 번 풀어보는 것이 좋겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-12100-2048easy-with-python/","summary":"📌 BOJ 12100 2048(easy) 💡 조건 보드의 크기는 N * N (1 ≤ N ≤ 20)\n0 은 빈칸, 이외의 값은 블록의 값들을 나타낸다.\n블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다.\n블록은 적어도 하나 주어진다. 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 최대 다섯번 이동 시켜서 얻을 수 있는 가장 큰 블록의 값을 출력.","title":"[BOJ] 12100 2048(easy) with Python"},{"content":"\n📌 BOJ 13334 철로 💡 조건 사람 수를 나타내는 양의 정수 n (1 ≤ n ≤ 100,000)\nn개의 각 줄에 정수 쌍 (hi, oi)가 주어진다.\n−100,000,000 ≤ hi ≤ 100,000,000\n−100,000,000 ≤ oi ≤ 100,000,000\noi != hi\n철로의 길이를 나타내는 정수 d (1 ≤ d ≤ 200,000,000) 집과 사무실 모두가 철로 길이 안에 들어갈 수 있는 최대의 개수를 구하는 문제. 우선순위 큐, 즉 자료구조를 활용하는 문제. 🔖 예제 및 실행결과 예제 8 5 40 35 25 10 20 10 25 30 50 50 60 30 25 80 100 30 실행결과 4 ⌨️ 문제 풀이 가장 먼저 집과 사무실의 위치를 입력받는데, 그 위치가 정렬이 된 데이터가 아니기에 계산을 용이하도록 하기 위해\n데이터를 전처리를 해준 후, data 리스트에 넣는다.\n철로의 길이를 입력받는다.\ndata를 순회하면서, 집과 사무실의 거리가 철로의 길이보다 짧을 경우에만 roads 리스트에 넣어준다.\n모든 곳에서의 선분 d(철로의 길이) 안에 집과 사무실이 모두 안에 들어가야 하기 때문이다.\n3번을 수행시켜 얻은 roads 리스트를 정렬시킨다.\n정렬시킨 roads 배열을 다시 순회하면서, heapq 를 만들어 큐가 비어있을 경우 정렬된 데이터를 넣는다.\n큐의 시작점 위치가 (현재 지정된 road의 끝나는 지점 - 철로 길이) 보다 짧으면 큐에서 데이터를 뺀다.\n큐에 들어가 있는 집과 사무실 좌표 순서쌍의 개수가 정답이기 때문에\n철로의 길이 범위 밖으로 좌표가 나가는 애들은 과함하게 잘라준다.\n🖥 소스 코드 from sys import stdin import heapq n = int(stdin.readline()) roads, data = [], [] for _ in range(n): data.append(sorted(list(map(int, stdin.readline().split())))) train_road_length = int(stdin.readline()) for road in data: s, e = road if (e - s) \u0026lt;= train_road_length: roads.append(road) roads.sort(key=lambda x: x[1]) answer = 0 q = [] for road in roads: if not q: heapq.heappush(q, road) else: while q[0][0] \u0026lt; road[1] - train_road_length: heapq.heappop(q) if not q: break heapq.heappush(q, road) answer = max(answer, len(q)) print(answer) 💾 느낀점 우선순위 큐를 사용해서 푸는 문제였지만, 문제를 이해하고 푸는데에 애를 먹었다. 누적합을 사용해서 풀어보려고 했는데 올바른 풀이가 아니었는지, 코딩을 하다가 몇 번 뒤집었다. 이 문제 또한 반드시 한번 더 풀어보고 개념을 익혀야할 문제인 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-13334-%EC%B2%A0%EB%A1%9C-with-python/","summary":"📌 BOJ 13334 철로 💡 조건 사람 수를 나타내는 양의 정수 n (1 ≤ n ≤ 100,000)\nn개의 각 줄에 정수 쌍 (hi, oi)가 주어진다.\n−100,000,000 ≤ hi ≤ 100,000,000\n−100,000,000 ≤ oi ≤ 100,000,000\noi != hi\n철로의 길이를 나타내는 정수 d (1 ≤ d ≤ 200,000,000) 집과 사무실 모두가 철로 길이 안에 들어갈 수 있는 최대의 개수를 구하는 문제. 우선순위 큐, 즉 자료구조를 활용하는 문제. 🔖 예제 및 실행결과 예제 8 5 40 35 25 10 20 10 25 30 50 50 60 30 25 80 100 30 실행결과 4 ⌨️ 문제 풀이 가장 먼저 집과 사무실의 위치를 입력받는데, 그 위치가 정렬이 된 데이터가 아니기에 계산을 용이하도록 하기 위해","title":"[BOJ] 13334 철로 with Python"},{"content":"\n📌 BOJ 1043 거짓말 💡 조건 N, M은 50 이하의 자연수 각각 사람의 수, 파티의 수\n진실을 아는 사람의 수는 0 이상 50 이하의 정수\n각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수 지민이는 모든 파티에 참가해야한다.\n지민이는 이야기를 과장되게 한다. 또한 지민이는 거짓말쟁이가 되기 싫다.\n이야기의 진실을 아는 사람이 파티에 있으면 과장해서 말할 수 없다. 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 문제. 자료구조의 활용을 요구하는 유형의 문제 🔖 예제 및 실행결과 예제 4 5 1 1 1 1 1 2 1 3 1 4 2 4 1 실행결과 2 ⌨️ 문제 풀이 cnt라는 리스트에 파티의 수만큼 원소를 만들어주고, 각 값을 1로 둔다.\n이는 파티에서 과장되게 말을 할 수 있다는 가정하에 1로 둔 것.\n또한 각 파티의 구성원을 party 리스트에 각각 집어넣어준다. 파티의 수만큼 다시 순회하면서 각 party의 번호와 구성원을 뽑아 반복문을 돌리기 위해 enumerate 를 사용해준다.\nenumerate 함수는 리스트를 순회하면서 리스트의 각 원소의 인덱스와 원소를 반환한다. 파티의 구성원과 진실을 아는 사람들간에 교집합이 존재한다면, cnt 리스트의 해당 번호에 해당하는 값을 0으로 변경한다.\n그 파티는 진실만을 말할 수 있는 파티라는 것이다.\n그 후, 파티원을 진실을 알고 있는 사람들이 저장되어 있는 set() 자료형에 update 시켜준다.\nupdate 와 |= 이 둘은 같은 효과를 볼 수 있다. cnt 리스트의 합을 구해 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) trues = set(list(map(int, stdin.readline().split()))[1:]) party = [] cnt = [] for _ in range(m): data = set(map(int, stdin.readline().split()[1:])) if data: party.append(data) cnt.append(1) for _ in range(m): for i, p in enumerate(party): if trues \u0026amp; p: cnt[i] = 0 trues |= p print(sum(cnt)) 💾 느낀점 set 집합자료형의 강력함을 알 수 있는 문제였다. 문제를 잘 읽고 자료구조를 활용하면 풀 수 있는 문제였다. 이 문제를 한번에 풀지 못했다. 아직 활용이 부족한 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1043-%EA%B1%B0%EC%A7%93%EB%A7%90-with-python/","summary":"📌 BOJ 1043 거짓말 💡 조건 N, M은 50 이하의 자연수 각각 사람의 수, 파티의 수\n진실을 아는 사람의 수는 0 이상 50 이하의 정수\n각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수 지민이는 모든 파티에 참가해야한다.\n지민이는 이야기를 과장되게 한다. 또한 지민이는 거짓말쟁이가 되기 싫다.\n이야기의 진실을 아는 사람이 파티에 있으면 과장해서 말할 수 없다. 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 문제. 자료구조의 활용을 요구하는 유형의 문제 🔖 예제 및 실행결과 예제 4 5 1 1 1 1 1 2 1 3 1 4 2 4 1 실행결과 2 ⌨️ 문제 풀이 cnt라는 리스트에 파티의 수만큼 원소를 만들어주고, 각 값을 1로 둔다.","title":"[BOJ] 1043 거짓말 with Python"},{"content":"\n📌 BOJ 2343 기타 레슨 💡 조건 강의의 수 N (1 ≤ N ≤ 100,000)\n블루레이의 수 M (1 ≤ M ≤ N) 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 각 강의의 길이가 분 단위(자연수)로 주어진다. 가능한 블루레이의 크기 중 최소를 구하는 문제. 이분탐색 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 9 3 1 2 3 4 5 6 7 8 9 실행결과 17 ⌨️ 문제 풀이 이분탐색을 위해 left, right, mid 변수를 초기화 해줍니다.\nleft는 입력받은 강의 시간 배열의 가장 큰 값 right는 입력받은 강의 시간 배열의 합 mid = (left + right) // 2 블루레이의 크기에 몇개의 강의가 들어가는지 검사하여 반환하는 함수를 만들어줍니다.\n여기서 블루레이의 크기는 mid를 기준으로 검사를 해준다.\ndef get_cnt(): count = 0 temp = 0 for i in range(n): if temp + arr[i] \u0026gt; mid: count += 1 temp = 0 temp += arr[i] if temp: count += 1 return count\nleft변수가 right 변수보다 크거나 같을 때까지 반복하여 진행한 뒤, left, right, mid 중 가장 큰 값을 출력한다.\n블루레이의 크기가 모두 같아야하기 때문에 최댓값을 출력하는 것이다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) def get_cnt(): count = 0 temp = 0 for i in range(n): if temp + arr[i] \u0026gt; mid: count += 1 temp = 0 temp += arr[i] if temp: count += 1 return count left, right = max(arr), sum(arr) while left \u0026lt;= right: mid = (left + right) // 2 cnt = get_cnt() if cnt \u0026gt; m: left = mid + 1 elif cnt \u0026lt;= m: right = mid - 1 print(max(left, right, mid)) 💾 느낀점 이분탐색을 통해서 풀어내는 문제였다. 문제를 이해하지 못해서 조금 헤맸던 문제였다. get_cnt 함수를 구현하려다가 순서가 바뀌면 안된다는 조건을 보고 구현할 수 있었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2343-%EA%B8%B0%ED%83%80-%EB%A0%88%EC%8A%A8-with-python/","summary":"📌 BOJ 2343 기타 레슨 💡 조건 강의의 수 N (1 ≤ N ≤ 100,000)\n블루레이의 수 M (1 ≤ M ≤ N) 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 각 강의의 길이가 분 단위(자연수)로 주어진다. 가능한 블루레이의 크기 중 최소를 구하는 문제. 이분탐색 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 9 3 1 2 3 4 5 6 7 8 9 실행결과 17 ⌨️ 문제 풀이 이분탐색을 위해 left, right, mid 변수를 초기화 해줍니다.","title":"[BOJ] 2343 기타 레슨 with Python"},{"content":"\n📌 BOJ 3184 양 💡 조건 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.\nR개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다. 한 칸에서 수평, 수직만으로 이동할수 있다.\n영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대가 많으면 양은 사라진다. 넓이 우선 탐색(BFS) 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 6 ...#.. .##v#. #v.#.# #.o#.# .###.# ...### 실행결과 0 2 ⌨️ 문제 풀이 양과 늑대의 수를 담을 answer 리스트를 각각의 원소를 0으로 초기화하여 생성한다.\n이미 방문했던 곳의 좌표를 담을 set 자료형 visited를 생성한다. 이중 반복문으로 필드를 순회하면서, 다음 두가지에 해당하면 BFS를 수행한다. (i, j) 가 visited 에 방문하지 않았을 때 (i, j) 에 해당하는 필드 값이 v 혹은 o 일 때 bfs 함수에서 vo라는 set()이 두개 담긴 리스트를 생성해준다.\n큐에는 bfs 를 수행하기 위해 받아온 x, y 값을 넣어주고, 큐가 빌 때까지 수행한다. 큐에서 뽑아낸 x, y 좌표가 필드에서 양인지 늑대인지 구문하여 vo[1] 혹은 v[0] 에 저장해준다.\n현재 좌표에서 상하좌우를 순회하며 방문하지 않았고, #이 아닌 필드의 좌표를 큐와 visited 에 넣어준다. 큐가 비어 while 반복문이 종료되면, 양의 수와 늑대의 수를 비교하여\n수가 더 작은 쪽은 0으로, 큰 쪽은 숫자 그대로 반환한다. bfs 함수에서 반환받은 값을 answer 원소에 각각 더해준다. 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) board = [] for n in range(n): board.append(list(stdin.readline().rstrip())) dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] visited = set() def bfs(x, y): vo = [set(), set()] q = deque() q.append((x, y)) visited.add((x, y)) while q: x, y = q.popleft() if board[x][y] == \u0026#39;o\u0026#39;: vo[1].add((x, y)) elif board[x][y] == \u0026#39;v\u0026#39;: vo[0].add((x, y)) for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: if board[nx][ny] != \u0026#39;#\u0026#39; and (nx, ny) not in visited: q.append((nx, ny)) visited.add((nx, ny)) if len(vo[0]) \u0026lt; len(vo[1]): return 0, len(vo[1]) else: return len(vo[0]), 0 answer = [0, 0] for i in range(n): for j in range(m): if (board[i][j] == \u0026#39;v\u0026#39; or board[i][j] == \u0026#39;o\u0026#39;) and (i, j) not in visited: v, o = bfs(i, j) answer[0] += o answer[1] += v print(*answer) 💾 느낀점 BFS 문제였고, 쉽게 풀 수 있는 문제였다. 다른 사람이 내 글을 보고 잘 이해할 수 있을지는 모르겠다. 조금 더 쉽게 설명할 수 있게 더 높은 수준의 이해가 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-3184-%EC%96%91-with-python/","summary":"📌 BOJ 3184 양 💡 조건 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.\nR개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다. 한 칸에서 수평, 수직만으로 이동할수 있다.\n영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대가 많으면 양은 사라진다. 넓이 우선 탐색(BFS) 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 6 .","title":"[BOJ] 3184 양 with Python"},{"content":"\n📌 BOJ 1713 후보 추천하기 💡 조건 사진틀의 개수 N이 주어진다. (1 ≤ N ≤ 20)\n총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 9 2 1 4 3 5 6 2 7 2 실행결과 2 6 7 ⌨️ 문제 풀이 추천받은 순서대로 주어진 리스트를 순회하며 student (dict) 에 없으면 새로 추가하고,\nstudent (dict) 에 있으면 + 1을 해준다.\n만약, 새로 추가를 해야하는데 student 길이가 사진틀의 개수보다 같거나 클 경우, 가장 적게 추천 받은 학생 또는 가장 오래된 사진을 뺀다. student에 남아있는 key만 뽑아 정렬한 뒤 반환한다. 🖥 소스 코드 from sys import stdin import heapq def solution(n): student = {} data = list(map(int, stdin.readline().split())) for s in data: if s not in student: if len(student) \u0026gt;= n: # dict를 heapq 모듈을 사용해 최솟값을 뽑아냄 a = heapq.nsmallest(min(student), student, key=student.get) student.pop(a[0]) student[s] = 1 else: student[s] += 1 return sorted(student.keys()) n = int(stdin.readline().rstrip()) r = int(stdin.readline().rstrip()) print(*solution(n)) 💾 느낀점 heapq 에 더 다양한 기능이 있다는 것을 검색을 통해 알았다. 일반 반목 + 조건문으로 코드를 작성한 것보다 훨씬더 보기가 좋았다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1713-%ED%9B%84%EB%B3%B4-%EC%B6%94%EC%B2%9C%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 1713 후보 추천하기 💡 조건 사진틀의 개수 N이 주어진다. (1 ≤ N ≤ 20)\n총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 9 2 1 4 3 5 6 2 7 2 실행결과 2 6 7 ⌨️ 문제 풀이 추천받은 순서대로 주어진 리스트를 순회하며 student (dict) 에 없으면 새로 추가하고,","title":"[BOJ] 1713 후보 추천하기 with Python"},{"content":"\n📌 BOJ 1743 음식물 피하기 💡 조건 통로의 세로 길이 N(1 ≤ N ≤ 100)\n통로의 가로 길이 M(1 ≤ M ≤ 100)\n음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)\nK개의 줄에 음식물이 떨어진 좌표 (r, c) DFS 유형의 문제(깊이우선탐색) 🔖 예제 및 실행결과 예제 3 4 5 3 2 2 2 3 1 2 3 1 1 실행결과 4 ⌨️ 문제 풀이 m * n 크기의 맵을 만들어 0으로 도배를 한 후, 쓰레기가 있는 곳의 좌표를 받아 1이라고 표시했다.\n쓰레기가 있는 좌표는 따로 foot_t라는 변수에 담았다. food_t 를 순회하면서 어느 좌표에서 가장 쓰레기가 크게 되는지 깊이 우선 탐색을 통해 계산해준다. 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n, m, k = map(int, stdin.readline().split()) arr = [[0] * (m + 1) for _ in range(n + 1)] food_t = [] for _ in range(k): x, y = map(int, stdin.readline().split()) arr[x][y] = 1 food_t.append((x, y)) answer = -1e9 dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] def dfs(x, y): global res if x \u0026lt; 0 or y \u0026lt; 0 or x \u0026gt; n or y \u0026gt; m: return if arr[x][y] == 1: arr[x][y] = 0 res += 1 for i in range(4): dfs(x + dx[i], y + dy[i]) return for x, y in food_t: res = 0 dfs(x, y) answer = max(res, answer) print(answer) 💾 느낀점 recursive 제약이 있어, setrecursionlimit 함수를 사용한다는 것을 매일 까먹는다. 조심해야겠다. DFS로 한번, BFS로 한번 풀어보았다. 이런 문제가 가장 싫었었는데 지금은 가장 좋다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1743-%EC%9D%8C%EC%8B%9D%EB%AC%BC-%ED%94%BC%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 1743 음식물 피하기 💡 조건 통로의 세로 길이 N(1 ≤ N ≤ 100)\n통로의 가로 길이 M(1 ≤ M ≤ 100)\n음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)\nK개의 줄에 음식물이 떨어진 좌표 (r, c) DFS 유형의 문제(깊이우선탐색) 🔖 예제 및 실행결과 예제 3 4 5 3 2 2 2 3 1 2 3 1 1 실행결과 4 ⌨️ 문제 풀이 m * n 크기의 맵을 만들어 0으로 도배를 한 후, 쓰레기가 있는 곳의 좌표를 받아 1이라고 표시했다.","title":"[BOJ] 1743 음식물 피하기 with Python"},{"content":"\n📌 BOJ 1244 스위치 켜고 끄기 💡 조건 및 풀이 첫째 줄은 스위치 개수. 스위치 개수는 100 이하인 양의 정수.\n둘째 줄은 각 스위치의 상태. 켜져 있으면 1, 꺼져있으면 0이라고 표시\n셋째 줄에는 학생 수. 학생수는 100 이하인 양의 정수\n넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수. 남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. 여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서,\n그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다. 구현 \u0026amp; 시뮬레이션 유형의 문제 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 문제. 🔖 예제 및 실행결과 예제 8 0 1 0 1 0 0 0 1 2 1 3 2 3 실행결과 1 0 0 0 1 1 0 1 ⌨️ 문제 풀이 학생의 수만큼 순회하여 남자일 때와 여자일 때를 구분하여 작업을 할 수 있도록 조건문을 짠다.\n(내가 문제를 푸는 방식은 이러하다. 이렇게 큰 틀을 짜놓고 구현하면 훨씬 편하다.) 남자는 지문에 나오는 것처럼, 스위치의 상태가 1일 때 0으로, 0일 때 1로 변경해주면 된다. 여자의 경우, 좌우로 대칭하는지 찾기 전에, 현재 학생이 받은 수에 1씩 더하고 빼서 스위치로 입력받은 리스트 범위 내인지부터 확인한다.\n범위 내인 경우, 현재 번호의 양쪽 데이터가 같은지 확인하고, 일치한다면 left, right 변수에 좌측, 우측의 인덱스 번호를 넣어준다. while 반복문으로 양측의 데이터가 같지 않을 때, 리스트의 범위를 벗어날 때 break를 걸어주고\nleft와 right를 갱신한다. while 반복이 끝난 후, range(left, right + 1) 범위의 리스트 원소를 변경해준다.\n0 일때 1, 1 일때, 0 20개씩 출력하는 것은 아래와 같이 for 문에서 조절해주면 된다. for i in range(1, n, 20): print(*switch[i:i+20]) 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) switch = [0] + list(map(int, stdin.readline().split())) for i in range(int(stdin.readline())): g, num = map(int, stdin.readline().split()) if g == 1: for i in range(num, n + 1, num): switch[i] = 1 if switch[i] == 0 else 0 elif g == 2: if num + 1 \u0026gt; n or num - 1 \u0026lt; 1: switch[num] = 1 if switch[num] == 0 else 0 else: if switch[num + 1] == switch[num - 1]: left = num - 1 right = num + 1 while 1: if left - 1 \u0026lt; 1 or right + 1 \u0026gt; n: break if switch[left - 1] != switch[right + 1]: break else: left -= 1 right += 1 for i in range(left, right + 1): switch[i] = 1 if switch[i] == 0 else 0 else: switch[num] = 1 if switch[num] == 0 else 0 for i in range(1, n, 20): print(*switch[i:i+20]) 💾 느낀점 조건문만 충실히 지키면 잘 풀 수 있는 문제였다. 여학생이 바꾸는 스위치들의 조건을 구현하는데에 살짝 힘이 들뻔했다. 링크드리스트로 풀수 있을 것 같다는 생각을 했다. 다음번에는 링크드 리스트로 구현하는 연습을 해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1244-%EC%8A%A4%EC%9C%84%EC%B9%98-%EC%BC%9C%EA%B3%A0-%EB%81%84%EA%B8%B0-with-python/","summary":"📌 BOJ 1244 스위치 켜고 끄기 💡 조건 및 풀이 첫째 줄은 스위치 개수. 스위치 개수는 100 이하인 양의 정수.\n둘째 줄은 각 스위치의 상태. 켜져 있으면 1, 꺼져있으면 0이라고 표시\n셋째 줄에는 학생 수. 학생수는 100 이하인 양의 정수\n넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수. 남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다.","title":"[BOJ] 1244 스위치 켜고 끄기 with Python"},{"content":"\n📌 Programmers - 광고 삽입 💡 조건 및 풀이 동영상에 광고를 넣어야한다. 시청자가 가장 많은 구간에 광고를 넣어야한다.\n= 시청자 수 구간합이 가장 큰 곳에 광고를 넣어야한다. 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time,\n시청자들이 해당 동영상을 재생했던 구간 정보 logs 구간합을 구해 답을 이끌어내는 유형의 문제 play_time, adv_time은 길이 8로 고정된 문자열\nplay_time, adv_time은 HH:MM:SS 형식이며,\n00:00:01 \u0026lt;= play_time, adv_time \u0026lt;= 99:59:59 공익광고 재생시간은 동영상 재생시간보다 짧거나 같다. 1 \u0026lt;= logs \u0026lt;= 300000 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;02:03:55\u0026#34;, \u0026#34;00:14:15\u0026#34;, [\u0026#34;01:20:15-01:45:14\u0026#34;, \u0026#34;00:40:31-01:00:00\u0026#34;, \u0026#34;00:25:50-00:48:29\u0026#34;, \u0026#34;01:30:59-01:53:29\u0026#34;, \u0026#34;01:37:44-02:02:30\u0026#34;])) 실행결과 \u0026#34;01:30:59\u0026#34; ⌨️ 문제 풀이 play_time, adv_time (동영상 재생 길이, 광고 재생 길이)를 각각 str 타입에서 int 타입으로 변경한다. def str_to_int(time): h, m, s = time.split(\u0026#39;:\u0026#39;) return int(h) * 3600 + int(m) * 60 + int(s) 각 구간의 시청자들의 수를 기록할 배열을 만든다. all_time = [0 for i in range(play_time + 1)] logs 를 순회하면서 시청 시작 시간에 시청자 수 + 1\n시청 종료 시간에 시청자 수 - 1 구간별 시청자 기록을 위해 all_time 배열을 순회하면서, 이전 배열의 값을 가지고 현재 배열에 더해주는 작업을 해줍니다. for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] 모든 구간의 시청자 누적 기록을 위해 다시 한번 4번의 작업을 해줍니다. 누적된 구간별 시청자 수의 정보가 저장된 배열을 순회하면서 시청자가 가장 많은 구간을 탐색합니다. # 가장 시청자 수가 많은 구간을 탐색 for i in range(adv_time - 1, play_time): # i가 공익 광고 시청 시간보다 빠를 때 if i \u0026gt;= adv_time: # 지금까지 최대 누적 시청자 수가 (총 누적 시청자 수 - 해당 구간 시청자 수) 보다 작으면? if most_view \u0026lt; all_time[i] - all_time[i - adv_time]: # 지금까지 최대 누적 시청자 수를 갱신 most_view = all_time[i] - all_time[i - adv_time] # 최대 누적 시청자 수에 해당하는 구간을 갱신 max_time = i - adv_time + 1 else: # 최대 시청자 수가 현재 탐색하는 시간대의 총 누적 시청자 수보다 적을 때 if most_view \u0026lt; all_time[i]: # 최대 시청자 수와 그에 해당하는 시간대를 갱신 most_view = all_time[i] max_time = i - adv_time + 1 최대 시청자가 있는 광고 삽입 시간을 HH:MM:SS 형식으로 변환하여 return 합니다. 🖥 소스 코드 def solution(play_time, adv_time, logs): play_time = str_to_int(play_time) adv_time = str_to_int(adv_time) all_time = [0 for i in range(play_time + 1)] for l in logs: start, end = l.split(\u0026#39;-\u0026#39;) start = str_to_int(start) end = str_to_int(end) all_time[start] += 1 all_time[end] -= 1 for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] most_view = 0 max_time = 0 for i in range(adv_time - 1, play_time): if i \u0026gt;= adv_time: if most_view \u0026lt; all_time[i] - all_time[i - adv_time]: most_view = all_time[i] - all_time[i - adv_time] max_time = i - adv_time + 1 else: if most_view \u0026lt; all_time[i]: most_view = all_time[i] max_time = i - adv_time + 1 return int_to_str(max_time) def str_to_int(time): h, m, s = time.split(\u0026#39;:\u0026#39;) return int(h) * 3600 + int(m) * 60 + int(s) def int_to_str(time): h = time // 3600 h = \u0026#39;0\u0026#39; + str(h) if h \u0026lt; 10 else str(h) time = time % 3600 m = time // 60 m = \u0026#39;0\u0026#39; + str(m) if m \u0026lt; 10 else str(m) time = time % 60 s = \u0026#39;0\u0026#39; + str(time) if time \u0026lt; 10 else str(time) return h + \u0026#39;:\u0026#39; + m + \u0026#39;:\u0026#39; + s 💾 느낀점 문자열 타입의 시간 형식 데이터는 각 시간, 분, 초를 합쳐 숫자로 만들어 다루는 것이 편하다. 구간별 시청자 기록과 모든 구간의 시청자 누적 기록을 하는 부분에서 많은 이해가 필요했다.\n스스로 이해하지 못해 다른 블로그를 참고하여 코드를 작성했다. 모든 구간의 시청자 누적 기록을 순회하는 부분에서도 이해가 어려워 여러번 코드를 디버깅했다.\n이해를 하는 방향으로 코드를 보고 나의 방식으로 코드를 작성하는 시간이 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EA%B4%91%EA%B3%A0-%EC%82%BD%EC%9E%85-with-python/","summary":"📌 Programmers - 광고 삽입 💡 조건 및 풀이 동영상에 광고를 넣어야한다. 시청자가 가장 많은 구간에 광고를 넣어야한다.\n= 시청자 수 구간합이 가장 큰 곳에 광고를 넣어야한다. 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time,\n시청자들이 해당 동영상을 재생했던 구간 정보 logs 구간합을 구해 답을 이끌어내는 유형의 문제 play_time, adv_time은 길이 8로 고정된 문자열\nplay_time, adv_time은 HH:MM:SS 형식이며,\n00:00:01 \u0026lt;= play_time, adv_time \u0026lt;= 99:59:59 공익광고 재생시간은 동영상 재생시간보다 짧거나 같다.","title":"[Programmers] 광고 삽입 with Python"},{"content":"\n📌 Programmers - 표 편집 💡 조건 및 풀이 표의 원본 행의 개수를 나타내는 변수 n\n5 ≤ n ≤ 1,000,000 처음에 선택되어 있는 행의 위치 k\n0 ≤ k \u0026lt; n 수행한 명령어들이 담긴 문자열 배열 cmd\n1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 \u0026quot;U X\u0026quot;, \u0026quot;D X\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;Z\u0026quot; 중 하나 Linked List 자료구조 문제 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않는다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) \u0026ldquo;Z\u0026quot;가 명령어로 주어지는 경우는 없다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 🔖 예제 및 실행결과 예제 print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;])) print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;U 1\u0026#34;, \u0026#34;C\u0026#34;])) 실행결과 \u0026#34;OOOOXOOO\u0026#34; \u0026#34;OOXOXOOO\u0026#34; ⌨️ 문제 풀이 Double Linked List 자료구조를 알고, 구현할 수 있다면 풀이가 가능한 문제이다. Double Linked List 는 쉽게 말해 각 노드의 포인터가 다음, 혹은 이전의 노드를 가리키는 정보를 두개 담고 있다. 연결리스트를 사용해 cmd 에 있는 명령을 수행하기 전의 원본 표의 데이터를 입력한다. class Node: def __init__(self, data=None, state=1): # 노드의 정보, 값을 저장 self.value = data # 노드가 가지고 있을 전, 후를 가리키는 값은 None으로 초기화 self.next = None self.priv = None def __init__(self): self.header = Node() self.tail = Node() self.header.next = self.tail self.header.priv = self.header self.tail.next = self.tail self.tail.priv = self.header self.pointer = self.header linkedlist = DoubleLinkedList() pointer = linkedlist.header for i in range(n): # 노드를 추가함 linkedlist.add(Node(i)) 가장 처음에 가리키고 있는 포인터를 정해주어야하기 때문에 현재 연결리스트의 포인터를 k로 맞춰주는 작업을 한다. # 포인터의 값이 k와 다르면 계속 반복 while pointer.value != k: # 포인터는 현재 포인터의 다음 것을 가리킨다. pointer = pointer.next cmd를 순회하면서 요쳉에 대한 작업을 진행한다.\n삭제를 진행하고, 복구를 하는 작업은 stack(list) 을 하나 만들어, 삭제가 진행됐을 때 저장한다.\n복구를 할 때는 리스트에서 pop 을 하여 데이터를 꺼내오면 된다. 삭제의 작업은 다음과 같다.\n삭제될 노드를 미리 stack 에 넣어준 뒤,\n현재의 포인터 기준으로 이전 노드에서 자신을 가리키던 것을 다음 노드를 가리키게 해주면 된다. def delete(self, pointer): if pointer.priv == self.header: self.header.next = pointer.next pointer.next.priv = self.header return self.header.next elif pointer.next == self.tail: _pointer = pointer.priv self.tail.priv = _pointer _pointer.next = self.tail return _pointer else: _pointer = pointer.next pointer.priv.next = pointer.next pointer.next.priv = pointer.priv return _pointer 복구의 작업은 다음과 같다.\n복구될 노드를 stack에서 뽑아 변수에 저장한 뒤, 추가를 해준다. def add(self, node): self.pointer.next = node node.priv = self.pointer node.next = self.tail self.pointer = node 가리키는 곳을 이동하는 것은 이동하려는 칸의 수만큼 반복문을 통해 옮겨주면 된다. def move(self, pointer, v, step): for _ in range(step): if v == \u0026#39;D\u0026#39;: pointer = pointer.next else: pointer = pointer.priv return pointer 🖥 소스 코드 class Node: def __init__(self, data=None, state=1): # 노드의 정보, 값을 저장 self.value = data # 노드가 가지고 있을 전, 후를 가리키는 값은 None으로 초기화 self.next = None self.priv = None class DoubleLinkedList: def __init__(self): self.header = Node() self.tail = Node() self.header.next = self.tail self.header.priv = self.header self.tail.next = self.tail self.tail.priv = self.header self.pointer = self.header def add(self, node): self.pointer.next = node node.priv = self.pointer node.next = self.tail self.pointer = node def move(self, pointer, v, step): for _ in range(step): if v == \u0026#39;D\u0026#39;: pointer = pointer.next else: pointer = pointer.priv return pointer def delete(self, pointer): if pointer.priv == self.header: self.header.next = pointer.next pointer.next.priv = self.header return self.header.next elif pointer.next == self.tail: _pointer = pointer.priv self.tail.priv = _pointer _pointer.next = self.tail return _pointer else: _pointer = pointer.next pointer.priv.next = pointer.next pointer.next.priv = pointer.priv return _pointer def insert(self, pointer): pointer.priv.next = pointer pointer.next.priv = pointer def get_answer(n, linkedlist): # 답이 될 리스트 생성 answer = [\u0026#39;X\u0026#39; for _ in range(n)] # 연결리스트의 첫 헤더부터 포인터를 따라 순차적으로 방문하여 # answer 원소 갱신 pointer = linkedlist.header.next while pointer != linkedlist.tail: answer[pointer.value] = \u0026#39;O\u0026#39; pointer = pointer.next return \u0026#39;\u0026#39;.join(answer) def solution(n, k, cmd): # double linked list 초기화 linkedlist = DoubleLinkedList() # 포인터 설정 pointer = linkedlist.header # 삭제 요청 수행 시 삭제된 노드를 넣을 쓰레기통 stack = [] for i in range(n): # 노드를 추가함 linkedlist.add(Node(i)) # 포인터의 값이 k와 다르면 계속 반복 while pointer.value != k: # 포인터는 현재 포인터의 다음 것을 가리킨다. pointer = pointer.next # 요청 문자에 대하 수행 시작 for string in cmd: # 삭제 요청 if string == \u0026#39;C\u0026#39;: # 현재 삭제될 포인터를 쓰레기통에 넣음 stack.append(pointer) # 연결 리스트에서 노드를 삭제 pointer = linkedlist.delete(pointer) # 복구 요청 elif string == \u0026#39;Z\u0026#39;: # 쓰레기 통에 가장 마지막으로 추가된 노드 추출 # == 연결 리스트에서 가장 최근에 삭제된 노드 _pointer = stack.pop() # 연결리스트에 삽입 linkedlist.insert(_pointer) else: v, step = string.split() # 포인터 이동 pointer = linkedlist.move(pointer, v, int(step)) # 답 만들기 answer = get_answer(n, linkedlist) return answer print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;])) print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;U 1\u0026#34;, \u0026#34;C\u0026#34;])) 💾 느낀점 문제를 풀지 못해서 다른 분의 아이디어를 참고하여 연결리스트를 먼저 구현해보고자 했었다.\n자료구조를 class 형식으로 구현하는 연결리스트에 놀랬다.\n처음보는 자료구조였고, 감탄할 수밖에 없는 풀이였다.\n그 후 이중 연결 리스트를 보면서 비슷한 유형의 문제가 나온다면\n연결리스트를 구현해서 풀어보고 싶다는 생각을 했다. 단순히 stack에 삭제한 노드 번호를 넣고, 노드번호를 이분탐색으로 제자리에 복구하려는 시도를 했으나\n구현부분이 까다롭고 구현하면서도 조금씩 제한되고 구현하기에 어려운 부분이 있어 풀이를 참고 했다. 현재까지 2회 풀었는데, 아직 이전 소스를 참고하지 않고 완벽하게 이중 연결 리스트를 구현하기가 어려웠다.\n매일 볼때마다 조금은 새로운 이중 연결 리스트 구현 방법의 숙달과 관련 문제 풀이가 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%ED%91%9C-%ED%8E%B8%EC%A7%91-with-python/","summary":"📌 Programmers - 표 편집 💡 조건 및 풀이 표의 원본 행의 개수를 나타내는 변수 n\n5 ≤ n ≤ 1,000,000 처음에 선택되어 있는 행의 위치 k\n0 ≤ k \u0026lt; n 수행한 명령어들이 담긴 문자열 배열 cmd\n1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 \u0026quot;U X\u0026quot;, \u0026quot;D X\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;Z\u0026quot; 중 하나 Linked List 자료구조 문제 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않는다.","title":"[Programmers] 표 편집 with Python"},{"content":"\n📌 Programmers - 순위 검색 💡 조건 및 풀이 조건을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n를 구하는 문제\n'-' 표시는 해당 조건을 고려하지 않겠다는 의미.\n\u0026#34;cpp and - and senior and pizza 500\u0026#34; 은를 의미한다.\n\u0026quot;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026quot;\n브루트포스 알고리즘 유형의 문제에 해당한다.\n🔖 예제 및 실행결과 예제 info = [\u0026#34;java backend junior pizza 150\u0026#34;, \u0026#34;python frontend senior chicken 210\u0026#34;, \u0026#34;python frontend senior chicken 150\u0026#34;,\u0026#34;cpp backend senior pizza 260\u0026#34;, \u0026#34;java backend junior chicken 80\u0026#34;, \u0026#34;python backend senior chicken 50\u0026#34;] query = [\u0026#34;java and backend and junior and pizza 100\u0026#34;, \u0026#34;python and frontend and senior and chicken 200\u0026#34;, \u0026#34;cpp and - and senior and pizza 250\u0026#34;, \u0026#34;- and backend and senior and - 150\u0026#34;, \u0026#34;- and - and - and chicken 100\u0026#34;, \u0026#34;- and - and - and - 150\u0026#34;] 실행결과 [1,1,1,1,2,4] ⌨️ 문제 풀이 info 배열을 순회하며 얻은 데이터를 잘라 배열로 만들고, 그 배열을 각각 데이터와 점수 부분으로 나누어 준다. temp = j.split() condition = temp[:-1] score = int(temp[-1]) 지원서에 입력한 4개의 값 range(4)의 데이터를 combinations 을 이용해\n짝을 지어 각 1부터 4개까지의 경우의 수와 점수를 dict 자료구조에 넣어준다. for i in range(5): comb = list(combinations(range(4), i)) for c in comb: test_case = condition.copy() for idx in c: test_case[idx] = '-' case = ''.join(test_case) if case not in data: data[case] = [score] else: data[case].append(score) 이분탐색 라이브러리인 bisect 라이브러리를 사용해 사용을 할 것이기 때문에 dict 자료구조의 value를 정렬해준다. 파라미터로 받아온 sql을 순차적으로 돌면서 and 문자열을 \u0026lsquo;\u0026lsquo;로 바꾸어주고 split 해준다.\ntest_query 와 test_score 로 나누어주고, test_query에 해당하는 인원 중(data의 key)\ntest_score 이상의 점수를 얻은(data의 value) 인원의 수를 계산하여 answer에 입력해준다. 🖥 소스 코드 from itertools import combinations from bisect import bisect_left def solution(info, query): answer, data, sql = [], {}, [] n, m = len(info), len(query) for j in info: temp = j.split() condition = temp[:-1] score = int(temp[-1]) for i in range(5): comb = list(combinations(range(4), i)) for c in comb: test_case = condition.copy() for idx in c: test_case[idx] = \u0026#39;-\u0026#39; case = \u0026#39;\u0026#39;.join(test_case) if case not in data: data[case] = [score] else: data[case].append(score) for i in data.values(): i.sort() for i in range(m): sql = query[i].replace(\u0026#39;and\u0026#39;, \u0026#39;\u0026#39;).split() test_query = \u0026#39;\u0026#39;.join(sql[:-1]) test_score = int(sql[-1]) if test_query in data: idx = bisect_left(data[test_query], test_score) answer.append(len(data[test_query]) - idx) else: answer.append(0) return answer 💾 느낀점 모든 경우의 수를 data 에 입력하여 찾는 아이디어를 구상하는 것이 힘이 들었다. sql에 해당하는 지원자를 이분탐색으로 찾을 아이디어와 dict 자료구조를 사용할 아이디어를 떠올리니\n구현하는데에는 큰 무리가 없었던 것 같다. 포스팅 내용을 보니 아예 아이디어를 얻지 못한 분들이 보시기에 괜찮을까 라는 생각이 들면서,\n설명하는 능력이 조금 부족하다고 느낀다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EC%88%9C%EC%9C%84-%EA%B2%80%EC%83%89-with-python/","summary":"📌 Programmers - 순위 검색 💡 조건 및 풀이 조건을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n를 구하는 문제\n'-' 표시는 해당 조건을 고려하지 않겠다는 의미.\n\u0026#34;cpp and - and senior and pizza 500\u0026#34; 은를 의미한다.\n\u0026quot;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026quot;\n브루트포스 알고리즘 유형의 문제에 해당한다.\n🔖 예제 및 실행결과 예제 info = [\u0026#34;java backend junior pizza 150\u0026#34;, \u0026#34;python frontend senior chicken 210\u0026#34;, \u0026#34;python frontend senior chicken 150\u0026#34;,\u0026#34;cpp backend senior pizza 260\u0026#34;, \u0026#34;java backend junior chicken 80\u0026#34;, \u0026#34;python backend senior chicken 50\u0026#34;] query = [\u0026#34;java and backend and junior and pizza 100\u0026#34;, \u0026#34;python and frontend and senior and chicken 200\u0026#34;, \u0026#34;cpp and - and senior and pizza 250\u0026#34;, \u0026#34;- and backend and senior and - 150\u0026#34;, \u0026#34;- and - and - and chicken 100\u0026#34;, \u0026#34;- and - and - and - 150\u0026#34;] 실행결과 [1,1,1,1,2,4] ⌨️ 문제 풀이 info 배열을 순회하며 얻은 데이터를 잘라 배열로 만들고, 그 배열을 각각 데이터와 점수 부분으로 나누어 준다.","title":"[Programmers] 순위 검색 with Python"},{"content":"\n📌 BOJ 10775 공항 💡 조건 및 풀이 공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다. 공항에는 P개의 비행기가 순서대로 도착할 예정. i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다. Union - Find 알고리즘 유형의 문제 비행기를 최대 몇 대 도킹시킬 수 있는지 구하는 문제. 게이트의 수 G (1 ≤ G ≤ 105)\n비행기의 수 P (1 ≤ P ≤ 105)\nP개의 줄에 gi (1 ≤ gi ≤ G) 🔖 예제 및 실행결과 예제 4 3 4 1 1 실행결과 2 ⌨️ 문제 풀이 각 비행기의 번호를 입력 받을 때 1부터 시작하기 때문에 게이트 수 + 1 만큼 배열 parent 를 생성한다. 배열의 원소값은 각 인덱스 값과 동일하게 하는데, 이것을 부모를 자신으로 둔 것이라고 생각하면 좋다. 비행기의 번호 gi 를 입력 받아 gi의 부모를 찾는다. data = find_parent(parent, gi) 만약 data 가 존재하지 않는 0번 게이트에 도킹을 해야할 경우 반복문을 중단한다. 4번 이 아니라면 res += 1. gi 번 비행기가 data 번 게이트에 도킹을 했고, 그 게이트에는 다른 비행기가 도킹 할 수 없으니\ndata - 1 번호의 게이트를 가리키는 게이트가 됐다고 생각하자. union_parent(parent, data, data - 1) 순서대로 들어오는 비행기를 반복적으로 수행하다, 4번 의 조건에 걸리는 경우 반복문을 중단하고 결과를 출력한다. 🖥 소스 코드 from sys import stdin def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union_parent(parent, a, b): a = find_parent(parent,a) b = find_parent(parent,b) if a \u0026gt;b: parent[a] = b else: parent[b] = a g = int(stdin.readline()) p = int(stdin.readline()) parent = [x for x in range(g + 1)] res = 0 for i in range(p): gi = int(stdin.readline()) data = find_parent(parent, gi) if data == 0: break res += 1 union_parent(parent, data, data - 1) print(res) 💾 느낀점 내가 좋아하는 Union-Find 문제이다. 처음 풀어보는 유형이라 조금 헷갈리긴 했지만, 게이트와 비행기의 관계를 조금 파악하니\n소스코드라도 짜면서 시도해볼 수 있었다. 유파 알고리즘 문제는 find_parent, union_parent 의 로직을 외워두니 훨~씬 수월했다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-10775-%EA%B3%B5%ED%95%AD-with-python/","summary":"📌 BOJ 10775 공항 💡 조건 및 풀이 공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다. 공항에는 P개의 비행기가 순서대로 도착할 예정. i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다. Union - Find 알고리즘 유형의 문제 비행기를 최대 몇 대 도킹시킬 수 있는지 구하는 문제. 게이트의 수 G (1 ≤ G ≤ 105)","title":"[BOJ] 10775 공항 with Python"},{"content":"\n📌 Programmers - 메뉴 리뉴얼 💡 조건 및 풀이 orders 배열의 크기는 2 이상 20 이하. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열.\n각 문자열은 알파벳 대문자로만 이루어져 있으며 중복은 허용 안함. course 배열의 크기는 1 이상 10 이하.\ncourse 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return\n배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬\n만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return\n무조건 return 하는 배열의 길이가 1 이상 Python 조합(combinations) 라이브러리를 사용해 구현\ndict를 사용해도 되는 문제.\n정렬이 중요한 문제. 각 손님은 단품메뉴를 2개 이상 주문해야 한다. 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함 🔖 예제 및 실행결과 예제 print(solution([\u0026#34;ABCFG\u0026#34;, \u0026#34;AC\u0026#34;, \u0026#34;CDE\u0026#34;, \u0026#34;ACDE\u0026#34;, \u0026#34;BCFG\u0026#34;, \u0026#34;ACDEH\u0026#34;], [2, 3, 4])) 실행결과 [\u0026#34;AC\u0026#34;, \u0026#34;ACDE\u0026#34;, \u0026#34;BCFG\u0026#34;, \u0026#34;CDE\u0026#34;] ⌨️ 문제 풀이 주문을 받은 orders 배열을 순차적으로 순회할 반복문.\n순회하며 메뉴들을 리스트로 만들어 정렬.\n코스를 만들 메뉴 개수를 순회할 반복문. \u0026laquo; 여기까지 2중 반복문. j\n조합 라이브러리를 사용해 3번 반복문에서 나오는 코스의 메뉴개수만큼 메뉴를 뽑아서\n중복을 없앤 뒤 t문자열에 저장. (t는 j 개를 뽑아 만든 메뉴의 조합입니다.)\nlist(set(combinations(data, j))) # set()은 중복을 없애줍니다! t 가 점수판에 없으면 새로 등록시켜 1점 부여\nt 가 점수판에 있으면 1점 부여\n최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합 만 해당하기 때문에\nscore에 저장된 점수가 1점 이상이라면 new_score에 (메뉴, 점수) 형식으로 저장 후 점수를 기준으로 정렬\n\u0026#34;\u0026#34;\u0026#34; # lambda 설명 x 를 x[1] 기준으로 정렬할건데, -가 붙으면 역순입니다. \u0026#34;\u0026#34;\u0026#34; new_score.sort(key=lambda x: -x[1]) 마지막으로 코스요리를 구성할 메뉴 개수를 순회하면서 new_score에 넣은 코스메뉴 후보들을 검사하면서\n정답으로 반환할 배열 answer에 넣어주고, 정렬을 한 뒤 반환 시켜준다.\n🖥 소스 코드 from itertools import combinations def solution(orders, course): answer = [] score = {} n = len(orders) for i in range(n): data = sorted(list(orders[i])) for j in course: for k in list(set(combinations(data, j))): t = \u0026#39;\u0026#39;.join(k) if t in score: score[t] += 1 else: score[t] = 1 new_score = [] for menu, num in score.items(): if num \u0026gt; 1: new_score.append((menu, num)) new_score.sort(key=lambda x: -x[1]) for i in course: max_order = 0 for c, num in new_score: if len(c) == i: if max_order \u0026lt;= num: max_order = num answer.append(c) else: break answer.sort() return answer 💾 느낀점 정렬을 할 때 lambda를 많이 사용한게 도움이 되었다. combinations를 사용해서 번거로운 일이 적어서 좋았다.\n이런 간편한 라이브러리를 알고 있다는 것보다 사용할 때를 알고 있다는게 기분 좋았다. 카카오 기춟문제는 문제도 길고 조건도 자세하게 써있는데 눈에 잘 안들어온다.\n아직 문제 압축능력이 부족한 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC-with-python/","summary":"📌 Programmers - 메뉴 리뉴얼 💡 조건 및 풀이 orders 배열의 크기는 2 이상 20 이하. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열.\n각 문자열은 알파벳 대문자로만 이루어져 있으며 중복은 허용 안함. course 배열의 크기는 1 이상 10 이하.\ncourse 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return\n배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬","title":"[Programmers] 메뉴 리뉴얼 with Python"},{"content":"\n📌 BOJ 2143 두 배열의 합 💡 조건 및 풀이 (-1,000,000,000 ≤ T ≤ 1,000,000,000) (1 ≤ n ≤ 1,000) (1 ≤ m ≤ 1,000) 누적합 유형의 문제 두 배열의 부분배열을 사용하여 합을 구해 T를 만들 수 있는 개수를 구한다. 🔖 예제 및 실행결과 예제 5 4 1 3 1 2 3 1 3 2 실행결과 7 ⌨️ 문제 풀이 A 부분 배열의 합들과 B 부분 배열의 합들을 더해 T가 만들어지는 경우의 수를 구하는 문제였다.\n두 배열을 각 구간에 해당하는 누적합을 각각의 dict 자료구조에 넣고, 중복되어 나오는 경우 +1 을 해준다.\nA 배열의 키 값을 순차적으로 순회하면서\n구하고자 하는 t 값에서 A 배열의 키 값을 빼준 값이 B배열의 키값으로 있다면,\nres에 해당 B배열의 값과 A배열의 값을 곱하여 더해준다.\nfor key in Asum.keys(): if (t - key) in Bsum: res += Bsum[t - key] * Asum[key] 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(int(1e9)) t = int(stdin.readline()) n = int(stdin.readline()) A = list(map(int, stdin.readline().split())) m = int(stdin.readline()) B = list(map(int, stdin.readline().split())) Asum = {} for i in range(n): for j in range(i, n): k = sum(A[i:j + 1]) if k in Asum: Asum[k] += 1 else: Asum[k] = 1 Bsum = {} for i in range(m): for j in range(i, m): k = sum(B[i:j + 1]) if k in Bsum: Bsum[k] += 1 else: Bsum[k] = 1 res = 0 for key in Asum.keys(): if (t - key) in Bsum: res += Bsum[t - key] * Asum[key] print(res) 💾 느낀점 처음에 아이디어가 떠오르지않아 힘들어했다. 수학, DP가 제일 약한 것 같다는 생각이 들었다. Dict 자료구조를 좋아하는데 이렇게 사용을 해봐서 더 좋았다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2143-%EB%91%90-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 2143 두 배열의 합 💡 조건 및 풀이 (-1,000,000,000 ≤ T ≤ 1,000,000,000) (1 ≤ n ≤ 1,000) (1 ≤ m ≤ 1,000) 누적합 유형의 문제 두 배열의 부분배열을 사용하여 합을 구해 T를 만들 수 있는 개수를 구한다. 🔖 예제 및 실행결과 예제 5 4 1 3 1 2 3 1 3 2 실행결과 7 ⌨️ 문제 풀이 A 부분 배열의 합들과 B 부분 배열의 합들을 더해 T가 만들어지는 경우의 수를 구하는 문제였다.","title":"[BOJ] 2143 두 배열의 합 with Python"},{"content":"\n📌 BOJ 1799 비숍 💡 조건 및 풀이 체스판의 크기는 10 이하의 자연수 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0 대각선 방향으로 움직이는 비숍이 이동할 수 있는 경로에 비숍을 놓을 수 없다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 1 실행결과 7 ⌨️ 문제 풀이 흑과 백을 구분할 수 있는 체스판을 True 와 False 를 사용해 다시 만든다. 비숍을 놓을 수 있는 좌표를 흑과 백으로 나누어 각각 black 과 white 리스트에 넣어준다. 비숍을 놓고, 놓을 수 없는 곳을 표시할 때 사용할 isused 리스트를 생성한다. 재귀함수를 타고 각 좌표에 해당하는 곳이 isused01, isused02 모두 사용 중이거나\n놓을 수 없는 자리라면 index를 하나 늘리고 다시 재귀. 4번에 해장하지 않으면 비숍을 놓고 놓은 비숍 개수와 index를 1씩 늘리고 재귀 재귀를 빠져나오면 직전에 놓았던 비숍의 정보를 제거하고 다음 좌표로 넘어가기 위해 index + 1 하고 재귀 index값이 흰색 혹은 검정색 비숍 좌표의 길이와 같다면 검정색의 최댓값과 흰색의 최댓값을 각각 Bcnt와 Wcnt에 저장한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) chess_map = [] black = [] white = [] color = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): color[i][j] = (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0) for i in range(n): chess_map.append(list(map(int, input().split()))) for j in range(n): # True가 검은색 if chess_map[i][j] == 1 and color[i][j] == 1: black.append((i, j)) # False가 흰색 if chess_map[i][j] == 1 and color[i][j] == 0: white.append((i, j)) # 검은색인 경우 Bcnt = 0 # 흰색인 경우 Wcnt = 0 isused01 = [0] * (n * 2 - 1) isused02 = [0] * (n * 2 - 1) def fun(bishop, index, count): global Bcnt, Wcnt if index == len(bishop): rx, ry = bishop[index - 1] # 블랙이면 Bcnt 최대값 if color[rx][ry]: Bcnt = max(Bcnt, count) # 흰색이면 Wcnt 최대값 else: Wcnt = max(Wcnt, count) return x, y = bishop[index] if isused01[x + y] or isused02[x - y + n - 1]: fun(bishop, index + 1, count) else: isused01[x + y] = 1 isused02[x - y + n - 1] = 1 fun(bishop, index + 1, count + 1) isused01[x + y] = 0 isused02[x - y + n - 1] = 0 fun(bishop, index + 1, count) if len(black) \u0026gt; 0: fun(black, 0, 0) if len(white) \u0026gt; 0: fun(white, 0, 0) print(Bcnt + Wcnt) 💾 느낀점 무지성 백트래킹으로 풀려다가 시간초과가 떴다. 백트래킹을 잘하려면 재귀를 잘 짤줄 알아야하는데 아직도 재귀함수가 약점이다. 흑, 백 칸을 구분지어 구현하는데에도 헷갈리는 부분이 있었다. 함수를 구현하고서도 이해가 안되는 부분이 있어서 별표를 많이 쳐놨다. 다시는 풀고 싶지 않은 유형이지만, 그래도 옛날보다는 나아지는 느낌을 받는다.\n다시 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1799-%EB%B9%84%EC%88%8D-with-python/","summary":"📌 BOJ 1799 비숍 💡 조건 및 풀이 체스판의 크기는 10 이하의 자연수 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0 대각선 방향으로 움직이는 비숍이 이동할 수 있는 경로에 비숍을 놓을 수 없다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 1 실행결과 7 ⌨️ 문제 풀이 흑과 백을 구분할 수 있는 체스판을 True 와 False 를 사용해 다시 만든다.","title":"[BOJ] 1799 비숍 with Python"},{"content":"\n📌 BOJ 1967 트리의 지름 💡 조건 및 풀이 노드의 개수 (1 ≤ n ≤ 10,000) 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호\n두 번째 정수는 자식 노드\n세 번째 정수는 간선의 가중치 부모 노드의 번호가 작은 것이 먼저 입력되고,\n부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. BFS 유형의 문제 루트 노드의 번호는 항상 1\n간선의 가중치는 100보다 크지 않은 양의 정수 트리에 존재하는 모든 경로들 중, 가장 긴 경로를 출력하는 문제이다. 🔖 예제 및 실행결과 예제 12 1 2 3 1 3 2 2 4 5 3 5 11 3 6 9 4 7 1 4 8 7 5 9 15 5 10 4 6 11 6 6 12 10 실행결과 45 ⌨️ 문제 풀이 BFS 문제 였지만, 트리의 길이를 구하는 문제라고 하기에 당황을 했다. BFS 를 통해 루트 노드인 1 부터 탐색을 시작해서 가중치가 가장 높은 것을\n반환받아 변수에 담는다. 변수에는 (node, cost) 형식으로 있는데, 이 node 번호를 다시 BFS에 넣어 처리한다. 3번을 통해서 반환 된 (node, cost) 에서 cost가 답이 된다. 다시 설명하자면,\n2번에서 BFS 로 가장 가중치가 많이 쌓이는 노드를 탐색한다. 이를 A-node 라고 하고,\n3번에서 A-node에서부터 가장 가중치가 많이 쌓이는 곳으로 순회를 하여 B-node라고 한다.\n문제에서 설명하듯, 이 두 노드가 가장 높은 가중치를 가지고 있는 경로 즉, 지름이 된다. 🖥 소스 코드 from sys import stdin from collections import deque n = int(stdin.readline()) tree = [[] for _ in range(n + 1)] for _ in range(n - 1): a, b, c = map(int, stdin.readline().split()) tree[a].append((b, c)) tree[b].append((a, c)) def bfs(i): visited = set() q = deque() q.append((i, 0)) visited.add(i) res = (0, 0) while q: now, cost = q.popleft() for n, c in tree[now]: if n not in visited: visited.add(n) t = c + cost q.append((n, t)) if res[1] \u0026lt; t: res = (n, t) return res a = bfs(1) b = bfs(a[0]) print(b[1]) 💾 느낀점 BFS를 응용하여 푸는 문제였다. 두번이나 돌릴 생각을 못해서 헤맸다. 문제를 해석하고 압축하는 능력을 더 키우고, 생각의 전환을 하는 습관을 길러야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1967-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84-with-python/","summary":"📌 BOJ 1967 트리의 지름 💡 조건 및 풀이 노드의 개수 (1 ≤ n ≤ 10,000) 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호\n두 번째 정수는 자식 노드\n세 번째 정수는 간선의 가중치 부모 노드의 번호가 작은 것이 먼저 입력되고,\n부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. BFS 유형의 문제 루트 노드의 번호는 항상 1\n간선의 가중치는 100보다 크지 않은 양의 정수 트리에 존재하는 모든 경로들 중, 가장 긴 경로를 출력하는 문제이다.","title":"[BOJ] 1967 트리의 지름 with Python"},{"content":"\n📌 BOJ 13305 주유소 💡 조건 및 풀이 도시의 개수 2 \u0026lt;= N \u0026lt;= 100000 도시를 연결하는 간선의 길이가 N-1개 주어진다. 그리디 알고리즘 유형 문제 제일 왼쪽에서 오른쪽으로 이동하는 최소 비용을 계산 어느 도시에서 기름을 넣어 이동하는 것이 가장 비용이 저렴한지에 대해 계산하면 된다. 서브태스크 점수가 주어진다 17점 모든 주유소의 리터당 가격은 1원 41점 2 \u0026lt;= N \u0026lt;= 1000\n제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 최대 10000,\n리터 당 가격은 최대 10000 42점 원래의 제약조건 이외에 아무 제약조건이 없다. 🔖 예제 및 실행결과 예제 4 2 3 1 5 2 4 1 실행결과 18 ⌨️ 문제 풀이 도로의 길이를 저장할 리스트 dist\n주유소의 리터당 가격을 저장할 리스트 cost 가장 왼쪽에 있는 도시의 주유소의 리터당 가격을 변수 c 에 넣어준다. k-1 반복문을 실행하여 주유소의 리터 당 가격을 순회한다. 만약 현재 계산된 c 가 i 번째 리터 당 가격보다 비싸다면 c 를 갱신한다.\n그게 아니라면, 결과값을 저장할 res에 리터 당 가격 * i번째 도로의 길이를 더해준다 🖥 소스 코드 from sys import stdin k = int(stdin.readline()) dist = list(map(int, stdin.readline().split())) cost = list(map(int, stdin.readline().split())) res = 0 c = cost[0] for i in range(k - 1): if c \u0026gt; cost[i]: c = cost[i] res += c * dist[i] print(res) 💾 느낀점 그리디 문제라고해서 얕봤다가 로직이 한순간 꼬여서 고생을 좀 했다. 리스트를 따로 처리해 사용하다가 머리가 순간 복잡해지는 것을 방지하기 위해 노력을 해야겠다. 그림을 그려 차분히 로직을 생각하고 구현하는 습관을 길러야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-13305-%EC%A3%BC%EC%9C%A0%EC%86%8C-with-python/","summary":"📌 BOJ 13305 주유소 💡 조건 및 풀이 도시의 개수 2 \u0026lt;= N \u0026lt;= 100000 도시를 연결하는 간선의 길이가 N-1개 주어진다. 그리디 알고리즘 유형 문제 제일 왼쪽에서 오른쪽으로 이동하는 최소 비용을 계산 어느 도시에서 기름을 넣어 이동하는 것이 가장 비용이 저렴한지에 대해 계산하면 된다. 서브태스크 점수가 주어진다 17점 모든 주유소의 리터당 가격은 1원 41점 2 \u0026lt;= N \u0026lt;= 1000\n제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 최대 10000,\n리터 당 가격은 최대 10000 42점 원래의 제약조건 이외에 아무 제약조건이 없다.","title":"[BOJ] 13305 주유소 with Python"},{"content":"\n📌 BOJ 6987 월드컵 💡 조건 및 풀이 6개의 국가가 있고, 총 18번의 경기를 한다. 승, 무, 패의 결과가 있으며, 승, 무, 패의 수는 6보다 작거나 같은 자연수 또는 0 백트래킹 유형의 문제 입력은 네 줄로 들어오며, 각 줄에 대해 가능한 결과 1, 불가능한 결과 0 을출력하는 문제이다 🔖 예제 및 실행결과 예제 5 0 0 3 0 2 2 0 3 0 0 5 4 0 1 1 0 4 4 1 0 3 0 2 4 1 0 1 1 3 0 0 5 1 1 3 5 0 0 4 0 1 2 2 1 2 0 3 1 0 4 0 0 5 5 0 0 3 1 1 2 1 2 2 0 3 0 0 5 1 0 4 실행결과 1 1 0 0 ⌨️ 문제 풀이 data 변수에 각 나라의 일정을 담고, res 베열에 3개씩 쪼개어 다시 넣는다. 결과를 담을 ans 변수를 0으로 초기화 시킨다. 팀끼리의 경기의 조합을 위해 itertools의 combinations를 사용.\ngame이라는 변수에 0~5번의 국가가 경기를 할 수 있는 조합을 만들어 저장한다. solution 함수에서 총 라운드를 파라미터로 입력받으며, 초기의 값은 0이다. 각 라운드를 순회하면서 res 배열의 값을 빼주면서 승, 무, 패 의 값이 남아있다면\nans = 0으로 초기화해서 불가능한 경기라고 answer 리스트에 저장하면 된다. 승에 해당하는 원소를 -1 할 때, 패에 해당하는 원소를 -1 해준다.\n무에 해당하는 원소를 -1 할 때, 무에 해당하는 다른 원소를 -1 해준다. round 값이 15라운드가 되었다면 ans의 값을 1로 변경하고 검사를 시작한다.\nres 변수에 있는 0의 값이 3개가 아니라면 ans 를 0으로 변경 🖥 소스 코드 from sys import stdin from itertools import combinations as cb def solution(round): global ans if round == 15: ans = 1 for sub in res: if sub.count(0) != 3: ans = 0 break return t1, t2 = game[round] for x, y in ((0, 2), (1, 1), (2, 0)): if res[t1][x] \u0026gt; 0 and res[t2][y] \u0026gt; 0: res[t1][x] -= 1 res[t2][y] -= 1 solution(round + 1) res[t1][x] += 1 res[t2][y] += 1 answer = [] game = list(cb(range(6), 2)) # 백트래킹 for _ in range(4): data = list(map(int, stdin.readline().split())) res = [data[i:i + 3] for i in range(0, 16, 3)] ans = 0 solution(0) answer.append(ans) print(*answer) 💾 느낀점 백트래킹을 위해 재귀함수를 구현하여 조건을 풀어내는 일련의 과정이 힘겹다.\n조금 더 백트래킹 및 재귀에 관한 문제를 풀어보아야겠다. 문제를 조금 더 내가 스스로도 납득하고 이해할 수 있게 풀어내는 방법을 생각해봐야겠다. 문제 및 로직에 대해 생각하는 시간이 너무 짧고, 문제를 풀기 위해 손부터 나가는 나쁜 습관을 고쳐야겠다. 아이디어를 떠올리지 못해 고생을 많이 했던 문제인 것 같다.\n블로그에 글을 포스팅하면서 다시 한 번 정리하니 도움이 되는 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-6987-%EC%9B%94%EB%93%9C%EC%BB%B5-with-python/","summary":"📌 BOJ 6987 월드컵 💡 조건 및 풀이 6개의 국가가 있고, 총 18번의 경기를 한다. 승, 무, 패의 결과가 있으며, 승, 무, 패의 수는 6보다 작거나 같은 자연수 또는 0 백트래킹 유형의 문제 입력은 네 줄로 들어오며, 각 줄에 대해 가능한 결과 1, 불가능한 결과 0 을출력하는 문제이다 🔖 예제 및 실행결과 예제 5 0 0 3 0 2 2 0 3 0 0 5 4 0 1 1 0 4 4 1 0 3 0 2 4 1 0 1 1 3 0 0 5 1 1 3 5 0 0 4 0 1 2 2 1 2 0 3 1 0 4 0 0 5 5 0 0 3 1 1 2 1 2 2 0 3 0 0 5 1 0 4 실행결과 1 1 0 0 ⌨️ 문제 풀이 data 변수에 각 나라의 일정을 담고, res 베열에 3개씩 쪼개어 다시 넣는다.","title":"[BOJ] 6987 월드컵 with Python"},{"content":"\n📌 BOJ 16507 어두운 건 무서워 💡 조건 및 풀이 사진 크기를 의미하는 1 \u0026lt;= R, C \u0026lt;= 1000 사진 일부분의 밝기 평균을 알아볼 개수 Q Q개의 각 줄에는 사진의 일부분을 나타내기 위한 두 꼭짓점을 의미하는 정수 r1, c1, r2, c2 가 주어진다.\n(1 ≤ r1 ≤ r2 ≤ R, 1 ≤ c1 ≤ c2 ≤ C) 누적합 문제 Q개의 각 줄에 주어진 사진에서 두 점 (r1, c1)과 (r2, c2)를 꼭짓점으로 하는 직사각형의 밝기 평균을 출력한다. 평균은 정수 나눗셈으로 몫만 취한다. 🔖 예제 및 실행결과 예제 5 6 1 4 1 3 4 9 5 1 2 8 7 5 5 8 1 2 5 3 2 1 5 3 4 2 5 5 2 1 2 3 5 2 2 4 5 실행결과 3 ⌨️ 문제 풀이 누적합 문제다.\n꼭지점을 의미하는 정수가 1부터 시작되기에 인덱스 에러를 조심해야한다.\n그래서 나는 (R + 1) * (C + 1) 크기릐 배열을 만들어 코드도 단순화 시켰다.\n입력 받은 R * C 크기의 데이터를 배열에 넣고 누적합을 구해 배열에 넣어준다.\n꼭지점 좌표를 입력받아 x좌표의 크기를 오픔차순으로 정렬시켰다.\n가장 왼쪽에 위치하고 있는 좌표를 찾으려고 했다.\n직사각형의 크기를 알아야 누적합을 이용해 찾은 밝기의 합도 나눌 수 있다.\n그래서 정렬 시킨 좌표를 사용해 직사각형의 크기를 계산했다.\n(abs(addr[0][0]-addr[1][0]) + 1) * (abs(addr[0][1]-addr[1][1]) + 1) 배열의 각 가로줄마다 따로 계산을 해주었다.\n누적합의 성질은 예를 들자면 다음과 같다.\n[4, 5, 8, 12, 21, 26] 의 배열이 있을 때, 배열의 두번째 원소부터 네번째 원소의 합을 구하려고한다.\n그렇다면 네번째 원소에서 첫번째 원소의 값을 빼주면 구하려는 값이 된다.\n🖥 소스 코드 from sys import stdin r, c, q = map(int, stdin.readline().split()) pic = [[0] * (c + 1)] for i in range(r): sum_list = [0] data = list(map(int, stdin.readline().split())) sum_list.append(data[0]) for i in range(1, c): sum_list.append(sum_list[-1] + data[i]) pic.append(sum_list) for _ in range(q): a, b, c, d = map(int, stdin.readline().split()) addr = [(a, b), (c, d)] addr.sort(key=lambda x: x[0]) res = 0 knife = (abs(addr[0][0]-addr[1][0]) + 1) * (abs(addr[0][1]-addr[1][1]) + 1) for i in range(addr[0][0], addr[1][0] + 1): res += pic[i][addr[1][1]] - pic[i][addr[0][1] - 1] print(res // knife) 💾 느낀점 누적합의 개념과 원리, 성질을 아르바이트 출근하면서 지하철에서 본 것이 큰 도움이 되었다. 인덱스 에러가 쉽게 발생할 수 있을 것 같다는 생각이 들어 다른 풀이도 생각해보았지만 큰 도움은 되지 않았다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-16507-%EC%96%B4%EB%91%90%EC%9A%B4-%EA%B1%B4-%EB%AC%B4%EC%84%9C%EC%9B%8C-with-python/","summary":"📌 BOJ 16507 어두운 건 무서워 💡 조건 및 풀이 사진 크기를 의미하는 1 \u0026lt;= R, C \u0026lt;= 1000 사진 일부분의 밝기 평균을 알아볼 개수 Q Q개의 각 줄에는 사진의 일부분을 나타내기 위한 두 꼭짓점을 의미하는 정수 r1, c1, r2, c2 가 주어진다.\n(1 ≤ r1 ≤ r2 ≤ R, 1 ≤ c1 ≤ c2 ≤ C) 누적합 문제 Q개의 각 줄에 주어진 사진에서 두 점 (r1, c1)과 (r2, c2)를 꼭짓점으로 하는 직사각형의 밝기 평균을 출력한다.","title":"[BOJ] 16507 어두운 건 무서워 with Python"},{"content":"\n📌 BOJ 17521 Byte Coin 💡 조건 및 풀이 주식 시장에서 단타를 치는 국제자본 부동산 회사를 도와 최고의 수익을 내는 문제. 일 수를 나타내는 1 \u0026lt;= n \u0026lt;= 15 초기 현금을 나타내는 W 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는\n정수 si가 주어진다(1 ≤ si ≤ 50). 단순 구현, 그리디 알고리즘 문제 🔖 예제 및 실행결과 예제 10 24 5 7 5 4 2 7 8 5 3 4 실행결과 170 ⌨️ 문제 풀이 현재 매수한 코인이 있는지의 상태를 체크할 수 있는 변수 \u0026quot;m\u0026quot; (기본값은 False)\n코인을 몇개 샀는지에 대한 정보를 넣어줄 변수 \u0026quot;coin\u0026quot; 코인이 다음 날에 가격이 상승하거나 변동이 없다?\n이미 매수한 경우, pass\n매수하지 않은 경우, 구매 코인이 다음 날에 가격이 떨어진다?\n판매 최종적으로 남아 있는 현금을 출력 🖥 소스 코드 from sys import stdin n, w = map(int, stdin.readline().split()) arr = [] for _ in range(n): arr.append(int(stdin.readline())) m = False coin = 0 for i in range(n - 1): if not m and arr[i] \u0026lt; arr[i + 1]: m = arr[i] coin = w // m w -= coin * m elif m and arr[i] \u0026gt; arr[i + 1]: w += arr[i] * coin coin, m = 0, False if m: w += coin * arr[-1] print(w) 💾 느낀점 단순 구현 및 그리디 문제였습니다. 코인을 샀는지 안샀는지에 대한 변수를 추가하여 쉽게 풀 수 있었습니다. 실제 코인 시장이나 은행처럼 x% 수익률 계산했다가 큰 코 다칠뻔했습니다. 문제를 더 확실히 읽고 압축하는 능력을 키워야겠습니다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-17521-byte-coin-with-python/","summary":"📌 BOJ 17521 Byte Coin 💡 조건 및 풀이 주식 시장에서 단타를 치는 국제자본 부동산 회사를 도와 최고의 수익을 내는 문제. 일 수를 나타내는 1 \u0026lt;= n \u0026lt;= 15 초기 현금을 나타내는 W 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는\n정수 si가 주어진다(1 ≤ si ≤ 50). 단순 구현, 그리디 알고리즘 문제 🔖 예제 및 실행결과 예제 10 24 5 7 5 4 2 7 8 5 3 4 실행결과 170 ⌨️ 문제 풀이 현재 매수한 코인이 있는지의 상태를 체크할 수 있는 변수 \u0026quot;m\u0026quot; (기본값은 False)","title":"[BOJ] 17521 Byte Coin with Python"},{"content":"\n📌 BOJ 9934 완전 이진 트리 💡 조건 및 풀이 이진 트리의 깊이를 나타내는 1\u0026lt;=K\u0026lt;=10, 깊이가 K인 이진 트리는 총 2 * K - 1 개의 노드로 이루어져 있다. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다. 이분탐색, 트리, 재귀구현 문제 모든 빌딩의 번호는 중복되지 않는다. 🔖 예제 및 실행결과 예제 3 1 6 4 3 5 2 7 실행결과 3 6 2 1 4 5 7 ⌨️ 문제 풀이 깊이가 k 인 2차원 리스트 res 를 생성하고, 이 리스트에 노드를 쌓을 것입니다. Python 리스트 자료구조의 extend() 함수를 사용했습니다.\nextend는 리스트를 리스트 안으로 넣을 때 리스트의 원소만 넣어줍니다. 입력받은 빌딩번호의 길이를 2로 나누어 값을 mid 변수에 넣어 가지고 있습니다. res에 파라미터로 받은 depth 값을 넣어줍니다.\n가장 맨 처음으로 이분탐색을 통해 뽑아낸 가운데 값이 루트 노드입니다. 가운데 값을 기준으로 양쪽을 분리해 각각 다시 이분탐색을 수행합니다. 이분 탐색을 하다가, 파라미터로 받은 arr 리스트의 길이가 1인 경우 depth 에 해당하는\n리스트에 넣어줍니다. 만들어진 트리(res)를 출력해줍니다. 파이썬으로 재귀를 구현할 때,아래의 함수를 사용해야 에러가 나지 않는 경우가 많습니다.\n쓴다고 문제될 것이 없으니, 재귀를 구현하여 문제를 푸실 때 꼭 입력하세요.\nsetrecursionlimit(int(1e9))​ 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(int(1e9)) k = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) res = [[] for _ in range(k)] def binary_separation(arr, depth): if len(arr) == 1: res[depth].extend(arr) return length = len(arr) mid = length // 2 res[depth].append(arr[mid]) binary_separation(arr[:mid], depth + 1) binary_separation(arr[mid + 1:], depth + 1) binary_separation(arr, 0) for i in range(k): if i == 0: print(res[i][0]) else: print(*res[i]) 💾 느낀점 이분탐색과 재귀를 사용하여 문제를 푸는 방식에 익숙해진 것을 느꼈다. 분할 정복 문제를 풀다가 이 문제를 푸니 훨씬 도움이 되었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-9934-%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-with-python/","summary":"📌 BOJ 9934 완전 이진 트리 💡 조건 및 풀이 이진 트리의 깊이를 나타내는 1\u0026lt;=K\u0026lt;=10, 깊이가 K인 이진 트리는 총 2 * K - 1 개의 노드로 이루어져 있다. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다. 이분탐색, 트리, 재귀구현 문제 모든 빌딩의 번호는 중복되지 않는다. 🔖 예제 및 실행결과 예제 3 1 6 4 3 5 2 7 실행결과 3 6 2 1 4 5 7 ⌨️ 문제 풀이 깊이가 k 인 2차원 리스트 res 를 생성하고, 이 리스트에 노드를 쌓을 것입니다.","title":"[BOJ] 9934 완전 이진 트리 with Python"},{"content":"\n📌 Programmers - 문자열 압축 💡 조건 및 풀이 입력 받는 의 길이는 1 \u0026lt;= s \u0026lt;= 1000, 소문자로만 이루어져 있다. 문자열을 1개 단위로 자르는 것부터 s의 길이 만큼 자르는 것까지 계산 완전탐색, 구현 문제 문자열을 자르고 숫자를 붙이는 것에서 쓸데 없는 문자가 들어가지 않도록 주의 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;aabbaccc\u0026#34;)) print(solution(\u0026#34;ababcdcdababcdcd\u0026#34;)) print(solution(\u0026#34;abcabcdede\u0026#34;)) print(solution(\u0026#34;abcabcabcabcdededededede\u0026#34;)) print(solution(\u0026#34;xababcdcdababcdcd\u0026#34;)) 실행결과 7 9 8 14 17 ⌨️ 문제 풀이 answer의 값을 s의 길이로 초기화.\ns의 길이만큼 자른것이 가장 짧을 수 있기 때문에 s의 길이로 초기화한다. 1개부터 s의 길이만큼 잘라주면서 진행을 할 것이기 때문에 1부터 s+1 까지 반복문을 진행 자른 문자열은 이미 1개만큼 잘랐기 때문에 cnt = 1 로 초기화 자른 문자열과 같은 문자열이 진행하면서 있을 경우, cnt += 1 자른 문자열과 다른 문자열이 발견되었을 경우, 검사할 문자를 교체한다\n지금까지 검사해주던 단어와 늘려온 cnt를 std에 넣어주고 다시 검사 진행. 검사가 끝난 뒤, std의 길이가 기존의 answer 보다 작다면 갱신. 🖥 소스 코드 def solution(s): k = len(s) answer = k for idx in range(1, k + 1): std = \u0026#39;\u0026#39; checker = s[0: idx] std += checker start, end = 0, idx cnt = 1 for i in range(idx, k + 1, idx): if i == k: if cnt \u0026lt;= 1: break else: std += str(cnt) break if checker == s[start + i:end + i]: cnt += 1 elif cnt \u0026lt;= 1: std += s[start + i:end + i] checker = s[start + i:end + i] continue else: std += str(cnt) cnt = 1 std += s[start + i:end + i] checker = s[start + i:end + i] answer = min(answer, len(std)) return answer 💾 느낀점 나는 구현이 매우 약하기 때문에 연습하기 굉장히 좋은 문제였던 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-with-python/","summary":"📌 Programmers - 문자열 압축 💡 조건 및 풀이 입력 받는 의 길이는 1 \u0026lt;= s \u0026lt;= 1000, 소문자로만 이루어져 있다. 문자열을 1개 단위로 자르는 것부터 s의 길이 만큼 자르는 것까지 계산 완전탐색, 구현 문제 문자열을 자르고 숫자를 붙이는 것에서 쓸데 없는 문자가 들어가지 않도록 주의 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;aabbaccc\u0026#34;)) print(solution(\u0026#34;ababcdcdababcdcd\u0026#34;)) print(solution(\u0026#34;abcabcdede\u0026#34;)) print(solution(\u0026#34;abcabcabcabcdededededede\u0026#34;)) print(solution(\u0026#34;xababcdcdababcdcd\u0026#34;)) 실행결과 7 9 8 14 17 ⌨️ 문제 풀이 answer의 값을 s의 길이로 초기화.","title":"[Programmers] 문자열 압축 with Python"},{"content":"\n📌 BOJ 2458 키 순서 💡 조건 및 풀이 1번부터 N번까지 번호가 붙여져 있는 학생들끼리 두 명씩 키를 비교했다. N명의 학생들은 모두 키가 다르다. 플로이드와샬 알고리즘으로 해결이 가능한 문제이다. 2 \u0026lt;= N \u0026lt;= 500, 0 \u0026lt;= M \u0026lt;= N(N-1)/2 M개의 줄에 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a, b가 주어진다. a, b == a가 b보다 작다 자신의 키가 몇번째인지 알 수 있는 학생의 수를 구하는 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) inf = int(1e9) graph = [[inf] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) graph[b][a] = 1 for i in range(1, n + 1): for j in range(1, n + 1): for k in range(1, n + 1): if j == k: graph[j][k] = 0 continue if graph[j][k] \u0026gt; graph[j][i] + graph[i][k]: graph[j][k] = graph[j][i] + graph[i][k] res = n for i in range(1, n + 1): checker = 1 for j in range(1, n + 1): if graph[i][j] == inf and graph[j][i] == inf: res -= 1 checker = 0 if not checker: break print(res) 🔖 예제 및 실행결과 예제 6 7 1 3 1 5 3 4 5 4 4 2 4 6 5 2 실행결과 2 ⌨️ 문제 풀이 최소 거리를 정해준다고 생각하고 플로이드 와샬을 사용하기 위해 2차원 리스트를 만들고\nINF 값을 넣어 리스트를 초기화했다. a, b 값을 입력받게 되면 a 가 b 보다 작다 라는 조건에 따라, 2차원 리스트에 graph[b].append(a) 플로이드 와샬 알고리즘 실행 자신의 키가 몇등인지 알 수있는 사람을 처음부터 N명이라고 정의한 뒤 1번 학생부터 순차적으로\n2중 반복문을 사용해 플로이드 와샬로 만든 2차원 리스트에 접근 if graph[i][j] == inf and graph[j][i] == inf:\ni번 학생이 j번 학생과의 작다, 크다의 정보가 아무것도 없다면 res -= 1 2중 반복문을 빠져나오기 위한 checker변수에 0을 넣어주고(False) 반복문 탈출 PyPy3 제출 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) inf = int(1e9) graph = [[inf] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) graph[b][a] = 1 for i in range(1, n + 1): for j in range(1, n + 1): for k in range(1, n + 1): if j == k: graph[j][k] = 0 continue if graph[j][k] \u0026gt; graph[j][i] + graph[i][k]: graph[j][k] = graph[j][i] + graph[i][k] res = n for i in range(1, n + 1): checker = 1 for j in range(1, n + 1): if graph[i][j] == inf and graph[j][i] == inf: res -= 1 checker = 0 if not checker: break print(res) 💾 느낀점 문제를 보자마자 플로이드와샬 알고리즘과 유니온-파인드가 생각났다.\n유니온-파인드로 구현을 하려다보니 절대 아닌 것 같아 플로이드와샬을 사용하기로 했다. 아는 분들의 이야기를 들어보니 BFS로 구현하셨다고 했다. 플로이드 와샬 알고리즘으로 해결했을 때, Python3 로 시간초과가 생겼으며, PyPy3 는 통과 BFS로 풀이하는 방법도 구현해봐야겠다. 문제를 풀시간은 없는데 생각할 시간이 너무 길다. 아직 숙달이 되지 못한 것이라고 생각하고 더 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-2458-%ED%82%A4-%EC%88%9C%EC%84%9C-with-python-feat.-pypy3/","summary":"📌 BOJ 2458 키 순서 💡 조건 및 풀이 1번부터 N번까지 번호가 붙여져 있는 학생들끼리 두 명씩 키를 비교했다. N명의 학생들은 모두 키가 다르다. 플로이드와샬 알고리즘으로 해결이 가능한 문제이다. 2 \u0026lt;= N \u0026lt;= 500, 0 \u0026lt;= M \u0026lt;= N(N-1)/2 M개의 줄에 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a, b가 주어진다. a, b == a가 b보다 작다 자신의 키가 몇번째인지 알 수 있는 학생의 수를 구하는 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.","title":"[BOJ] 2458 키 순서 with Python (Feat. PyPy3)"},{"content":"\n📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,\n입력받은 N이 비어있는 문자열 ''이면 break 입력받은 N이 0, -의 개수가 1이라면 print('-') (N ** 3) * '-' == 하이픈의 개수 만들어진 하이픈을 분할 정복 함수에 넣는다.\n각 파라미터는 3 ** N개의 하이픈과 인덱스 번호이다. 인덱스 번호는 세등분이 된 문자열의 각 인덱스 번호이며, 재귀를 통해 인덱스 번호가 1인\n문자열을 공백으로 만들어주면 된다. 문자열은 파라미터로 받은 문자열 길이를 3으로 나누어\n그 길이만큼 리스트를 슬라이싱해 arr 리스트에 넣는다. 반환 조건은 아래의 두가지로 만들었다. 문자열의 길이가 3이고 인덱스 번호가 1이 아닐 때에는 \u0026lsquo;- -\u0026lsquo;을 리턴 문자열의 길이가 3보다 같거나 크며, 인덱스 번호가 1일 때는 문자열의 길이만큼 공백을 반환 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) def div(s, idx): ls = len(s) if ls == 3 and idx != 1: return \u0026#39;- -\u0026#39; elif ls \u0026gt;= 3 and idx == 1: return s.replace(\u0026#39;-\u0026#39;, \u0026#39; \u0026#39;) arr = [] for i in range(0, ls, ls // 3): arr.append(string[i:i+ls//3]) k = div(arr[0], 0) + div(arr[1], 1) + div(arr[2], 2) return k while 1: k = \u0026#39;-\u0026#39; n = stdin.readline().rstrip() if n == \u0026#39;\u0026#39;: break num = (3 ** int(n)) if num == 1: print(\u0026#39;-\u0026#39;) continue string = k * num arr = div(string, 0) print(arr) 💾 느낀점 분할 정복을 사용하기로 하고 인덱스를 같이 파라미터 값으로 넣자고 생각했다.\n좋은 아이디어가 한번에 떠올라서 매우 좋았다. 성공적인 풀이였다. 재귀 사용 실력이 최악이라 사용자체가 많이 힘들었지만\n예전보다는 사용하기 매우 수월해졌다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-4779-%EC%B9%B8%ED%86%A0%EC%96%B4-%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,","title":"[BOJ] 4779 칸토어 집합 with Python"},{"content":"\n📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 \u0026lt;= N \u0026lt;= 10 각 카드에 숫자가 적혀있다. 1 \u0026lt;= 숫자 \u0026lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions\npermutations라는 순열 함수를 사용했다.\n리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다. 리스트에는 같은 숫자도 존재하며, 충분히 순열로 리스트를 만들었을 때, 중복이 존재한다. 결과를 반환할 set() 자료구조를 만든 후 for 문을 사용해서 순열리스트에 차례대로 접근하면서, 문자열로 만들어주면서 합친다. 합쳐진 문자열을 set() 자료구조로 만든 변수에 추가한다. 중복으로 추가가 되지 않는다 set() 변수의 길이를 재서 출력. 🖥 소스 코드 from sys import stdin from itertools import permutations as p arr = [] n, k = int(stdin.readline()), int(stdin.readline()) for i in range(n): arr.append(int(stdin.readline())) res = set() for i in list(p(arr, k)): res.add(\u0026#39;\u0026#39;.join(list(map(str, i)))) print(len(res)) 💾 느낀점 처음엔, 순열 리스트로만 만들어서 길이를 쟀다. -\u0026gt; TLE 순열 리스트에 순차적으로 접근해서 문자열로 만들어 조합을 본 뒤\n풀어나가는 아이디어, set() 자료구조를 사용할 아이디어를 떠올린 뒤\n바로 풀었다. 비교적 실버 문제가 쉽고 개념을 쌓기에 좋은 문제들이 많은 것 같다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-5568-%EC%B9%B4%EB%93%9C-%EB%86%93%EA%B8%B0-with-python/","summary":"📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 \u0026lt;= N \u0026lt;= 10 각 카드에 숫자가 적혀있다. 1 \u0026lt;= 숫자 \u0026lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions\npermutations라는 순열 함수를 사용했다.\n리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다.","title":"[BOJ] 5568 카드 놓기 with Python"},{"content":"\n📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다. - dict 이름만 저장하는 리스트를 사용한다 - list 문자열로 입력이 들어왔을 때, dict 자료형에서 매핑된 번호를 꺼낸다. 숫자로 입력이 들어왔을 때, list 자료형에서 매핑된 이름을 꺼낸다. 🖥 소스 코드 import sys n, m = map(int, sys.stdin.readline().split()) pokemon = {} pokemon_nm = [] for i in range(n): nm = sys.stdin.readline().rstrip() pokemon[nm] = i pokemon_nm.append(nm) for _ in range(m): c = sys.stdin.readline().rstrip() if c.isnumeric(): print(pokemon_nm[int(c) - 1]) else: print(pokemon[c] + 1) 💾 느낀점 key - value 로 매핑되는 dict 자료형으로 구현하기로 결정했는데,\n문제를 보고 바로 떠올린 것에 대해서 큰 뿌듯함이 들었다. 문제를 쉽게 풀어서 그런지, 기분좋은 공부의 시작이 되었다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-1620-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C-with-python/","summary":"📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다.","title":"[BOJ] 1620 나는야 포켓몬 마스터 이다솜 with Python"},{"content":"\n📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다. 단방향 간선이기 때문에 graph[a].append(b) bfs(x)에서 사용하는 방문처리용 자료구조를 list가 아닌 set으로 사용했다. queue에는 현재 노드와 비용에 대해서 튜플로 만들어 넣어준다.\n단, 이미 방문했던 노드는 다시 방문하지 않는다. = visited 🖥 소스 코드 from sys import stdin from collections import deque n, m, k, x = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] for i in range(m): a, b = map(int, stdin.readline().split()) graph[a].append(b) def bfs(x): res = [] visited = set() q = deque() q.append((x, 0)) visited.add(x) while q: now, cost = q.popleft() if cost == k: res.append(now) for i in graph[now]: if i not in visited: q.append((i, cost + 1)) visited.add(i) if not res: print(-1) else: res.sort() for i in res: print(i) bfs(x) 💾 느낀점 다익스트라, BFS 문제의 유형은 더 많이 풀어봐야겠다. 개념이 조금 익혀져 있는 다익스트라 기본 문제를 풀어서 쉽게 풀 수 있었다. 플로이드 와샬로는 시도해보지 않았다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-18352-%ED%8A%B9%EC%A0%95-%EA%B1%B0%EB%A6%AC%EC%9D%98-%EB%8F%84%EC%8B%9C-%EC%B0%BE%EA%B8%B0-with-python/","summary":"📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다.","title":"[BOJ] 18352 특정 거리의 도시 찾기 with Python"},{"content":"\n📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용. list로 받은 수열을 sort()로 정렬. 정렬된 리스트에 대해 0번 인덱스부터 순차적으로 접근하며\nbisect_left, bisect_right 함수를 사용해 반환받은 값(l, r)을 비교한다. 수열의 총 개수(n)보다 bisect_left 로 반환받은 값(l)이 작을 때만 실행한다. 현재 수열의 i번째 숫자와 수열의 l번째 숫자가 같지 않으며, r과 l이 같지 않을 때 cnt += 1 따로 for문의 범위를 지정해주지 않으면, 정답에 해당하는 (A[i], A[j]) 쌍이\n두번이 나오기 때문에 cnt // 2를 해준다. 🖥 소스 코드 from sys import stdin from bisect import bisect_right, bisect_left n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() x = int(stdin.readline()) cnt = 0 for i in range(n): l, r = bisect_left(arr, x - arr[i]), bisect_right(arr, x - arr[i]) if l \u0026lt; n: if arr[i] != arr[l] and l != r: cnt += 1 print(cnt // 2) 💾 느낀점 n을 순차적으로 접근할 for문의 범위를 잘못 지정해주어서 틀렸었다. bisect 라이브러리를 사용해 찾으려고 하는 숫자의 인덱스 번호를 잘못 계산해서 틀렸었다. 이분탐색 문제를 더 많이 풀어보고, 다양한 유형을 경험해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-3273-%EB%91%90-%EC%88%98%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용.","title":"[BOJ] 3273 두 수의 합 with Python"},{"content":"\n📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ```python \u0026lt;br\u0026gt; ### ⌨️ 문제 풀이 1. 편한 계산을 위해 dp를 `n + 1`의 크기만큼 생성했다. 2. **상담을 하는데 필요한 시간을 담을 리스트** `T`를 생성 3. **상담을 하면 얻을 수 있는 이익을 담을 리스트** `P`를 생성 4. 1일째부터 상담을 진행하면 얻을 수 있는 이익을 DP 리스트에 최댓값으로 갱신 5. **상담을 시작한 날의 이익의 데이터가 DP 리스트의 상담이 끝나는 날 위치에 들어감** 6. i번째 날에 상담을 시작했으면, `i + t[i]` 가 n을 넘지 말아야한다. 즉, 7(N)일 남은 퇴사 예정자가 퇴사 하루 전 날(i = 7)에 `T[i]` 2일 걸릴 상담을 시작하면, 끝내지 못하기에(N \u0026lt; Ti + i) 이익을 취할 수 없다. 7. k 라는 변수를 만들어, `dp[i]`와 k 중 가장 큰 값을 집어넣는다. 이 값과 `dp[i + t[i]]` 이 값을 비교하여 큰 값을 `dp[i + t[i]]`에 넣는다. \u0026lt;br\u0026gt; ### 🖥 소스 코드 ```python from sys import stdin n = int(stdin.readline()) t, p = [], [] dp = [0 for _ in range(n + 1)] for _ in range(n): ti, pi = map(int, stdin.readline().split()) t.append(ti) p.append(pi) k = 0 for i in range(n): k = max(k, dp[i]) if i + t[i] \u0026gt; n: continue dp[i + t[i]] = max(k + p[i], dp[i + t[i]]) print(max(dp)) 💾 느낀점 다이나믹 프로그래밍 문제에 매우 약하다. 여러 문제를 꾸준히 풀어봐야겠다. 다이나믹 프로그래밍 부분에서는 구현 부분에서 굉장히 헤매는 것 같다.\n각 변수의 사용처, 갱신 등을 더 꼼곰히 체크해서 사고하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-15486-%ED%87%B4%EC%82%AC-2-with-python/","summary":"📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ```python \u0026lt;br\u0026gt; ### ⌨️ 문제 풀이 1.","title":"[BOJ] 15486 퇴사 2 with Python"},{"content":"\n📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,\nT1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 응시자, 테이블, 파티션 = P, O, X 정확성 테스트의 시간은 10초. 🔖 예제 및 실행결과 예제 places = [[\u0026#34;POOOP\u0026#34;, \u0026#34;OXXOX\u0026#34;, \u0026#34;OPXPX\u0026#34;, \u0026#34;OOXOX\u0026#34;, \u0026#34;POXXP\u0026#34;], [\u0026#34;POOPX\u0026#34;, \u0026#34;OXPXP\u0026#34;, \u0026#34;PXXXO\u0026#34;, \u0026#34;OXXXO\u0026#34;, \u0026#34;OOOPP\u0026#34;], [\u0026#34;PXOPX\u0026#34;, \u0026#34;OXOXP\u0026#34;, \u0026#34;OXPOX\u0026#34;, \u0026#34;OXXOP\u0026#34;, \u0026#34;PXPOX\u0026#34;], [\u0026#34;OOOXX\u0026#34;, \u0026#34;XOOOX\u0026#34;, \u0026#34;OOOXX\u0026#34;, \u0026#34;OXOOX\u0026#34;, \u0026#34;OOOOO\u0026#34;], [\u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;]] 실행결과 [1, 0, 1, 1, 1] ⌨️ 문제 풀이 정확성 테스트가 있기 때문에 시간초과 및 메모리 초과에 신경을 써야한다.\n그러므로 응시자들의 좌표만 따로 배열로 받아서 맨해튼 거리를 구한 뒤 맨해튼 거리가 2 이하인 것들만 BFS를 통해\n응시자 사이가 파티션으로 막혀 있는지 확인한다.\n대기실을 BFS로 돌면서 큐에 이동 거리, 좌표, 움직인 이동 좌표를 배열로 넣어 주며,\n이동 거리가 맨해튼 거리보다 멀다면 BFS 과정을 skip 한다.\n두 응시자의 맨해튼 거리가 2 이하일 때, 사이에 파티션이 있는 경우를 처리 하지 못해서 테스트 케이스 5번이 틀렸다.\n내가 틀린 반례는 아래와 같다. 답은 1이다.\n[[\u0026#34;OPXPO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;]] 🖥 소스 코드 from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] def bfs(board, now, goal, dist): q = deque() visited = [] x, y = now q.append((0, x, y, [])) visited.append(now) check = False while q: cost, x, y, visit = q.popleft() # 움직인 거리가 맨헤튼 거리보다 많으면 넘어가기 if cost \u0026gt; dist: continue if (x, y) == goal: for i, j in visit: if board[i][j] == \u0026#39;X\u0026#39;: check = True elif board[i][j] == \u0026#39;O\u0026#39;: return False for i in range(4): nx, ny = dx[i] + x, y + dy[i] if -1 \u0026lt; nx \u0026lt; 5 and -1 \u0026lt; ny \u0026lt; 5: if (nx, ny) not in visited: # 목표 지점을 visited 에 넣지 않는다. # 가능한 많은 경로를 염두에 두어 계산한다. if (nx, ny) != goal: visited.append((nx, ny)) temp = visit[:] temp.append((nx, ny)) q.append((cost + 1, nx, ny, temp)) return check def solution(places): answer = [] for i in range(len(places)): board = [] data = places[i] ps = [] # 대기실 리스트 만들기 for j in range(5): for k in range(5): if data[j][k] == \u0026#39;P\u0026#39;: ps.append((j, k)) board.append(list(data[j])) ps.sort() check = True for j in range(len(ps)): x1, y1 = ps[j] for k in range(j + 1, len(ps)): x2, y2 = ps[k] dist = abs(x1 - x2) + abs(y1 - y2) if dist \u0026lt; 3: if not bfs(board, ps[j], ps[k], dist): check = False break if not check: break answer.append(1) if check else answer.append(0) return answer 💾 느낀점 어제 풀었던 불! 보다 쉬웠다. 반례 테스트 케이스를 찾는데 조금 어려움이 있었다. BFS는 짜기 나름인 것 같다. queue 에 넣는 정보를 다양하게 사용하는 법이 익숙해지고 있는 것 같아 좋다.\n그러나 visited 배열을 더 다양하게 사용하는 법을 연습해야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-with-python/","summary":"📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,","title":"[Programmers] 거리두기 확인하기 with Python"},{"content":"\n📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다. 입력받은 expression의 정보를 담을 변수를 하나 만들고,\n문자열에서 연산자를 구분한 뒤 숫자는 정수형 변수로 변환시켜 각각 리스트에 담는다. 연산자의 우선순위는 itertools 의 permutaions 를 사용해 순열을 만든 후\nset()을 통해 순열의 중복을 없앴다. 각 순열을 하나씩 for 문으로 꺼내고, 그 순열의 원소를 돌며 최댓값을 계산한다. 주어지는 문자열의 길이가 매우 길지 않은 점\npython 언어의 list와 문자열에 있는 index() 함수를 사용. 리스트의 index() 함수는 찾고자 하는 데이터의 가장 앞에 있는 것을 반환\n그렇기 때문에 같은 연산자인 경우 우선순위가 앞에 있다는 점을 만족한다 해당하는 인덱스의 연산자 앞 뒤의 숫자를 연산자에 맞게 계산 후,\n계산한 연산자와 피연산자를 뺀 자리에 계산값을 넣음 반복하여 1개 남은 원소 즉, 수식의 최종 계산값을 answer 와 비교해 큰 값으로 교체해주면 된다.\n뮬론 음수는 abs() 함수를 사용해 양수로 변경해주었다. 🖥 소스 코드 from itertools import permutations as pt def solution(expression): answer = -1e9 op, nums = [], [] a, b = -1, -1 new_ex = [] for i in range(len(expression)): if expression[i].isnumeric(): if a \u0026lt; 0: a = i else: b = i else: if b \u0026lt; 0: b = a op.append(expression[i]) nums.append((a, b)) new_ex.append(int(expression[a:b+1])) new_ex.append(expression[i]) a, b = -1, -1 if b \u0026gt; -1: new_ex.append(int(expression[a:b+1])) else: new_ex.append(int(expression[a])) k = list(set(op)) for case in list(set(pt(k, len(k)))): temp_new_ex = new_ex[:] for j in case: while j in temp_new_ex: idx = temp_new_ex.index(j) if j == \u0026#39;*\u0026#39;: temp = temp_new_ex[idx - 1] * temp_new_ex[idx + 1] elif j == \u0026#39;-\u0026#39;: temp = temp_new_ex[idx - 1] - temp_new_ex[idx + 1] else: temp = temp_new_ex[idx - 1] + temp_new_ex[idx + 1] temp_new_ex = temp_new_ex[:idx - 1] + [temp] + temp_new_ex[idx + 2:] answer = max(answer, abs(temp_new_ex[0])) return answer 💾 느낀점 정규표현식으로 연산자와 피연산자를 구분하여 추출해서 풀면,\n시간복잡도가 더 줄 수도 있을 것 같다. 정규표현식을 더 공부하고 연습해보아야겠다. 이보다 expression의 길이가 더 길어 시간초과가 날 때는 어떻게 할 것인지\n연산을 더 줄일 수 있는 방법을 생각해봐야겠다. 괄호를 넣어 eval() 함수를 사용하는 것도 생각해보았는데, 실행 속도에서 생각해보니\n그리 좋지 않은 풀이 방법인 것 같아 사용하지 않았다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94-with-python/","summary":"📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다.","title":"[Programmers] 수식최대화 with Python"},{"content":"\n📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산\ni에서 j로 가는 비용과 i에서 k를 경유하여 j로 가는 비용 중에 더 저렴한 것 answer를 더 저렴한 비용을 비교하기 위해 1e9로 초기화 for 문으로 1번 노드부터 n번 노드까지 아래의 내용을 검사한다.\nanswer와 출발지(s)에서 i까지 합승한 값 + i 부터 B의 목적지까지 가는 값 + i 부터 A의 목적지까지 가는 값 비교 🖥 소스 코드 from collections import deque def solution(n, s, a, b, fares): answer = int(1e9) INF = int(1e9) distance = [[INF] * (n + 1) for _ in range(n + 1)] for q, w, e in fares: distance[q][w] = e distance[w][q] = e for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if i == j: distance[i][j] = 0 else: if distance[i][j] \u0026gt; distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] for i in range(1, n + 1): if answer \u0026gt; distance[s][i] + distance[i][b] + distance[i][a]: answer = distance[s][i] + distance[i][b] + distance[i][a] return answer 💾 느낀점 BFS로 최단거리를 찾아보기 위해 이동거리 값을 저장하는 큐를 생성해 문제를 풀려고 시도했다.\n그 결과 시간을 매우 낭비하게 되었고, 플로이드 와샬을 떠올려 문제 풀이를 했다. 플로이드 와샬 구현 방법을 조금 헷갈리는 문제점이 있었다.\n플로이드 와샬이면 굳이 BFS가 없는데 위에서 말한 BFS 소스코드를 그대로 두었었다. 시간초과가 났다. 26번 테스트 케이스에서 시간초과가 났다.\n플로이드 와샬 부분과 반환할 answer를 위해 비교하는 부분에서 min() 대신\nif를 써주었더니 속도차이가 두 배 가까이 났다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/programmers-%ED%95%A9%EC%8A%B9-%ED%83%9D%EC%8B%9C-%EC%9A%94%EA%B8%88-with-python/","summary":"📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산","title":"[Programmers] 합승 택시 요금 with Python"},{"content":"\n📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다. 임시 배열을 만들어 불과 지훈이가 움직일 때 이동 가능한 경로를 모두 넣어주고 while 문이 종료되었을 때 큐에 삽입 지훈이가 지나간 곳은 '$'로 변경 불은 '$' 와 '.' 를, 지훈이는 오로지 '.' 만 갈 수 있게 처리. 지훈이가 움직일 때, Queue 에서 현재 지훈이의 좌표를 뽑아, 벽에 위치하고 있다면 탈출 성공. if x == 0 or y == 0 or x == r - 1 or y == c - 1: 더 이상 지훈이가 움직일 경로가 없다면 탈출 실패 if not J: 🖥 소스 코드 from sys import stdin from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, 1, -1] r, c = map(int, stdin.readline().split()) board, res = [], 0 # 지환이와 불난 곳 저장할 변수 F, J = deque(), deque() for i in range(r): data = list(stdin.readline().rstrip()) for j in range(c): if data[j] == \u0026#39;J\u0026#39;: J.append((i, j)) if data[j] == \u0026#39;F\u0026#39;: F.append((i, j)) board.append(data) def bfs(): global F, J, res while 1: res += 1 temp = [] while F: x, y = F.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c: if board[nx][ny] == \u0026#39;.\u0026#39; or board[nx][ny] == \u0026#39;$\u0026#39;: temp.append((nx, ny)) board[nx][ny] = \u0026#39;F\u0026#39; F = deque(temp) temp = [] while J: x, y = J.popleft() if x == 0 or y == 0 or x == r - 1 or y == c - 1: return res for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c and board[nx][ny] == \u0026#39;.\u0026#39;: temp.append((nx, ny)) board[x][y] = \u0026#39;$\u0026#39; board[nx][ny] = \u0026#39;J\u0026#39; J = deque(temp) if not J: return False if bfs(): print(res) else: print(\u0026#39;IMPOSSIBLE\u0026#39;) 💾 느낀점 BFS 유형 문제에서 난이도가 실버2 ~ 골드4 로만 올라가도 헤매는 모습을 보였다. 방문처리용 배열의 다양한 사용법을 눈에 익히고 응용할 줄 알아야겠다. 방문처리용 배열을 사용하기 전, 메모리 초과가 뜰 각인지 잴 줄 알아야겠다. 문제를 나름대로 해석하고 압축하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-4179-%EB%B6%88-with-python/","summary":"📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다.","title":"[BOJ] 4179 불! with Python"},{"content":"\n📌 BOJ 17103 골드바흐 파티션 💡 조건 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.\n짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다.\n짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.\n첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다.\n각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 \u0026lt; N ≤ 1,000,000을 만족한다.\n정수론, 소수판별, 에라토스테네스의 체 유형의 문제\n🔖 예제 및 실행결과 예제 5 6 8 10 12 100 실행결과 1 1 2 1 6 ⌨️ 문제 풀이 소수판별 리스트를 만들어 반환하는 함수를 통해서 소수 리스트를 얻는다.\n각 테스트 케이스마다 입력받은 숫자 num // 2 + 1에 해당하는 숫자까지 순회하면서 골드바흐 파티션의 수를 세어 출력한다\n🖥 소스 코드 from sys import stdin def prime_list(n): sieve = [False, False] + [True] * n m = int(n ** 0.5) for i in range(2, m + 1): if sieve[i]: for j in range(i + i, n, i): sieve[j] = False return sieve prime_nums = prime_list(10 ** 6) for _ in range(int(stdin.readline())): cnt = 0 num = int(stdin.readline()) for i in range((num // 2) + 1): if prime_nums[i] and prime_nums[num - i]: cnt += 1 print(cnt) ","permalink":"https://jxun-h.github.io/posts/problem-solving/boj-17103-%EA%B3%A8%EB%93%9C%EB%B0%94%ED%9D%90-%ED%8C%8C%ED%8B%B0%EC%85%98-with-python/","summary":"📌 BOJ 17103 골드바흐 파티션 💡 조건 골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.\n짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다.\n짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.\n첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다.\n각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 \u0026lt; N ≤ 1,000,000을 만족한다.","title":"[BOJ] 17103 골드바흐 파티션 with Python"},{"content":" 안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Contact. Github : github.com/Jxun-h\nTistory : dreamtreeits.tistory.com\nEmail : its1108@kakao.com Resume. 이력과 포트폴리오를 기재한 이력서입니다. Introduction. 트레이드 오프를 고려해 균형잡힌 선택을 하려 노력합니다.\n안정적인 서비스를 만드는데 기여하고자 노력하는 백엔드 개발자입니다.\n또한 서비스가 안정적으로 운영되기 위한 방법에 대해 고민합니다. Why Post in Blog. 블로그를 처음 쓰기 시작한 것은 2021년 08월 28일 입니다.\n코딩 테스트를 위해 고민했던 내용과 해결 과정들을 오로지 머리로만 기억하는 것에 한계가 있음을 느꼈습니다.\n블로그를 제 두뇌의 외장하드로 쓰기 결심하고, 티스토리에서 포스팅을 시작했습니다.\n그 후 약 1년간 꾸준히 알고리즘 풀이를 포스팅 했고, 2023년 4월 18일 이후 공백기간이 있었습니다.\n2024년을 맞이해 블로그 작성을 통해 쌓여가는 경험과 지식을 되돌아보고 회고록도 써보려고 합니다.\n다시 시작하는 저의 블로그는 github.io 로 시작해보려 합니다. ","permalink":"https://jxun-h.github.io/about/","summary":"짤막한 소개글","title":"About"},{"content":"안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Work Experience TAPartners period 24.01 - current position Back-end Engineer project 건설사업관리 플랫폼 고도화 자세히 보기\n건설사업관리 플랫폼 고도화\n기획 중 Tech Stack\nVue3 Java Oracle SQL period 23.06 - 24.01 position Back-end Engineer project 건설사업관리 플랫폼 구축/개발 자세히 보기\n건설사업관리 플랫폼 구축/개발\nRestful API 작성 다국어 처리를 위한 Oracle Function 생성 및 Query 작성 대용량 Excel Read \u0026amp; Upload 처리 개발 Spring JDBC Batch 적용 약 80% 이상의 업로드 속도 개선\n공사 관련 청구/정산 프로세스 개발 Tech Stack\nVue3 Java Oracle SQL SAX Library POI Excel Library Toogram Systems period 19.12 - 21.01 position Python Back-end Engineer project 선박 자율운항 최적항로 알고리즘 구축/개발 자세히 보기\n선박 자율운항 최적항로 알고리즘 구축/개발\n선박 데이터 전처리 및 가공 선박 운항 데이터 전처리 및 가공 선박 운항 항로 렌더링 처리 그래프 탐색 알고리즘 기반 자율운항 항로 계산 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript period 19.07 - 20.01 position Python Back-end Engineer project 선박 데이터 기반 이상탐지 알고리즘 개발 자세히 보기\n선박 데이터 기반 이상탐지 알고리즘 개발\n선박 데이터 전처리 마할라노비스 다구찌 기반 이상탐지 알고리즘 개발 선박 데이터 시각화 개발 JS 기반 데이터 차트 오픈소스 라이브러리 적용 및 테스트 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript Other Experience Blog Author, Maintainer\n21.08.28 - 현재\n비정기적으로 새롭게 배우고 공부한 내용 등을 글로 작성해 공유합니다.\n블로그는 이전에 약 1년간 사용하던 Tistory 와 현재 보고 계신 Github Pages가 있습니다.\n현재 블로그는 Hugo + github.io 를 사용해 구현했습니다. Internship 한이음 ICT 멘토링 period 18.04 - 18.11 position Intern project 생활 법령 정보제공 챗봇 서비스 개발 자세히 보기\n생활 법령 정보제공 챗봇 서비스 개발\nSoap API 를 사용해 공공데이터포털 크롤링 자연어 처리에 사용할 형태소 분석기를 시스템에 import 자연어 처리 Seq2Seq 연구 및 적용 테스트 카카오톡 챗봇 서비스 API 연결 및 테스트 Tech Stack\nPython Django Soap API MySQL Linux (Ubuntu) 씨에스리 ICT 인턴십 period 18.03 - 18.06 position Intern project 블럭코딩 데이터 분석툴(BigZami) 개발 자세히 보기\n블럭코딩 데이터 분석툴(BigZami) 개발\nNexacro Flatform 기반 컴포넌트 개발 및 연결 SpringBoot 기반 Back-end 환경 구성 R - Java 언어 연동 및 Nexacro Flatform 연동 테스트 Plotly 오픈소스 라이브러리 적용 테스트 Tech Stack\nNexacro Flatform Java Spring Boot OpenSource Library 씨에스리 ICT 인턴십 period 17.09 - 17.12 position Intern project IT 지식 제공 챗봇 개발 자세히 보기\nIT 지식 제공 챗봇 개발\nDjango 기반 개발 서버 환경구축 카카오톡 챗봇 서버와 Restful API 연동 형태소 분석기 테스트 및 사용자 전용 단어 사전 구축 자연어 처리 방법 연구 및 분석 Tech Stack\nDjango Python2 Ubuntu MySQL Rest API Skills Overall. 안정적인 서비스 및 효율적인 구현을 좋아합니다. 최신 기술보다 상황에 따라 적절한 선택을 하는 것이 최적의 결과가 나온다고 믿습니다. 업무에 따라 능숙한 분야가 아니더라도 적극적으로 탐색해 최적의 결과를 낼 수 있도록 노력합니다. Communication. 직위 및 포지션에 관계없이 적극적인 의사소통을 시도합니다. 지적 겸손함을 유지하기 위해 노력합니다. Server. 성능향상을 위한 리팩토링을 한 경험이 있습니다. Java SpringBoot 를 비롯해, Python Django 또한 지원이 가능합니다. 필요하다면 셸스크립트를 작성해 반복되는 업무를 자동화 가능합니다. Python. Python3 환경에 익숙하고 능숙합니다. 웹프레임워크를 필요에 따라 구분해 사용할 수 있으며, 공통 로직을 적절히 모듈화해 사용합니다. Java JDBC를 능숙하게 사용하고, 속도개선을 위해 캐싱이나 배치를 적절히 활용합니다. 불필요한 API 호출을 최대한 삼가하며, 합리적인 방식으로 서비스를 분리합니다. Education Woosuk Univ. 정보보안학과\n2012.03 - 2019.02\n4.31 / 4.5\n정보보안학과에서 4년간 공부하며, 거의 모든 과목을 높은 성적으로 이수하였습니다.\n군대에 가기 전, 가고 싶은 곳에 지원하기 위한 준비를 위해 약 1년 간 휴학했습니다. certificate 정보처리기사 2018.08.17 리눅스마스터 2급 2017.06.10 ","permalink":"https://jxun-h.github.io/resume/","summary":"이력서","title":"Resume"}]