[{"content":"\n📌 BOJ 1531 투명 💡 조건 세준이는 1×1크기의 그림으로 모자이크한 100×100크기의 그림을 가지고 있다. 어느 날 이 모자이크 중 일부 그림이 너무 보기 싫어서 N개의 불투명한 종이로 그림을 가리기 시작했다. 그림의 현재 부분 위에 M개 이하의 종이가 올려져 있으면 그림은 그 부분에서 보이게 된다. N은 0보다 크거나 같고, 50보다 작거나 같다. M은 0보다 크거나 같고, 50보다 작거나 같다. 왼쪽 아래 모서리의 x, y좌표, 오른쪽 위 모서리의 x, y좌표 순으로 주어진다.\n모든 좌표는 100보다 작거나 같은 자연수이다. 시뮬레이션, 구현 🔖 예제 및 실행결과 예제 3 1 21 21 80 80 41 41 60 60 71 71 90 90 실행결과 500 ⌨️ 문제 풀이 N개의 불투명한 종이의 좌표를 받아서 x1부터 x2까지, y1부터 y2까지 순회한다. 순회하면서 해당하는 인덱스에 해당하는 배열의 값이 False라면 1로 변경한다. 순회하면서 해당하는 인덱스에 해당하는 배열의 값이 False가 아니라면 + 1 해준다. 100 * 100 크기의 좌표를 순회하면서 m 이상의 크기가 있다면 res + 1 해준다. 🖥 소스 코드 from sys import stdin board = [[False] * 101 for _ in range(101)] n, m = map(int, stdin.readline().split()) for _ in range(n): x1, y1, x2, y2 = map(int, stdin.readline().split()) for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): if board[i][j] is False: board[i][j] = 1 else: board[i][j] += 1 res = 0 for i in range(1, 101): for j in range(1, 101): if board[i][j] \u0026gt; m: res += 1 print(res) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/ps/boj-1531-%ED%88%AC%EB%AA%85-with-python/","summary":"📌 BOJ 1531 투명 💡 조건 세준이는 1×1크기의 그림으로 모자이크한 100×100크기의 그림을 가지고 있다. 어느 날 이 모자이크 중 일부 그림이 너무 보기 싫어서 N개의 불투명한 종이로 그림을 가리기 시작했다. 그림의 현재 부분 위에 M개 이하의 종이가 올려져 있으면 그림은 그 부분에서 보이게 된다. N은 0보다 크거나 같고, 50보다 작거나 같다. M은 0보다 크거나 같고, 50보다 작거나 같다. 왼쪽 아래 모서리의 x, y좌표, 오른쪽 위 모서리의 x, y좌표 순으로 주어진다.","title":"[BOJ] 1531 투명 with Python"},{"content":"\n📌 BOJ 2096 내려가기 💡 조건 N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다.\n내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다. 먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다.\n그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다.\n바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 최대 점수, 최소 점수를 구하는 프로그램을 작성하는 문제 첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.\n첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 3 1 2 3 4 5 6 4 9 0 실행결과 18 6 ⌨️ 문제 풀이 입력받은 n만큼 순회한다. 아래층으로 내려가면서 합칠 때 가장 큰 값과 작은 값을 x_temp, n_temp에 저장한다. dp에 x_temp, n_temp 내용을 저장한다. 최댓갑과 최댓값을 따로 저장할 배열을 만들고, 위치에 따라 선택할 수 있는 값을 달리하여 최댓값과 최솟값을 구하는 것이 목적이다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) x_dp = [0] * 3 n_dp = [0] * 3 x_temp = [0] * 3 n_temp = [0] * 3 for i in range(n): a, b, c = map(int, stdin.readline().split()) for j in range(3): if j == 0: x_temp[j] = a + max(x_dp[j], x_dp[j + 1]) n_temp[j] = a + min(n_dp[j], n_dp[j + 1]) elif j == 1: x_temp[j] = b + max(x_dp[j - 1], x_dp[j], x_dp[j + 1]) n_temp[j] = b + min(n_dp[j - 1], n_dp[j], n_dp[j + 1]) elif j == 2: x_temp[j] = c + max(x_dp[j], x_dp[j - 1]) n_temp[j] = c + min(n_dp[j], n_dp[j - 1]) for j in range(3): x_dp[j] = x_temp[j] n_dp[j] = n_temp[j] print(max(x_dp), min(n_dp)) 💾 느낀점 다이나믹프로그래밍 문제는 역시 점화식 때문에 골치를 많이 썩어하는 것 같다. 생각보다 문제풀이를 보고 어렵지 않았던 문제인데 왜 헤맸을까 하는 생각을 했다. 이러한 유형을 다시 풀었을 때, 잘 풀 수 있게 풀이를 써야겠다는 생각을 했다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2096-%EB%82%B4%EB%A0%A4%EA%B0%80%EA%B8%B0-with-python/","summary":"📌 BOJ 2096 내려가기 💡 조건 N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다.\n내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다. 먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다.\n그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다.\n바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다.","title":"[BOJ] 2096 내려가기 with Python"},{"content":"\n📌 BOJ 1269 대칭 차집합 💡 조건 자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다. 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,\nA-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로,\n대칭 차집합의 원소의 개수는 1 + 3 = 4개이다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다. 대칭 차집합의 원소의 개수를 출력하는 문제 해시맵, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 3 5 1 2 4 2 3 4 5 6 실행결과 4 ⌨️ 문제 풀이 집합 A의 원소의 개수와 집합 B의 원소의 개수를 입력 받는다. 각 집합의 원소를 set()으로 입력받아 저장한다. (a - b) 의 길이와 (b - a)의 길이를 더한 뒤 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) a = set(map(int, stdin.readline().split())) b = set(map(int, stdin.readline().split())) print(len(a - b) + len(b - a)) 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/ps/boj-1269-%EB%8C%80%EC%B9%AD-%EC%B0%A8%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 1269 대칭 차집합 💡 조건 자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다. 예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때,\nA-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로,\n대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.","title":"[BOJ] 1269 대칭 차집합 with Python"},{"content":"\n📌 BOJ 12760 최후의 승자는 누구? 💡 조건 최종 플레이어 N명이 남아있다. 각 플레이어는 M장씩의 숫자가 적힌 카드를 가지고 있으며,\n이들은 매 턴 자신이 가진 카드 중 가장 큰 카드를 두고 비교를 하는데, 그 카드들 중 가장 큰 수를 가진 플레이어가 1점을 획득한다. 그 턴에 사용된 카드는 버리기로 한다. (가장 큰 수를 가진 플레이어는 여러 명일 수 있다.) 3. M번의 경기 후 가장 많은 점수를 획득한 플레이어는 몇 번 플레이어인지 구하는 문제.\n2 \u0026lt;= N \u0026lt;= 100, 1 \u0026lt;= M \u0026lt;= 100\n1 \u0026lt;= 카드에 적힌 숫자 \u0026lt;= 100 가장 많은 점수를 획득한 플레이어가 여러 명일 경우, 빈칸을 사이에 두고 플레이어들의 번호를 오름차순으로 출력한다. 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 3 5 4 3 3 4 5 3 5 4 4 5 3 3 4 4 실행결과 1 2 3 4 ⌨️ 문제 풀이 d 변수는 dictionary 이며, 각 플레이어의 점수를 저장할 변수이다. N 명의 플레이어가 각자 들고 있는 카드의 숫자들이 입력될 때, 그 숫자들을 내림차순으로 정렬하여 players에 넣어준다. 각 플레이어의 카드를 순회하면서 가장 큰 카드 값을 저장한다. 각 플레이어의 카드를 순회하면서 mx[j] 가 i 번 플레이어의[j]번째 카드와 값이 같다면, d[i + 1] 에 + 1을 해준다. d 에 저장된 값 중, 가장 큰 값을 골라낸 뒤, mx_cnt 에 저장한다. d를 순회하면서 mx_cnt 와 같은 값을 가진 키를 res에 저장해준다.\nres를 출력할 땐, 오름차순 정렬을 한 번 수행해준 뒤 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) d = {x: 0 for x in range(1, n + 1)} players = [] for i in range(n): cards = list(map(int, stdin.readline().split())) cards.sort() players.append(list(reversed(cards))) mx = [0 for _ in range(m)] for i in range(n): for j in range(m): mx[j] = max(mx[j], players[i][j]) for i in range(n): for j in range(m): if mx[j] == players[i][j]: d[i + 1] += 1 mx_cnt = max(d.values()) res = [] for key, item in d.items(): if item == mx_cnt: res.append(key) res.sort() print(*res) 💾 느낀점 간단하게 풀 수 있었던 정렬 문제였습니다. 카드의 숫자를 큰 순서대로 보아야하는 것을 떠올리지 못해 조금 헤맸습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-12760-%EC%B5%9C%ED%9B%84%EC%9D%98-%EC%8A%B9%EC%9E%90%EB%8A%94-%EB%88%84%EA%B5%AC-with-python/","summary":"📌 BOJ 12760 최후의 승자는 누구? 💡 조건 최종 플레이어 N명이 남아있다. 각 플레이어는 M장씩의 숫자가 적힌 카드를 가지고 있으며,\n이들은 매 턴 자신이 가진 카드 중 가장 큰 카드를 두고 비교를 하는데, 그 카드들 중 가장 큰 수를 가진 플레이어가 1점을 획득한다. 그 턴에 사용된 카드는 버리기로 한다. (가장 큰 수를 가진 플레이어는 여러 명일 수 있다.) 3. M번의 경기 후 가장 많은 점수를 획득한 플레이어는 몇 번 플레이어인지 구하는 문제.","title":"[BOJ] 12760 최후의 승자는 누구? with Python"},{"content":"\n📌 BOJ 10163 색종이 💡 조건 평면에 색깔이 서로 다른 직사각형 모양의 색종이 N장이 하나씩 차례로 놓여진다. 이때 색종이가 비스듬하게 놓이는 경우는 없다. 색종이의 장수를 나타내는 정수 N (1 ≤ N ≤ 100) N장의 색종이가 주어진 위치에 차례로 놓일 경우, 각 색종이가 보이는 부분의 면적을 구하는 문제 가로 최대 1001칸, 세로 최대 1001칸으로 구성된 격자 모양이다.\n격자의 각 칸은 가로, 세로 길이가 1인 면적이 1인 정사각형 색종이가 놓인 상태는 가장 왼쪽 아래 칸의 번호와 너비, 높이를 나타내는 네 정수로 표현한다.\n예를 들어, 위 그림에서 회색으로 표시된 색종이는 (1,4)가 가장 왼쪽 아래에 있고 너비 3, 높이 2이므로 1 4 3 2로 표현한다.\n색종이가 격자 경계 밖으로 나가는 경우는 없다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 4 0 2 10 10 7 9 8 4 8 4 10 6 6 0 12 10 실행결과 62 24 0 120 ⌨️ 문제 풀이 색종이의 정보를 입력받아서 가장 왼쪽 아래칸에서부터 놓는다. (1)번의 작업을 반복문을 통해서 board 에 채워넣는데, 이때 k의 값은 색종이의 번호를 뜻한다. 색종이가 놓인 부분에서 가장 작은 좌표의 값과 가장 큰 좌표의 값을 계산하여 변수를 갱신한다. 모든 입력을 받았다면, k를 순회하면서 각 색종이의 면적을 구해준다. 각 번호에 알맞은 색종이의 면적은 res 변수에 k 번째에 더해지고, res를 순회하면서 출력하면 된다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) board = [[-1] * 1001 for _ in range(1001)] res = [0 for _ in range(n)] minx, miny = 1001, 1001 maxx, maxy = 0, 0 for k in range(n): x, y, width, height = map(int, stdin.readline().split()) for i in range(x, x + width): for j in range(y, y + height): board[i][j] = k minx, miny = min(x, minx), min(y, miny) maxx, maxy = max(x + width, maxx), max(y + height, maxy) for k in range(n): for i in range(minx, maxx): for j in range(miny, maxy): if board[i][j] == k: res[k] += 1 for i in res: print(i) 💾 느낀점 pypy로 제출하여 풀었던 문제이다. 서브태스크가 있는 문제라서 문제를 풀이할 때, 몇 번 틀리기도 했다. 이 때, 구현이 참 힘들고 어려웠었는데, 성장했음을 느꼈다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-10163-%EC%83%89%EC%A2%85%EC%9D%B4-with-python/","summary":"📌 BOJ 10163 색종이 💡 조건 평면에 색깔이 서로 다른 직사각형 모양의 색종이 N장이 하나씩 차례로 놓여진다. 이때 색종이가 비스듬하게 놓이는 경우는 없다. 색종이의 장수를 나타내는 정수 N (1 ≤ N ≤ 100) N장의 색종이가 주어진 위치에 차례로 놓일 경우, 각 색종이가 보이는 부분의 면적을 구하는 문제 가로 최대 1001칸, 세로 최대 1001칸으로 구성된 격자 모양이다.\n격자의 각 칸은 가로, 세로 길이가 1인 면적이 1인 정사각형 색종이가 놓인 상태는 가장 왼쪽 아래 칸의 번호와 너비, 높이를 나타내는 네 정수로 표현한다.","title":"[BOJ] 10163 색종이 with Python"},{"content":"\n📌 BOJ 12018 Yonsei TOTO 💡 조건 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다.\n그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다.\n(내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다. 과목 수 n (1 ≤ n ≤ 100)\n마일리지 m (1 ≤ m ≤ 100)\n각 과목마다 2줄의 입력이 주어지는데 첫째 줄에는 각 과목에 신청한 사람 수 Pi과 과목의 수강인원 Li\n그 다음 줄에는 각 사람이 마일리지를 얼마나 넣었는지 주어진다. 정렬 유형의 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) res = 0 c = [] for i in range(n): p, l = map(int, stdin.readline().split()) point = list(map(int, stdin.readline().split())) point.sort(reverse=True) if p \u0026lt; l: c.append(1) else: mile = point[l - 1] c.append(mile) c.sort() for class_m in c: if m - class_m \u0026gt;= 0: res += 1 m -= class_m print(res) 🔖 예제 및 실행결과 예제 5 76 5 4 36 25 1 36 36 4 4 30 24 25 20 6 4 36 36 36 36 36 36 2 4 3 7 5 4 27 15 26 8 14 실행결과 4 ⌨️ 문제 풀이 과목에 신청한 인원 수보다 수강 인원이 높다면, 마일리지를 크게 투자하지 않아도 된다.\n반대로 신청한 인원 수가 수강 인원보다 높다면, 성준이가 우선순위를 가지기 때문에\n(수강인원) 번째 신청한 사람만큼만 신청하면 수강할 수 있다.\n신청한 마일리지는 내림차순으로 정렬해서 계산한다. if p \u0026lt; l: c.append(1) else: mile = point[l - 1] c.append(mile) c를 정렬하고 성준이가 가지고 있는 마일리지에서 신청할 때 필요한 마일리지를 빼주며, 음수가 되지 않으면 res 에 1을 추가한다 💾 느낀점 그리디가 묻은 정렬을 이용한 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-12018-yonsei-toto-with-python/","summary":"📌 BOJ 12018 Yonsei TOTO 💡 조건 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다.\n그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다.\n(내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다. 과목 수 n (1 ≤ n ≤ 100)\n마일리지 m (1 ≤ m ≤ 100)","title":"[BOJ] 12018 Yonsei TOTO with Python"},{"content":"\n📌 BOJ 4811 알약 💡 조건 70세 박종수 할아버지는 매일 매일 약 반알을 먹는다.\n손녀 선영이는 종수 할아버지에게 약이 N개 담긴 병을 선물로 주었다. 다음 날부터 종수는 병에서 약을 하나 꺼낸다.\n(약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고,\n아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다. 종수는 손녀에게 한 조각을 꺼낸 날에는 W를, 반 조각을 꺼낸 날에는 H 보낸다. 손녀는 할아버지에게 받은 문자를 종이에 기록해 놓는다. 총 2N일이 지나면 길이가 2N인 문자열이 만들어지게 된다. 이때, 가능한 서로 다른 문자열의 개수는 총 몇 개일까? 입력은 최대 1000개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스는 한 줄이며, 병에 들어있는 약의 개수 N ≤ 30 가 주어진다.\n입력의 마지막 줄에는 0이 하나 주어진다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 6 1 4 2 3 30 0 실행결과 132 1 14 2 5 3814986502092304 ⌨️ 문제 풀이 알약을 먹지 않으면 절대로 반개짜리는 존재할 수도 없다. 온전한 알약을 먹으면 반쪽짜리 알약이 생긴다.\n이 경우, 반쪽짜리 알약을 먹을 수 있는 경우의 수가 하나 더 늘어난다. h/w 0 1 2 3 4\n0 0 1 1 1 1\n1 1 2 3 4\n2 2 5 9\n3 5 14\n4 14 🖥 소스 코드 from sys import stdin arr = [[0] * 31 for _ in range(31)] arr[0][1] = 1 for i in range(31): for j in range(i, 31): if i == 0: arr[i][j] = 1 else: if i == j: arr[i][j] = arr[i-1][j] else: arr[i][j] = arr[i-1][j] + arr[i][j-1] while 1: n = int(stdin.readline()) if n == 0: break print(arr[n][n]) 💾 느낀점 다이나믹프로그래밍을 너무 못한다. 문제를 이해하고, 이해한 내용을 바탕으로 풀이를 유도하는 것이 아예 되지를 않는다. DP 문제같다고 생각이 되면 천천히 그려가면서 생각을 해보자. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4811-%EC%95%8C%EC%95%BD-with-python/","summary":"📌 BOJ 4811 알약 💡 조건 70세 박종수 할아버지는 매일 매일 약 반알을 먹는다.\n손녀 선영이는 종수 할아버지에게 약이 N개 담긴 병을 선물로 주었다. 다음 날부터 종수는 병에서 약을 하나 꺼낸다.\n(약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고,\n아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다. 종수는 손녀에게 한 조각을 꺼낸 날에는 W를, 반 조각을 꺼낸 날에는 H 보낸다.","title":"[BOJ] 4811 알약 with Python"},{"content":"\n📌 BOJ 9081 단어 맞추기 💡 조건 단어를 주면 그 단어를 이루는 알파벳들로 만들 수 있는 단어들을 사전 순으로 정렬할 때에\n주어진 단어 다음에 나오는 단어를 찾는 프로그램을 작성하는 문제 케이스의 개수 T (1 ≤ T ≤ 10) 단어는 알파벳 A~Z 대문자로만 이루어지며 항상 공백이 없는 연속된 알파벳으로 이루어진다.\n단어의 길이는 100을 넘지 않는다. 구현 유형의 문제 🖥 소스 코드 from sys import stdin for t in range(int(stdin.readline())): string = list(stdin.readline().rstrip()) length = len(string) i, j = 0, 1 for idx in range(1, length): if string[idx] \u0026gt; string[idx - 1]: if i \u0026lt; idx: i = idx for idx in range(1, length): if string[idx] \u0026gt; string[i - 1]: if j \u0026lt; idx: j = idx if i != 0 and j != 0: string[i-1], string[j] = string[j], string[i-1] string[i:] = list(reversed(string[i:])) print(\u0026#39;\u0026#39;.join(string)) 🔖 예제 및 실행결과 예제 4 HELLO DRINK SHUTTLE ZOO 실행결과 HELOL DRKIN SLEHTTU ZOO ⌨️ 문제 풀이 s[i-1] \u0026lt; s[i] 를 만족하는 최대 i(s의 value) 찾는다. j \u0026gt;= 1, s[i-1] \u0026lt; s[j] 를 만족하는 최대 j(index) 찾는다. s[i-1] 과 s[j] 를 바꿔준 뒤, s[i:]의 데이터를 뒤집어 준다. 💾 느낀점 문제를 풀기 위해서 다음에 오는 문자를 구하기 위한 공식이 따로 있었습니다. cpp 에서는 next_permutation 을 사용해서 풀면 된다고 했던 것 같은데, 파이썬은 그게 없다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9081-%EB%8B%A8%EC%96%B4-%EB%A7%9E%EC%B6%94%EA%B8%B0-with-python/","summary":"📌 BOJ 9081 단어 맞추기 💡 조건 단어를 주면 그 단어를 이루는 알파벳들로 만들 수 있는 단어들을 사전 순으로 정렬할 때에\n주어진 단어 다음에 나오는 단어를 찾는 프로그램을 작성하는 문제 케이스의 개수 T (1 ≤ T ≤ 10) 단어는 알파벳 A~Z 대문자로만 이루어지며 항상 공백이 없는 연속된 알파벳으로 이루어진다.\n단어의 길이는 100을 넘지 않는다. 구현 유형의 문제 🖥 소스 코드 from sys import stdin for t in range(int(stdin.readline())): string = list(stdin.","title":"[BOJ] 9081 단어 맞추기 with Python"},{"content":"\n📌 BOJ 1660 캡틴 이다솜 💡 조건 N은 300,000보다 작거나 같은 자연수이다. 사면체를 만드는 방법은 길이가 N인 정삼각형 모양을 만든다.\n그 위에 길이가 N-1인 정삼각형 모양을 얹고 그위에 계속 해서 얹어서 1크기의 정삼각형 모양을 얹으면 된다. N개의 대포알로 만들 수 있는 사면체의 최소 개수를 출력하는 프로그램을 작성하는 문제 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 15 실행결과 3 ⌨️ 문제 풀이 대포알의 개수는 1, 4, 10, 20 \u0026hellip; 순으로 늘어난다. n이 30만이기 때문에 모두 한번에 다 구해놓기에는 힘들기 떄문에,\nn보다 같거나 많은 양의 대포가 쌓여있는 사면체가 처음 등장할때까지 구해야한다. N 이 15라면 1, 4, 10 으로 만들 수 있다.\n15는 14에서 1을 더해 만들 수 있다. 10에서 4를 더하고, 5에서 10을 더해서 만들 수 있다. dp10384 팬그램[i10384 팬그램] = min(dp10384 팬그램[i10384 팬그램], 1 + dp10384 팬그램[i - num10384 팬그램])\n라는 점화식을 세울 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] num = 0 i = 1 while n \u0026gt; num: num += (i * (i + 1)) // 2 arr.append(num) i += 1 dp = [int(1e9) for i in range(n + 1)] for i in range(1, n + 1): for num in arr: if num == i: dp[i] = 1 break elif num \u0026gt; i: break dp[i] = min(dp[i], 1 + dp[i - num]) print(dp[n]) 💾 느낀점 다이나믹\u0026hellip; 프로그래밍\u0026hellip; ","permalink":"https://jxun-h.github.io/posts/ps/boj-1660-%EC%BA%A1%ED%8B%B4-%EC%9D%B4%EB%8B%A4%EC%86%9C-with-python/","summary":"📌 BOJ 1660 캡틴 이다솜 💡 조건 N은 300,000보다 작거나 같은 자연수이다. 사면체를 만드는 방법은 길이가 N인 정삼각형 모양을 만든다.\n그 위에 길이가 N-1인 정삼각형 모양을 얹고 그위에 계속 해서 얹어서 1크기의 정삼각형 모양을 얹으면 된다. N개의 대포알로 만들 수 있는 사면체의 최소 개수를 출력하는 프로그램을 작성하는 문제 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 15 실행결과 3 ⌨️ 문제 풀이 대포알의 개수는 1, 4, 10, 20 \u0026hellip; 순으로 늘어난다.","title":"[BOJ] 1660 캡틴 이다솜 with Python"},{"content":"\n📌 BOJ 1755 숫자놀이 💡 조건 79를 영어로 읽되 숫자 단위로 하나씩 읽는다면 \u0026ldquo;seven nine\u0026quot;이 된다. 80은 마찬가지로 \u0026ldquo;eight zero\u0026quot;라고 읽는다. 79는 80보다 작지만, 영어로 숫자 하나씩 읽는다면 \u0026ldquo;eight zero\u0026quot;가 \u0026ldquo;seven nine\u0026quot;보다 사전순으로 먼저 온다. 문제는 정수 M, N(1 ≤ M ≤ N ≤ 99)이 주어지면 M 이상 N 이하의 정수를 숫자 하나씩 읽었을 때를 기준으로 사전순으로 정렬하여 출력하는 것. M 이상 N 이하의 정수를 문제 조건에 맞게 정렬하여 한 줄에 10개씩 출력한다. 정렬 유형의 문제 🔖 예제 및 실행결과 예제 8 28 실행결과 8 9 18 15 14 19 11 17 16 13 12 10 28 25 24 21 27 26 23 22 20 ⌨️ 문제 풀이 dict 형 변수 d 에 각 숫자마다의 영어 문자열을 저장한다. n부터 m + 1 까지 순회(i)하면서 i를 문자열로 변환했을 때 길이만큼 또 순회(j)한다. s 배열에 data[j]를 영어 문자열로 변환 후 넣어준다. j 순회가 끝나면 s 리스트에 i를 문자열로 변환한 값을 추가해준다. 그 후, temp 배열에 s를 튜플로 만들어 추가한다. temp를 정렬하고, 정렬된 숫자값을 10개씩 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] num = 0 i = 1 while n \u0026gt; num: num += (i * (i + 1)) // 2 arr.append(num) i += 1 dp = [int(1e9) for i in range(n + 1)] for i in range(1, n + 1): for num in arr: if num == i: dp[i] = 1 break elif num \u0026gt; i: break dp[i] = min(dp[i], 1 + dp[i - num]) print(dp[n]) 💾 느낀점 그다지 어려운 문제가 아니었는데, 복잡하게 생각해서 힘들었던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1755-%EC%88%AB%EC%9E%90%EB%86%80%EC%9D%B4-with-python/","summary":"📌 BOJ 1755 숫자놀이 💡 조건 79를 영어로 읽되 숫자 단위로 하나씩 읽는다면 \u0026ldquo;seven nine\u0026quot;이 된다. 80은 마찬가지로 \u0026ldquo;eight zero\u0026quot;라고 읽는다. 79는 80보다 작지만, 영어로 숫자 하나씩 읽는다면 \u0026ldquo;eight zero\u0026quot;가 \u0026ldquo;seven nine\u0026quot;보다 사전순으로 먼저 온다. 문제는 정수 M, N(1 ≤ M ≤ N ≤ 99)이 주어지면 M 이상 N 이하의 정수를 숫자 하나씩 읽었을 때를 기준으로 사전순으로 정렬하여 출력하는 것. M 이상 N 이하의 정수를 문제 조건에 맞게 정렬하여 한 줄에 10개씩 출력한다.","title":"[BOJ] 1755 숫자놀이 with Python"},{"content":"\n📌 BOJ 1788 피보나치수의 확장 💡 조건 피보나치 수 F(n)을 n이 음수인 경우로도 확장시킬 수 있다. F(n) = F(n-1) + F(n-2)를 n ≤ 1일 때도 성립되도록 정의하는 것이다. n = 1일 때 F(1) = F(0) + F(-1)이 성립되어야 하므로, F(-1)은 1이 되어야 한다. n이 주어졌을 때, 피보나치 수 F(n)을 구하는 프로그램을 작성하는 프로그램.\nn은 음수로 주어질 수도 있다. n은 절댓값이 1,000,000을 넘지 않는 정수이다.\n첫째 줄에 F(n)이 양수이면 1, 0이면 0, 음수이면 -1을 출력한다.\n둘째 줄에는 F(n)의 절댓값을 출력한다.\n이 수가 충분히 커질 수 있으므로, 절댓값을 1,000,000,000으로 나눈 나머지를 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 10 실행결과 1 55 ⌨️ 문제 풀이 피보나치 값을 저장할 fibo 리스트 크기를 150만 개로 만들어준다.\n리스트의 첫번째 값과 두번째 값을 0 과 1로 저장한다. n 이 0보다 작은 경우, -1부터 n까지 -1씩 줄여가면서 순회한다.\nfibo[i + 2] - fibo[i + 1] 의 점화식을 통한 값이 0 보다 작을 경우\nfibo[i]의 값은 fibo[i + 2] - fibo[i + 1] 를 절대값 처리해 준 후, 1000000000로 나누고 다시 음수로 만들어준다. fibo[n] \u0026lt; 0 일 경우, -1 을 출력하고, fibo[n]를 음수로 변환하여 출력한다. fibo[n] \u0026gt;= 0 일 경우, 1 을 출력하고, fibo[n]을 출력한다. n \u0026gt; 0 경우, 일반 피보나치처럼 수를 구한다. n = 0 경우, 0을 출력한다. 🖥 소스 코드 from sys import stdin fibo = [0 for _ in range(1500000)] n = int(stdin.readline()) fibo[0:1] = [0, 1] if n \u0026lt; 0: for i in range(-1, n - 1, -1): data = fibo[i+2] - fibo[i+1] if data \u0026lt; 0: fibo[i] = (abs(data) % 1000000000) * -1 else: fibo[i] = data % 1000000000 if fibo[n] \u0026lt; 0: print(-1) print(fibo[n] * -1) else: print(1) print(fibo[n]) elif n \u0026gt; 0: for i in range(2, n + 1): fibo[i] = (fibo[i - 1] + fibo[i - 2]) % 1000000000 print(1) print(fibo[n]) else: print(0) print(0) 💾 느낀점 음수로 피보나치를 확장하는 것이 생각보다 조금 까다로운 느낌이 있었습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1788-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EC%88%98%EC%9D%98-%ED%99%95%EC%9E%A5-with-python/","summary":"📌 BOJ 1788 피보나치수의 확장 💡 조건 피보나치 수 F(n)을 n이 음수인 경우로도 확장시킬 수 있다. F(n) = F(n-1) + F(n-2)를 n ≤ 1일 때도 성립되도록 정의하는 것이다. n = 1일 때 F(1) = F(0) + F(-1)이 성립되어야 하므로, F(-1)은 1이 되어야 한다. n이 주어졌을 때, 피보나치 수 F(n)을 구하는 프로그램을 작성하는 프로그램.\nn은 음수로 주어질 수도 있다. n은 절댓값이 1,000,000을 넘지 않는 정수이다.\n첫째 줄에 F(n)이 양수이면 1, 0이면 0, 음수이면 -1을 출력한다.","title":"[BOJ] 1788 피보나치수의 확장 with Python"},{"content":"\n📌 BOJ 1822 차집합 💡 조건 집합 A에는 속하면서 집합 B에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하는 문제. 집합 A의 원소의 개수 n(A)와 집합 B의 원소의 개수 n(B)가 빈 칸을 사이에 두고 주어진다. (1 ≤ n(A), n(B) ≤ 500,000)이 주어진다. 둘째 줄에는 집합 A의 원소가, 셋째 줄에는 집합 B의 원소가 빈 칸을 사이에 두고 주어진다. 하나의 집합의 원소는 2,147,483,647 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다르다. 지료구조 유형의 문제 🔖 예제 및 실행결과 예제 4 3 2 5 11 7 9 7 4 실행결과 3 2 5 11 ⌨️ 문제 풀이 각 집합의 원소의 개수를 입력받는다. 각 집합을 입력받되, set() 자료구조에 입력을 받는다. a 집합 자료형에서 b 집합 자료형을 빼준 결과값을 res에 저장한다. res가 빈 값이라면, 0을 출력한다. res가 비어있지 않다면, res의 길이와 정렬된 res를 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) a = set(map(int, stdin.readline().split())) b = set(map(int, stdin.readline().split())) res = a-b if res: print(len(res)) print(*sorted(list(res))) else: print(0) 💾 느낀점 해시맵 자료구조를 사용한 간단한 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1822-%EC%B0%A8%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 1822 차집합 💡 조건 집합 A에는 속하면서 집합 B에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하는 문제. 집합 A의 원소의 개수 n(A)와 집합 B의 원소의 개수 n(B)가 빈 칸을 사이에 두고 주어진다. (1 ≤ n(A), n(B) ≤ 500,000)이 주어진다. 둘째 줄에는 집합 A의 원소가, 셋째 줄에는 집합 B의 원소가 빈 칸을 사이에 두고 주어진다. 하나의 집합의 원소는 2,147,483,647 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다르다. 지료구조 유형의 문제 🔖 예제 및 실행결과 예제 4 3 2 5 11 7 9 7 4 실행결과 3 2 5 11 ⌨️ 문제 풀이 각 집합의 원소의 개수를 입력받는다.","title":"[BOJ] 1822 차집합 with Python"},{"content":"\n📌 BOJ 15965 K번째 소수 💡 조건 서브태스크가 존재한다. 2 이상의 자연수 N이 1과 N을 제외하고 어떤 자연수로도 나누어 떨어지지 않을 때 소수라고 한다. 자연수 K가 주어진다.(1 ≤ K ≤ 500,000) k번째 소수를 구하는 문제 수학, 에라토스테네스의 체 유형의 문제 🔖 예제 및 실행결과 예제 3 실행결과 5 ⌨️ 문제 풀이 에라토스테네스의 체를 사용하여 풀이를 하면 됩니다. i 가 소수일 때, i의 배수는 소수가 아니다 라는 아이디어에서 시작을 합니다. i가 소수로 판별이 되었다면, 10^7 까지 검사를 하면서 i의 배수는 모두 array 배열에서 0으로 체크합니다. 소수로 판별된 i는 answer에 추가해줍니다. 🖥 소스 코드 BIG_NUM = 10**7 k = int(input()) array = [1 for _ in range(BIG_NUM + 1)] answer = [] for i in range(2, BIG_NUM + 1): if array[i]: answer.append(i) for j in range(i+i, BIG_NUM + 1, i): array[j] = 0 print(answer[k - 1]) 💾 느낀점 에라토스테네스의 체가 익숙하지 않은 상태에서 풀었었던 문제였다. 지금은 문제를 슥 읽으니 바로 풀이가 생각이 났다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15965-k%EB%B2%88%EC%A7%B8-%EC%86%8C%EC%88%98-with-python/","summary":"📌 BOJ 15965 K번째 소수 💡 조건 서브태스크가 존재한다. 2 이상의 자연수 N이 1과 N을 제외하고 어떤 자연수로도 나누어 떨어지지 않을 때 소수라고 한다. 자연수 K가 주어진다.(1 ≤ K ≤ 500,000) k번째 소수를 구하는 문제 수학, 에라토스테네스의 체 유형의 문제 🔖 예제 및 실행결과 예제 3 실행결과 5 ⌨️ 문제 풀이 에라토스테네스의 체를 사용하여 풀이를 하면 됩니다. i 가 소수일 때, i의 배수는 소수가 아니다 라는 아이디어에서 시작을 합니다. i가 소수로 판별이 되었다면, 10^7 까지 검사를 하면서 i의 배수는 모두 array 배열에서 0으로 체크합니다.","title":"[BOJ] 15965 K번째 소수 with Python"},{"content":"\n📌 BOJ 16935 배열 돌리기 3 💡 조건 크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다.\n1번 연산은 배열을 상하 반전시키는 연산이다.\n2번 연산은 배열을 좌우 반전시키는 연산이다.\n3번 연산은 오른쪽으로 90도 회전시키는 연산이다.\n4번 연산은 왼쪽으로 90도 회전시키는 연산이다.\n5, 6번은 문제 참고 첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.\n2 ≤ N, M ≤ 100, N, M은 짝수\n1 ≤ R ≤ 1,000 둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.\n1 ≤ Aij ≤ 108 연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 6 8 6 3 2 6 3 1 2 9 7 9 7 8 2 1 4 5 3 5 9 2 1 9 6 1 8 2 1 3 8 6 3 9 2 1 3 2 8 7 9 2 1 4 5 1 9 8 2 1 3 1 2 3 4 5 6 실행결과 3 1 2 8 9 1 5 4 1 2 9 7 8 2 3 1 2 9 3 6 8 3 1 2 8 1 6 9 1 2 9 5 3 5 4 1 2 8 7 9 7 9 2 1 3 6 2 3 ⌨️ 문제 풀이 말 그대로 구현을 하는 문제였다. 🖥 소스 코드 from sys import stdin n, m, r = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) command = list(map(int, list(stdin.readline().split()))) for i in range(r): if command[i] == 1: length = len(board) for j in range(length // 2): board[j], board[length - 1 - j] = board[length - 1 - j], board[j] elif command[i] == 2: for i in range(len(board)): board[i] = list(reversed(board[i])) elif command[i] == 3: if len(board) == n: new_board = [[0] * n for _ in range(m)] for j in range(m): for k in range(n): new_board[j][n - 1 - k] = board[k][j] else: new_board = [[0] * m for _ in range(n)] for j in range(n): for k in range(m): new_board[j][m - 1 - k] = board[k][j] board = new_board elif command[i] == 4: if len(board) == n: new_board = [[0] * n for _ in range(m)] for j in range(m - 1, -1, -1): for k in range(n - 1, -1, -1): new_board[(m - 1) - j][k] = board[k][j] else: new_board = [[0] * m for _ in range(n)] for j in range(n - 1, -1, -1): for k in range(m - 1, -1, -1): new_board[(n - 1) - j][k] = board[k][j] board = new_board elif command[i] == 5: r, c = len(board), len(board[0]) new_board = [[0] * c for _ in range(r)] arr1 = [item[:c // 2] for item in board[:r // 2]] arr2 = [item[c // 2:] for item in board[:r // 2]] arr3 = [item[c // 2:] for item in board[r // 2:]] arr4 = [item[:c // 2] for item in board[r // 2:]] for j in range(r // 2): new_board[j] = arr4[j] + arr1[j] for j in range(r // 2, r): new_board[j] = arr3[j - r // 2] + arr2[j - r // 2] board = new_board elif command[i] == 6: r, c = len(board), len(board[0]) new_board = [[0] * c for _ in range(r)] arr1 = [item[:c // 2] for item in board[:r // 2]] arr2 = [item[c // 2:] for item in board[:r // 2]] arr3 = [item[c // 2:] for item in board[r // 2:]] arr4 = [item[:c // 2] for item in board[r // 2:]] for j in range(r // 2): new_board[j] = arr2[j] + arr3[j] for j in range(r // 2, r): new_board[j] = arr1[j - r // 2] + arr4[j - r // 2] board = new_board for arr in board: print(*arr) 💾 느낀점 배열을 돌리는게 꽤 까다롭긴한데, 천천히 그림을 그리며 정리해서 풀었습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-16935-%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0-3-with-python/","summary":"📌 BOJ 16935 배열 돌리기 3 💡 조건 크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다.\n1번 연산은 배열을 상하 반전시키는 연산이다.\n2번 연산은 배열을 좌우 반전시키는 연산이다.\n3번 연산은 오른쪽으로 90도 회전시키는 연산이다.\n4번 연산은 왼쪽으로 90도 회전시키는 연산이다.\n5, 6번은 문제 참고 첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.\n2 ≤ N, M ≤ 100, N, M은 짝수\n1 ≤ R ≤ 1,000 둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.","title":"[BOJ] 16935 배열 돌리기 3 with Python"},{"content":"\n📌 BOJ 10384 팬그램 💡 조건 팬그램은 모든 알파벳을 적어도 한 번씩을 사용한 영어 문장을 말한다. 더블 팬그램은 모든 알파벳을 적어도 두 번씩은 사용한 문장을 말하고, 트리플 팬그램은 모든 알파벳을 적어도 세 번씩은 사용한 문장을 말한다. 입력은 여러 줄의 테스트케이스들로 이루어진다.\n첫째 줄에 테스트케이스의 수 n이 주어진다.\n각 테스트케이스는 영어 소문자와 대문자, 특수기호들로 이루어진다. 팬그램이 아닐 경우 - Not a pangram\n팬그램일 경우 - Pangram!\n더블 팬그램일 경우 - Double pangram!!\n트리플 팬그램일 경우 - Triple pangram!!! 구현 유형의 문제 🔖 예제 및 실행결과 예제 3 The quick brown fox jumps over a lazy dog. The quick brown fox jumps over a laconic dog. abcdefghijklmNOPQRSTUVWXYZ-zyxwvutsrqpon 2013/2014 MLKJIHGFEDCBA 실행결과 Case 1: Pangram! Case 2: Not a pangram Case 3: Double pangram!! ⌨️ 문제 풀이 테스트케이스만큼 반복문을 진행하면서, 결과값을 저장할 res 변수를 \u0026lsquo;Not a pangram\u0026rsquo;으로 초기화한다. string에 어떤 검사할 문자열을 입력받고, 알파벳을 몇번 썼는지 검사할 alphabet 이라는 2차원 배열을 만든다. string을 순회하면서 알파벳이 아닐 경우 continue, 알파벳일 경우 해당 알파벳을 True로 체크해주면된다. 최대 트리플 팬그램까지 밖에 없으니 idx 를 0부터 시작하여 2까지 늘려주고, 다시 0으로 만들어주는 작업을 통해서 알파벳이 사용되었는지 체크한다. alphabet 리스트를 순회하면서 리스트에 False가 없다면 cnt + 1, 있다면 break를 한다. cnt에 따라 결과값 res를 갱신하고 출력양식에 맞게 출력한다. 🖥 소스 코드 from sys import stdin for i in range(1, int(stdin.readline()) + 1): res = \u0026#39;Not a pangram\u0026#39; string = stdin.readline().rstrip() alphabet = [[False] * 26 for _ in range(3)] for j in string: idx = 0 if not j.isalpha(): continue else: while 1: if not alphabet[idx][ord(j.lower()) - 97]: alphabet[idx][ord(j.lower()) - 97] = True break else: idx += 1 if idx \u0026gt; 2: idx = 0 break cnt = 0 for data in alphabet: if False in data: break else: cnt += 1 if cnt == 1: res = \u0026#39;Pangram!\u0026#39; elif cnt == 2: res = \u0026#39;Double pangram!!\u0026#39; elif cnt == 3: res = \u0026#39;Triple pangram!!!\u0026#39; print(\u0026#39;Case {}: {}\u0026#39;.format(i, res)) 💾 느낀점 dict로도 풀수 있지 않을까? 라는 생각이 든다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-10384-%ED%8C%AC%EA%B7%B8%EB%9E%A8-with-python/","summary":"📌 BOJ 10384 팬그램 💡 조건 팬그램은 모든 알파벳을 적어도 한 번씩을 사용한 영어 문장을 말한다. 더블 팬그램은 모든 알파벳을 적어도 두 번씩은 사용한 문장을 말하고, 트리플 팬그램은 모든 알파벳을 적어도 세 번씩은 사용한 문장을 말한다. 입력은 여러 줄의 테스트케이스들로 이루어진다.\n첫째 줄에 테스트케이스의 수 n이 주어진다.\n각 테스트케이스는 영어 소문자와 대문자, 특수기호들로 이루어진다. 팬그램이 아닐 경우 - Not a pangram\n팬그램일 경우 - Pangram!\n더블 팬그램일 경우 - Double pangram!","title":"[BOJ] 10384 팬그램 with Python"},{"content":"\n📌 BOJ 9742 순열 💡 조건 집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하는 문제 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 235 4 bein 20 123456 700 mnpqr 130 tuvwxyz 4000 실행결과 235 4 = 352 bein 20 = nbie 123456 700 = 651342 mnpqr 130 = No permutation tuvwxyz 4000 = ywuxvzt ⌨️ 문제 풀이 입력받은 순열 집합의 길이의 제곱이 구하고자하는 순서의 숫자보다 작을 경우, No permutation 을 출력하면 됩니다. (1)번에 해당하지 않을 경우, 재귀호출을 통해 순열을 구하면 됩니다. 테스트 케이스가 여러 개이기 때문에 while 문으로 감싼 뒤, 입력받은 문자가 2개로 나누어지지 않을 경우 break 를 해주면 됩니다. 재귀호출에서 cnt 의 개수가 재귀 호출을 통해 만들어진 순열의 개수와 같아지면 그대로 문자열을 반환시키면 됩니다. 🖥 소스 코드 from sys import stdin from math import factorial def solve(string, i): global cnt if i == len(a): cnt += 1 if cnt == b: return string else: for k in a: if k not in string: res = solve(string + k, i + 1) if res: return res return while 1: cnt = 0 input_data = stdin.readline().rstrip().split() if len(input_data) != 2: break a, b = input_data b = int(b) if factorial(len(a)) \u0026lt; b: print(a, b, \u0026#39;=\u0026#39;, \u0026#39;No permutation\u0026#39;) else: print(a, b, \u0026#39;=\u0026#39;, solve(\u0026#39;\u0026#39;, 0)) 💾 느낀점 입력 받은 순열 집합의 길이의 제곱이 구하고자하는 n번째, 즉 n보다 작을 경우 DFS를 돌리지 않아도 되는 사실을 몰랐다 (1)번을 잘 몰랐기에 당연히 시간초과가 떠서 고생을 했던 문제이다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9742-%EC%88%9C%EC%97%B4-with-python/","summary":"📌 BOJ 9742 순열 💡 조건 집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하는 문제 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.","title":"[BOJ] 9742 순열 with Python"},{"content":"\n📌 BOJ 6443 애너그램 💡 조건 첫째 줄에 단어의 개수 N 이, 둘째 줄부터 N개의 영단어가 들어온다. 영단어는 소문자로 이루어져 있다. 단어의 길이는 20보다 작거나 같고, 애너그램의 수가 100,000개 이하인 단어만 입력으로 주어진다. 애너그램 프로그램이란, 입력받은 영단어의 철자들로 만들 수 있는 모든 단어를 출력하는 것이다. 입력받은 단어내에 몇몇 철자가 중복될 수 있다. 이 경우 같은 단어가 여러 번 만들어 질 수 있는데, 한 번만 출력해야 한다. 또한 출력할 때에 알파벳 순서로 출력해야 한다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 2 abc acba 실행결과 abc acb bac bca cab cba aabc aacb abac abca acab acba baac baca bcaa caab caba cbaa ⌨️# 문제 풀이 string 이라는 변수에 문자열을, 각 알파벳이 몇 개 나왔는지 개수를 저장할 alpha 라는 변수를 만든다 입력받은 문자열을 순회하면서 arr에 각 알파벳의 개수를 기록해준다. solve() 함수에 string의 길이와 빈 문자열을 매개변수로 주고 실행합니다. solve() 함수에서 alpha 배열의 값이 0보다 클 때 매개변수로 문자열에 알파벳을 붙이고 매개변수로 넣는다.\n그리고 문자열의 길이를 -1 해준다. 매개변수로 받는 문자열의 길이가 0이 되었을 때, visited 에 넣어줍니다. visited 를 리스트로 변환하고, 정렬한 뒤, 순서대로 출력한다. 🖥 소스 코드 from sys import stdin def solve(l, s): if l == 0: visited.add(s) return for i in range(26): if alpha[i] \u0026gt;= 1: alpha[i] -= 1 solve(l - 1, s + chr(i + 97)) alpha[i] += 1 for _ in range(int(stdin.readline())): visited = set() alpha = [0 for _ in range(26)] string = stdin.readline().rstrip() for i in string: alpha[ord(i)-97] += 1 solve(len(string), \u0026#39;\u0026#39;) for s in sorted(list(visited)): print(s) 💾 느낀점 골드문제치고 시간초과가 나지 않는 쉬운 문제였습니다. 재귀함수를 통해서 백트래킹으로 간단히 풀 수 있는 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-6443-%EC%95%A0%EB%84%88%EA%B7%B8%EB%9E%A8-with-python/","summary":"📌 BOJ 6443 애너그램 💡 조건 첫째 줄에 단어의 개수 N 이, 둘째 줄부터 N개의 영단어가 들어온다. 영단어는 소문자로 이루어져 있다. 단어의 길이는 20보다 작거나 같고, 애너그램의 수가 100,000개 이하인 단어만 입력으로 주어진다. 애너그램 프로그램이란, 입력받은 영단어의 철자들로 만들 수 있는 모든 단어를 출력하는 것이다. 입력받은 단어내에 몇몇 철자가 중복될 수 있다. 이 경우 같은 단어가 여러 번 만들어 질 수 있는데, 한 번만 출력해야 한다. 또한 출력할 때에 알파벳 순서로 출력해야 한다.","title":"[BOJ] 6443 애너그램 with Python"},{"content":"\n📌 BOJ 8394 악수 💡 조건 회의가 끝났고, 이제 악수를 하는 시간이다. 모든 사람은 직사각형 탁자 하나의 한 면에 앉아있다. 자리를 벗어나지 않고 악수를 하는 방법의 수를 구하는 문제 각 사람들은 자신의 왼쪽이나 오른쪽에 있는 사람들과 악수를 할 수 있다. (안 할 수도 있다) 첫째 줄에 회의에 참석한 사람의 수 n (1 ≤ n ≤ 10,000,000)이 주어진다. 수가 매우 커질 수 있기 때문에, 마지막 자리만 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 실행결과 5 ⌨️ 문제 풀이 n 이 1일 때는 악수를 안하는 경우, n이 2일 때는 악수를 안하는 경우와 둘이 악수를 하는 경우가 있다. n 이 3일 때는 세번째 사람이 악수를 안할경우, 이 때는 두명이 있을 경우와 같기 때문에 dp[i-1] 과 같다고 할 수 있다. 세번째 사람이 악수를 할 경우, 첫번째 사람이 혼자 남기 때문에 dp[n-2]와 같다고 할 수 있다. dp[n] = dp[n-2] + dp[n-1] 이는 피보나치 수열의 점화식과 같으나, 맨 마지막 숫자만 출력하면 된다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [0 for _ in range(n + 1)] arr[0], arr[1] = 1, 1 for i in range(2, n + 1): arr[i] = (arr[i-1] + arr[i - 2]) % 10 print(arr[n]) 💾 느낀점 나는 피보나치 수열의 점화식과 같은지 모르고, 전수조사를 통해서 문제를 파악하고 규칙을 찾았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-8394-%EC%95%85%EC%88%98-with-python/","summary":"📌 BOJ 8394 악수 💡 조건 회의가 끝났고, 이제 악수를 하는 시간이다. 모든 사람은 직사각형 탁자 하나의 한 면에 앉아있다. 자리를 벗어나지 않고 악수를 하는 방법의 수를 구하는 문제 각 사람들은 자신의 왼쪽이나 오른쪽에 있는 사람들과 악수를 할 수 있다. (안 할 수도 있다) 첫째 줄에 회의에 참석한 사람의 수 n (1 ≤ n ≤ 10,000,000)이 주어진다. 수가 매우 커질 수 있기 때문에, 마지막 자리만 출력한다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 실행결과 5 ⌨️ 문제 풀이 n 이 1일 때는 악수를 안하는 경우, n이 2일 때는 악수를 안하는 경우와 둘이 악수를 하는 경우가 있다.","title":"[BOJ] 8394 악수 with Python"},{"content":"\n📌 BOJ 1342 행운의 문자열 💡 조건 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다. 첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 abcdefghij 실행결과 3628800 ⌨️ 문제 풀이 브루트포스 알고리즘으로 해결하는 문제였습니다. arr 에 입력받은 문자열을 저장한 뒤, 순차적으로 순회하면서 point 배열에 점수를 부여합니다. solve() 함수는 재귀함수입니다. arr 에 있는 중복되지 않는 문자를 하니씩 넣으면서 만들 수 있는 문자열마다 cnt를 하나씩 늘려줍니다. cnt를 출력합니다. 🖥 소스 코드 from sys import stdin arr = stdin.readline().rstrip() cnt = 0 point = [0 for _ in range(26)] for i in arr: point[ord(i) - 97] += 1 def solve(goal, p): global cnt if goal == 0: cnt += 1 return for c in set(list(arr)): if point[ord(c) - 97] \u0026gt; 0 and c != p: point[ord(c) - 97] -= 1 solve(goal - 1, c) point[ord(c) - 97] += 1 solve(len(arr), \u0026#39;\u0026#39;) print(cnt) 💾 느낀점 재귀함수를 통해서 브루트포스를 구현했습니다. 파이썬에서는 pypy로 채점이 가능했습니다. 시간을 단축할 수 있는 방법을 생각해보는 것도 좋겠습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1342-%ED%96%89%EC%9A%B4%EC%9D%98-%EB%AC%B8%EC%9E%90%EC%97%B4-with-python/","summary":"📌 BOJ 1342 행운의 문자열 💡 조건 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다. 첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 abcdefghij 실행결과 3628800 ⌨️ 문제 풀이 브루트포스 알고리즘으로 해결하는 문제였습니다.","title":"[BOJ] 1342 행운의 문자열 with Python"},{"content":"\n📌 BOJ 18243 Small World Network 💡 조건 첫 번째 줄에 지구에 있는 사람의 수 N과 친구 관계의 개수 K.\n(1 ≤ N ≤ 100, 0 ≤ K ≤ N×(N-1)/2) 모든 사람은 1부터 N까지 번호가 매겨져 있다. 두 번째 줄부터 K+1번째 줄까지 친구 관계를 나타내는 A B가 한 줄에 하나씩 주어진다.\n(1 ≤ A, B ≤ N) A와 B가 친구면 B와 A도 친구다. 자기 자신과 친구인 경우는 없다.\nA와 B의 친구 관계는 중복되어 입력되지 않는다. 해당 네트워크가 작은 세상 네트워크를 만족하면\n\u0026ldquo;Small World!\u0026ldquo;를, 만족하지 않는다면 \u0026ldquo;Big World!\u0026ldquo;를 출력 BFS, 그래프 이론 유형의 문제 🔖 예제 및 실행결과 예제 10 8 1 2 2 3 3 4 4 5 6 7 7 8 8 9 9 10 실행결과 Big World! ⌨️ 문제 풀이 네트워크 상의 친구 사이는 양방향 간선이라고 볼 수 있다. 그래프로 사용할 network 라는 리스트를 만들고, 그래프에 입력한다. 1번 노드부터 bfs() 알고리즘을 수행하면서 q 에 (노드번호, dist)를 넣어 수행한다.\ndist = 0 부터 시작한다. bfs가 수행되면서 dist가 6을 초과하면, False를 반환한다. visited (방문 처리 set)의 길이가 만약 노드 총 개수 n과 같지 않다면 False 를 반환. 반환받은 bfs 의 결과값이 False라면 \u0026ldquo;Big World!\u0026rdquo;\n반환받은 bfs 의 결과값이 True라면 \u0026ldquo;Small World!\u0026rdquo; 🖥 소스 코드 from sys import stdin from collections import deque n, k = map(int, stdin.readline().split()) network = [[] for _ in range((n + 1))] tf = True for i in range(k): a, b = map(int, stdin.readline().split()) network[a].append(b) network[b].append(a) def bfs(root): visited = set() visited.add(root) q = deque() q.append((root, 0)) while q: now, dist = q.popleft() if dist \u0026gt; 6: return False for node in network[now]: if node not in visited: visited.add(node) q.append((node, dist + 1)) if len(visited) == n: return True else: return False for i in range(1, n + 1): if not bfs(i): tf = False break if tf: print(\u0026#34;Small World!\u0026#34;) else: print(\u0026#34;Big World!\u0026#34;) 💾 느낀점 BFS로는 풀이를 가능했지만, 플로이드-와샬 알고리즘에서는 실패했었다. (1)번 의 이유는 dist \u0026gt; 6 의 조건을 처리하지 못해서였다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-18243-small-world-network-with-python/","summary":"📌 BOJ 18243 Small World Network 💡 조건 첫 번째 줄에 지구에 있는 사람의 수 N과 친구 관계의 개수 K.\n(1 ≤ N ≤ 100, 0 ≤ K ≤ N×(N-1)/2) 모든 사람은 1부터 N까지 번호가 매겨져 있다. 두 번째 줄부터 K+1번째 줄까지 친구 관계를 나타내는 A B가 한 줄에 하나씩 주어진다.\n(1 ≤ A, B ≤ N) A와 B가 친구면 B와 A도 친구다. 자기 자신과 친구인 경우는 없다.\nA와 B의 친구 관계는 중복되어 입력되지 않는다.","title":"[BOJ] 18243 Small World Network with Python"},{"content":"\n📌 BOJ 1855 암호 💡 조건 먼저 암호화 할 문자열을 1,1부터 위에서 아래 순서대로 채운다. 그리고 가장 밑의 행을 채운 후에는 오른쪽 열에서 다시 같은 과정을 반복한다. 암호화 된 문자열과 몇 개의 열로 암호화를 하였는지 주어져 있을 때 원래의 문자열을 구하는 프로그램을 작성하는 문제. 열의 개수 K(1 ≤ K ≤ 20)가 주어진다.\n두 번째 줄에는 암호화 된 문자열(모두 영소문자)이 주어진다. (문자열의 길이는 200 이하이며 K의 배수이다.) 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 3 aeijfbcgklhd 실행결과 abcdefghijkl ⌨️ 문제 풀이 열의 개수와 문자열을 입력받고, 열의 개수에 맞게 문자열을 쪼개서 arr 리스트에 저장한다. arr의 행의 개수만큼 순회하면서 i를 2로 나누었을 때, 0인 경우 arr[i] 을 뒤집어 arr에 다시 저장한다. 결과값을 담을 res 변수에 arr 배열을 차례대로 순회하면서 res에 문자열을 추가해준다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) s = stdin.readline().rstrip() arr = [] for i in range(0, len(s), n): arr.append(list(s[i:i+n])) for i in range(len(arr)): if i % 2 != 0: data = list(reversed(arr[i])) arr[i] = data res = \u0026#39;\u0026#39; for j in range(n): for i in range(len(arr)): res += arr[i][j] print(res) 💾 느낀점 친절하고 재미있는 문자열 + 구현 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1855-%EC%95%94%ED%98%B8-with-python/","summary":"📌 BOJ 1855 암호 💡 조건 먼저 암호화 할 문자열을 1,1부터 위에서 아래 순서대로 채운다. 그리고 가장 밑의 행을 채운 후에는 오른쪽 열에서 다시 같은 과정을 반복한다. 암호화 된 문자열과 몇 개의 열로 암호화를 하였는지 주어져 있을 때 원래의 문자열을 구하는 프로그램을 작성하는 문제. 열의 개수 K(1 ≤ K ≤ 20)가 주어진다.\n두 번째 줄에는 암호화 된 문자열(모두 영소문자)이 주어진다. (문자열의 길이는 200 이하이며 K의 배수이다.) 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 3 aeijfbcgklhd 실행결과 abcdefghijkl ⌨️ 문제 풀이 열의 개수와 문자열을 입력받고, 열의 개수에 맞게 문자열을 쪼개서 arr 리스트에 저장한다.","title":"[BOJ] 1855 암호 with Python"},{"content":"\n📌 BOJ 2697 다음수 구하기 💡 조건 A의 다음수는 A와 구성이 같으면서, A보다 큰 수 중에서 가장 작은 수. A와 B의 구성이 같다는 말은 A를 이루고 있는 각 자리수의 등장 횟수가, B를 이루는 각 자리수의 등장 횟수와 같을 때. 첫째 줄에 테스트 케이스의 개수 T(1\u0026lt;=T\u0026lt;=1,000)가 주어진다.\n둘째 줄부터 T개 줄에는 각 테스트 케이스가 주어진다. 테스트 케이스는 한 줄로 이루어져 있으며, 수 A이다. A는 최대 80자리 자연수이다. 어떤 수 A가 주어졌을 때, A의 다음수를 구하는 프로그램을 작성하는 문제.\n만약, A의 다음수가 없을 때는 BIGGEST를 출력한다. 구현, 문자열, 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 123 279134399742 987 실행결과 132 279134423799 BIGGEST ⌨️ 문제 풀이 입력받은 숫자를 역순으로 탐색합니다. 왼쪽에 있는 값이 오른쪽보다 작아질 경우, idx에 해당 인덱스 값을 넣어줍니다. 숫자를 a 와 b 로 나누는데, 그 기준은 idx 값으로 나눌 수 있습니다. 나누어진 두 숫자 중 하나라도 비어있다면, BIGGEST 를 출력합니다. (4)번의 경우가 아니라면, b 를 오름차순으로 정렬하고, b의 길이만큼 순회합니다. 원래 입력 받았던 숫자의 idx 번째 숫자보다 b를 순회하는 중 i번째 숫자가 크다면,\ni번째 숫자를 뽑아서 a에 붙이고, 나머지 b를 그대로 이어붙여줍니다. a를 문자열로 출력합니다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): data = list(map(int, list(stdin.readline().rstrip()))) length, idx = len(data), 0 for i in range(length - 1, 0, -1): if data[i] \u0026gt; data[i - 1]: if i == length - 1: idx = length - 2 else: idx = i - 1 break a = data[:idx] b = data[idx:] if not a or not b: print(\u0026#39;BIGGEST\u0026#39;) else: b.sort() for i in range(len(b)): if b[i] \u0026gt; data[idx]: a.append(b.pop(i)) a.extend(b) break print(\u0026#39;\u0026#39;.join(map(str, a))) 💾 느낀점 문제를 한참보고도 헤맸던 문제였다. 원래 이런 규칙이 있는 것처럼 모두 풀이를 써놔서 일단 풀이를 외웠던 것으로 기억했다. 글을 쓰면서 다시 한번 풀이를 상기해보려고 했으나, 어려웠던 문제 중 하나인 것 같다. 이러한 문제를 만나면 천천히 풀이를 생각해보자. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2697-%EB%8B%A4%EC%9D%8C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 2697 다음수 구하기 💡 조건 A의 다음수는 A와 구성이 같으면서, A보다 큰 수 중에서 가장 작은 수. A와 B의 구성이 같다는 말은 A를 이루고 있는 각 자리수의 등장 횟수가, B를 이루는 각 자리수의 등장 횟수와 같을 때. 첫째 줄에 테스트 케이스의 개수 T(1\u0026lt;=T\u0026lt;=1,000)가 주어진다.\n둘째 줄부터 T개 줄에는 각 테스트 케이스가 주어진다. 테스트 케이스는 한 줄로 이루어져 있으며, 수 A이다. A는 최대 80자리 자연수이다. 어떤 수 A가 주어졌을 때, A의 다음수를 구하는 프로그램을 작성하는 문제.","title":"[BOJ] 2697 다음수 구하기 with Python"},{"content":"\n📌 BOJ 14425 문자열 집합 💡 조건 N개의 문자열로 이루어진 집합 S 입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 문제 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000) 어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다. 문자열, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 5 11 baekjoononlinejudge startlink codeplus sundaycoding codingsh baekjoon codeplus codeminus startlink starlink sundaycoding codingsh codinghs sondaycoding startrink icerink 실행결과 4 ⌨️ 문제 풀이 n개의 문자열을 dictionary 자료형 변수에 넣는다 m 개의 문자열을 입력 받으면서 만약 입력 받은 문자열이 만들어둔 dictionary 변수에 있다면\n그 키에 해당하는 value 값을 + 1 해준다. dictionary 의 values 값을 모두 더해준다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) strings = {} for _ in range(n): strings[stdin.readline().rstrip()] = 0 for i in range(m): s = stdin.readline().rstrip() if s in strings: strings[s] += 1 print(sum(strings.values())) 💾 느낀점 해시맵, dict 자료구조를 이용하는 문제인데, 문제 태그에 트라이라고 되어 있었습니다. 트라이까지 필요한지는 모르겠으나, N 과 M 의 최대 크기가 10000 이라서\ndict 안에 입력 받은 m개의 문자열이 있는지 검사시켰습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-14425-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 14425 문자열 집합 💡 조건 N개의 문자열로 이루어진 집합 S 입력으로 주어지는 M개의 문자열 중에서 집합 S에 포함되어 있는 것이 총 몇 개인지 구하는 문제 N과 M (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000) 어지는 문자열은 알파벳 소문자로만 이루어져 있으며, 길이는 500을 넘지 않는다. 집합 S에 같은 문자열이 여러 번 주어지는 경우는 없다. 문자열, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 5 11 baekjoononlinejudge startlink codeplus sundaycoding codingsh baekjoon codeplus codeminus startlink starlink sundaycoding codingsh codinghs sondaycoding startrink icerink 실행결과 4 ⌨️ 문제 풀이 n개의 문자열을 dictionary 자료형 변수에 넣는다 m 개의 문자열을 입력 받으면서 만약 입력 받은 문자열이 만들어둔 dictionary 변수에 있다면","title":"[BOJ] 14425 문자열 집합 with Python"},{"content":"\n📌 BOJ 15722 빙글빙글 스네일 💡 조건 달팽이는 원점에서 시작하여 1초에 한 칸 씩, 시계방향으로 아래 그림과 같이 움직인다. 1초일 때 달팽이의 위치는 (0, 1)이다. 몇 초가 지났는지가 입력으로 주어질 때, 현재 달팽이의 위치를 좌표로 출력하는 문제 달팽이가 움직인 시간이 n초로 주어진다. (0 ≤ n ≤ 1000, n은 0이상의 정수) 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 9 실행결과 -1 2 ⌨️ 문제 풀이 달팽이의 첫 위치를 [0, 0]으로 지정한다. cnt 가 n 과 같아질 때까지 반복을 할 것. i가 0일 때는 좌표 값을 더해주고, 1일 때는 좌표 값을 빼줄 것. 좌표를 더해주거나 빼줄 때, cnt 를 1씩 증가시키고, i 를 순회할 때마다 length를 늘려준다\n늘려준 length 는 좌표를 반복적으로 빼주고 더해줄 때 사용하는 변수 mode 는 1 일 때 0으로, 0일 때 1로 변경해주는데, x, y 를 각각 더하고 빼줄 때 사용하는 것. 함수가 반복적으로 좌표를 빼주고 더해주는 작업을 하다가, cnt가 n과 같아지면 좌표 pos 를 리턴한다. 🖥 소스 코드 from sys import stdin def solve(): n = int(stdin.readline()) pos = [0, 0] mode, length = 0, 1 cnt = 0 while 1: for i in range(2): for _ in range(2): # Add if i == 0: if mode == 0: for _ in range(length): pos[1] += 1 cnt += 1 if n == cnt: return pos else: for _ in range(length): pos[0] += 1 cnt += 1 if n == cnt: return pos # Sub if i == 1: if mode == 0: for _ in range(length): pos[1] -= 1 cnt += 1 if n == cnt: return pos else: for _ in range(length): pos[0] -= 1 cnt += 1 if n == cnt: return pos mode = 1 if mode == 0 else 0 length += 1 print(*solve()) 💾 느낀점 문제에서 설명해주는 대로 달팽이가 움직이는 방향을 잘 생각해서 구현해야 합니다. 스스로 구현 실력이 부족하다고 생각했던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15722-%EB%B9%99%EA%B8%80%EB%B9%99%EA%B8%80-%EC%8A%A4%EB%84%A4%EC%9D%BC-with-python/","summary":"📌 BOJ 15722 빙글빙글 스네일 💡 조건 달팽이는 원점에서 시작하여 1초에 한 칸 씩, 시계방향으로 아래 그림과 같이 움직인다. 1초일 때 달팽이의 위치는 (0, 1)이다. 몇 초가 지났는지가 입력으로 주어질 때, 현재 달팽이의 위치를 좌표로 출력하는 문제 달팽이가 움직인 시간이 n초로 주어진다. (0 ≤ n ≤ 1000, n은 0이상의 정수) 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 9 실행결과 -1 2 ⌨️ 문제 풀이 달팽이의 첫 위치를 [0, 0]으로 지정한다.","title":"[BOJ] 15722 빙글빙글 스네일 with Python"},{"content":"\n📌 BOJ 10546 배부른 마라토너 💡 조건 참가자 수 N이 주어진다. (1 ≤ N ≤ 105) N개의 줄에는 참가자의 이름이 주어진다. N-1개의 줄에는 완주한 참가자의 이름이 쓰여져 있다. 참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다.\n참가자들 중엔 동명이인이 있을 수도 있다. 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른 참가자 한 명은 누굴까? 해시맵 자료구조 응용 유형의 문제 🔖 예제 및 실행결과 예제 4 mislav stanko mislav ana stanko ana mislav 실행결과 mislav ⌨️ 문제 풀이 동명이인이 있다는 것이 중요합니다. {key: value} 형식으로 저장되는 데이터를 사용하는 Dictionary 자료구조를 사용합니다. n 을 입력받고, n만큼 반복문을 진행하면서 대회에 참가한 인원들을 dictionary 자료구조에 넣습니다.\n{참가자 이름 : 인원 수}, 인원 수는 dictionary 에 이름이 없을 땐 1로 초기화해서 넣습니다. n-1 만큼 반복문을 진행하면서 완주한 사람들의 이름에 해당하는 값을 dictionary에서 -1 해줍니다. dictionary.item() 을 통해서 key, value 값을 순회하면서 value 가 0보다 큰 키 값을 찾습니다. 참가자 한명을 찾는 것이기 때문에 출력한 뒤 바로 break 를 걸어 멈춰줍니다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) mara_tang = {} for _ in range(n): name = stdin.readline().rstrip() if name not in mara_tang: mara_tang[name] = 1 else: mara_tang[name] += 1 for _ in range(n - 1): mara_tang[stdin.readline().rstrip()] -= 1 for key, item in mara_tang.items(): if item != 0: print(key) break 💾 느낀점 파이썬 딕셔너리 만세 ","permalink":"https://jxun-h.github.io/posts/ps/boj-10546-%EB%B0%B0%EB%B6%80%EB%A5%B8-%EB%A7%88%EB%9D%BC%ED%86%A0%EB%84%88-with-python/","summary":"📌 BOJ 10546 배부른 마라토너 💡 조건 참가자 수 N이 주어진다. (1 ≤ N ≤ 105) N개의 줄에는 참가자의 이름이 주어진다. N-1개의 줄에는 완주한 참가자의 이름이 쓰여져 있다. 참가자들의 이름은 길이가 1보다 크거나 같고, 20보다 작거나 같은 문자열이고, 알파벳 소문자로만 이루어져 있다.\n참가자들 중엔 동명이인이 있을 수도 있다. 백준 마라톤 대회에 참가해 놓고 완주하지 못한 배부른 참가자 한 명은 누굴까? 해시맵 자료구조 응용 유형의 문제 🔖 예제 및 실행결과 예제 4 mislav stanko mislav ana stanko ana mislav 실행결과 mislav ⌨️ 문제 풀이 동명이인이 있다는 것이 중요합니다.","title":"[BOJ] 10546 배부른 마라토너 with Python"},{"content":"\n📌 BOJ 11501 주식 💡 조건 홍준이는 요즘 주식에 빠져있다. 아래 세가지 중 하나의 행동을 한다. 주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다. 테스트케이스 수를 나타내는 자연수 T. 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고,\n둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다. 최대 이익이 얼마나 되는지 계산을 해 출력하는 문제. 그리디 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 3 10 7 6 3 3 5 9 5 1 1 3 1 2 실행결과 0 10 5 ⌨️ 문제 풀이 이 문제의 키포인트는, 주식의 예측 값이 떨어질 때 주식을 모두 팔아 이익을 챙기는 것이 아닌,\n현재 가격의 주식을 언제 팔아서 최대 이익을 낼 것이냐? 입니다. 그러므로 입력을 받은 데이터를 역순회하면서, 현재 순회하고 있는 주가가 주가 최댓값보다 크다면 갱신합니다. 순회하고 있는 주가가 주가 최댓값보다 작아지면 출력할 변수(money) 에 (주가 최댓값 - 현재 순회 하고 있는 주가)를 더해줍니다. 🖥 소스 코드 from sys import stdin for tc in range(int(stdin.readline())): n = int(stdin.readline()) days = list(map(int, stdin.readline().split())) m_val, money = 0, 0 for i in range(n - 1, -1, -1): if m_val \u0026lt; days[i]: m_val = days[i] elif m_val \u0026gt; days[i]: money += (m_val - days[i]) print(money) 💾 느낀점 그리디라고 무지성으로 그냥 더했다 팔았다 하는게 아니라 역순으로도 생각해볼 수 있게 도와준 문제였습니다. 그리디도 쉽게 볼게 아니었습니다. 생각이 많이 열려있지 않다는 걸 느꼈습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-11501-%EC%A3%BC%EC%8B%9D-with-python/","summary":"📌 BOJ 11501 주식 💡 조건 홍준이는 요즘 주식에 빠져있다. 아래 세가지 중 하나의 행동을 한다. 주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다. 테스트케이스 수를 나타내는 자연수 T. 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고,\n둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다. 최대 이익이 얼마나 되는지 계산을 해 출력하는 문제.","title":"[BOJ] 11501 주식 with Python"},{"content":"\n📌 BOJ 2628 종이 자르기 💡 조건 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 칼로 잘라야하는 점선의 개수가 주어진다.\n셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다.\n가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 점선을 따라 이 종이를 칼로 자르려고 한다.\n가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다. 가장 큰 종이 조각의 넓이가 몇 ㎠인지를 구하는 프로그램 정렬 유형의 문제 🔖 예제 및 실행결과 예제 10 8 3 0 3 1 4 0 2 실행결과 30 ⌨️ 문제 풀이 가로와 세로 처음의 길이를 ga, se 리스트에 각각 넣은 후 시작한다. 가로인 경우와 세로인 경우를 나누어 각각의 리스트에 담는다. 담긴 가로, 세로 리스트를 정렬합니다. max_x, max_y 값을 정렬된 리스트의 가장 첫번째 값으로 초기화 합니다. 정렬된 가로, 세로 리스트를 순회하면서 잘린 종이의 크기가 가장 큰 값을 찾습니다.\nga[i + 1] - ga[i] 의 값이 더 크다면 갱신합니다.\nse[i + 1] - se[i] 의 값이 더 크다면 갱신합니다. ga * se 의 값을 출력합니다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) ga, se = [n], [m] for i in range(int(stdin.readline())): sep, line = map(int, stdin.readline().split()) if sep == 1: ga.append(line) else: se.append(line) ga.sort() se.sort() max_x, max_y = ga[0], se[0] for x in range(len(ga)-1): max_x = max(max_x, ga[x + 1] - ga[x]) for y in range(len(se)-1): max_y = max(max_y, se[y + 1] - se[y]) print(max_x * max_y) 💾 느낀점 잘린 종이의 크기를 어떻게 구할지 고민을 했습니다. 가로세로 리스트에 자르기 전의 종이 크기를 넣는 아이디어를 떠올리지 못했습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2628-%EC%A2%85%EC%9D%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0-with-python/","summary":"📌 BOJ 2628 종이 자르기 💡 조건 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 칼로 잘라야하는 점선의 개수가 주어진다.\n셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다.\n가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 점선을 따라 이 종이를 칼로 자르려고 한다.\n가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다.","title":"[BOJ] 2628 종이 자르기 with Python"},{"content":"\n📌 BOJ 9372 상근이의 여행 💡 조건 N개국을 여행할 상근이에게 가장 적은 비행기를 타고 여행할 수 있게 도와주자. 테스트 케이스의 수 T(T ≤ 100) 첫 번째 줄에는 국가의 수 N(2 ≤ N ≤ 1 000)과 비행기의 종류 M(1 ≤ M ≤ 10 000) 가 주어진다.\n이후 M개의 줄에 a와 b 쌍들이 입력된다. a와 b를 왕복하는 비행기가 있다는 것을 의미한다. (1 ≤ a, b ≤ n; a ≠ b)\n주어지는 비행 스케줄은 항상 연결 그래프를 이룬다. 그래프 이론, 유니온-파인드 유형의 문제 🔖 예제 및 실행결과 예제 2 3 3 1 2 2 3 1 3 5 4 2 1 2 3 4 3 4 5 실행결과 2 4 ⌨️ 문제 풀이 Union-Find 알고리즘을 사용하면 쉽게 풀 수 있습니다. parent 리스트에서 각 국은 본인의 번호를 가지고 있다.\n만약 상근이가 a국가에서 b 국가를 간다고 입력을 받았으면, a와 b 국가의 parent 를 찾고, 만약 서로 같지 않다면 같은 부모에 속하도록 변경한다. (2)번 작업을 마친 뒤, res + 1 res 를 출력한다. 🖥 소스 코드 from sys import stdin def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union_parent(a, b, parent): a = find_parent(parent, a) b = find_parent(parent, b) if a \u0026lt; b: parent[a] = b else: parent[b] = a for test_case in range(int(stdin.readline())): n, m = map(int, stdin.readline().split()) nations = [x for x in range(n + 1)] res = 0 for _ in range(m): a, b = map(int, stdin.readline().split()) if find_parent(nations, a) != find_parent(nations, b): union_parent(a, b, nations) res += 1 print(res) 💾 느낀점 공항이라는 문제를 풀었던 기억이 있고, 유니온-파인드 알고리즘을 이용해 시도해 봤었던 기억이 있습니다. 유파로 한번에 풀었던 문제입니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9372-%EC%83%81%EA%B7%BC%EC%9D%B4%EC%9D%98-%EC%97%AC%ED%96%89-with-python/","summary":"📌 BOJ 9372 상근이의 여행 💡 조건 N개국을 여행할 상근이에게 가장 적은 비행기를 타고 여행할 수 있게 도와주자. 테스트 케이스의 수 T(T ≤ 100) 첫 번째 줄에는 국가의 수 N(2 ≤ N ≤ 1 000)과 비행기의 종류 M(1 ≤ M ≤ 10 000) 가 주어진다.\n이후 M개의 줄에 a와 b 쌍들이 입력된다. a와 b를 왕복하는 비행기가 있다는 것을 의미한다. (1 ≤ a, b ≤ n; a ≠ b)\n주어지는 비행 스케줄은 항상 연결 그래프를 이룬다.","title":"[BOJ] 9372 상근이의 여행 with Python"},{"content":"\n📌 BOJ 2075 N번째 큰 수 💡 조건 N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데,\n모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. 표에 채워진 수는 모두 다르다. N(1 ≤ N ≤ 1,500) 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다. 자료구조 응용, 우선순위 큐 활용, 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 12 7 9 15 5 13 8 11 19 6 21 10 26 31 16 48 14 28 35 25 52 20 32 41 49 실행결과 35 ⌨️ 문제 풀이 q 라는 리스트를 만든다. 이 리스트는 표의 셀마다의 숫자를 넣을 것이며, 우선순위 큐로 사용된다. 각 숫자를 cnt 변수가 입력 받은 n과 같을 때까지 cnt + 1을 해주며 q 에 넣는다. 만약 q[0]의 값보다 방금 순회하고 있는 값이 크다면\n우선순위가 가장 높은 것을 꺼내고, 순회하고 있는 값을 넣는다. 모든 데이터를 순회했다면, q 를 정렬하고 가장 첫번째에 있는 값을 출력한다. 🖥 소스 코드 from sys import stdin import heapq n = int(stdin.readline()) q = [] cnt = 0 for _ in range(n): data = list(map(int, stdin.readline().split())) for j in data: if cnt != n: heapq.heappush(q, j) cnt += 1 else: if q[0] \u0026lt; j: heapq.heappop(q) heapq.heappush(q, j) q.sort() print(q[0]) 💾 느낀점 우선순위 큐의 성질을 이용하는 문제였습니다. 자료구조의 강의를 듣기 전, 우선순위큐는 대충 이런 느낌이지~ 라는 생각으로 풀었는데\n자료구조 강의를 보고 문제를 다시 보니 이런 꿀 골드문제가 없습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2075-n%EB%B2%88%EC%A7%B8-%ED%81%B0-%EC%88%98-with-python/","summary":"📌 BOJ 2075 N번째 큰 수 💡 조건 N×N의 표에 수 N2개 채워져 있다. 채워진 수에는 한 가지 특징이 있는데,\n모든 수는 자신의 한 칸 위에 있는 수보다 크다는 것이다. 표에 채워진 수는 모두 다르다. N(1 ≤ N ≤ 1,500) 표에 적힌 수는 -10억보다 크거나 같고, 10억보다 작거나 같은 정수이다. 자료구조 응용, 우선순위 큐 활용, 정렬 유형의 문제 🔖 예제 및 실행결과 예제 5 12 7 9 15 5 13 8 11 19 6 21 10 26 31 16 48 14 28 35 25 52 20 32 41 49 실행결과 35 ⌨️ 문제 풀이 q 라는 리스트를 만든다.","title":"[BOJ] 2075 N번째 큰 수 with Python"},{"content":"\n📌 BOJ 2168 터널 위의 대각선 💡 조건 한 변의 길이가 1cm인 정사각형 모양의 타일이 있다.\n이 타일들을 가로가 xcm, 세로가 ycm인 직사각형 모양의 벽에 빈틈없이 붙였다. x와 y는 정수이다. 직사각형에 붙어 있는 x*y개의 타일 중에는 대각선이 그려진 타일도 있고, 그렇지 않은 타일도 있다. x*y개의 타일 중에서 대각선이 그려져 있는 타일의 개수를 구하는 문제. x와 y는 1,000,000,000 이하의 자연수 수학, 정수론, 유클리드 호제법유형의 문제 🔖 예제 및 실행결과 예제 8 12 실행결과 16 ⌨️ 문제 풀이 유클리드 호제법과 관련된 문제입니다. 대각선이 꼭지점을 지나가지 않는 직사각형의 개수는 x + y + 1\n대각선이 꼭지점을 지나가는 직사각형의 개수는 x + y - (점의 개수) - 1\n입니다. 점의 개수는 gcd(x, y) - 1개 입니다. 우리는 대각선이 꼭지점을 지나가는 직사각형의 개수를 구해야하기 때문에\n(2)번의 두번째 공식을 이용해야하며, x + y - gcd(x + y) 가 성립한다. x + y - gcd(x + y) 를 출력한다. 🖥 소스 코드 from sys import stdin from math import gcd x, y = map(int, stdin.readline().split()) print(x + y - gcd(x, y)) 💾 느낀점 수학적인 지식이 부족해 어려웠습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2168-%ED%84%B0%EB%84%90-%EC%9C%84%EC%9D%98-%EB%8C%80%EA%B0%81%EC%84%A0-with-python/","summary":"📌 BOJ 2168 터널 위의 대각선 💡 조건 한 변의 길이가 1cm인 정사각형 모양의 타일이 있다.\n이 타일들을 가로가 xcm, 세로가 ycm인 직사각형 모양의 벽에 빈틈없이 붙였다. x와 y는 정수이다. 직사각형에 붙어 있는 x*y개의 타일 중에는 대각선이 그려진 타일도 있고, 그렇지 않은 타일도 있다. x*y개의 타일 중에서 대각선이 그려져 있는 타일의 개수를 구하는 문제. x와 y는 1,000,000,000 이하의 자연수 수학, 정수론, 유클리드 호제법유형의 문제 🔖 예제 및 실행결과 예제 8 12 실행결과 16 ⌨️ 문제 풀이 유클리드 호제법과 관련된 문제입니다.","title":"[BOJ] 2168 터널 위의 대각선 with Python"},{"content":"\n📌 BOJ 15970 화살표 그리기 💡 조건 부분 점수가 있는 문제. 점들의 개수를 나타내는 정수 N N개의 줄 각각에는 점의 좌표와 색깔을 나타내는 두 정수 x와 y가 주어진다. 모든 점에서 시작하는 화살표들의 길이 합을 출력하는 문제. 각 점은 N개의 색깔 중 하나를 가진다. 각 점 p에 대해서, p에서 시작하는 직선 화살표를 이용해서 다른 점 q에 연결하려고 한다.\n여기서, 점 q는 p와 같은 색깔의 점들 중 p와 거리가 가장 가까운 점이어야 한다.\n만약 가장 가까운 점이 두 개 이상이면 아무거나 하나를 선택한다. 브루트포스유형의 문제 🔖 예제 및 실행결과 예제 5 0 1 1 2 3 1 4 2 5 1 실행결과 13 ⌨️ 문제 풀이 n을 입력 받은 뒤, n개의 점의 위치화 색의 번호를 입력 받는다. 입력 받은 각 점의 위치와 색의 번호는 arr 리스트에 저장한다. arr 리스트를 순회한다.\n점의 색깔이 0이 아닌 경우, solve(색, 위치) 에 넘겨준다. solve 함수 내부에서 다시 arr 리스트를 순회하면서, 점의 위치는 같지 않으나 색깔이 같은 점을 찾는다. 같은 색깔의 점이 있다면 가장 작은 점의 거리를 min_cost 에 저장하고 반환한다. 반환값을 res 에 더해 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] for _ in range(n): x, y = map(int, stdin.readline().split()) arr.append((x, y)) def solve(color, idx): min_cost = int(1e9) for t_idx, t_color in arr: if t_idx != idx and t_color == color: if abs(idx - t_idx) \u0026lt; min_cost: min_cost = abs(idx - t_idx) return min_cost res = 0 for idx, color in arr: if color != 0: res += solve(color, idx) print(res) 💾 느낀점 자칫 잘못생각하면 어렵게 느껴질 문제였던 것 같습니다. 입력받은 n의 크기를 보고 시간초과가 나지 않을 것이라고 판단하고 풀이해서 쉽게 풀었습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15970-%ED%99%94%EC%82%B4%ED%91%9C-%EA%B7%B8%EB%A6%AC%EA%B8%B0-with-python/","summary":"📌 BOJ 15970 화살표 그리기 💡 조건 부분 점수가 있는 문제. 점들의 개수를 나타내는 정수 N N개의 줄 각각에는 점의 좌표와 색깔을 나타내는 두 정수 x와 y가 주어진다. 모든 점에서 시작하는 화살표들의 길이 합을 출력하는 문제. 각 점은 N개의 색깔 중 하나를 가진다. 각 점 p에 대해서, p에서 시작하는 직선 화살표를 이용해서 다른 점 q에 연결하려고 한다.\n여기서, 점 q는 p와 같은 색깔의 점들 중 p와 거리가 가장 가까운 점이어야 한다.","title":"[BOJ] 15970 화살표 그리기 with Python"},{"content":"\n📌 BOJ 19941 햄버거 분배 💡 조건 식탁의 길이가 N이다.\n사람들(P)은 자신의 위치에서 거리가 K 이하인 햄버거를 먹을 수 있다.\n1 \u0026lt;= N \u0026lt;= 20,000\n1 \u0026lt;= K \u0026lt;= 10 햄버거를 먹을 수 있는 사람의 최대 수를 구하는 프로그램을 작성. 그리디 알고리즘 유형의 문제 🖥 소스 코드 from sys import stdin n, k = map(int, stdin.readline().split()) arr = list(stdin.readline().rstrip()) res = 0 for i in range(n): if arr[i] == \u0026#39;P\u0026#39;: for j in range(i - k, i + k + 1): if -1 \u0026lt; j \u0026lt; n: if arr[j] == \u0026#39;H\u0026#39;: arr[j] = \u0026#39;-\u0026#39; res += 1 break print(res) 🔖 예제 및 실행결과 예제 20 1 HHPHPPHHPPHPPPHPHPHP 실행결과 8 ⌨️ 문제 풀이 식탁의 길이 N과 햄버거를 먹을 수 있는 거리 K 를 입력받는다. N 길이의 햄버거와 사람의 위치의 정보가 담긴 문자열을 입력받아 arr 리스트에 저장한다. n 만큼 arr 리스트를 순회하면서 arr[i]가 사람일 때, i - k 부터 i + k + 1 까지 순회한다\ni번째에 위치한 사람이 i - k 부터 i + k + 1 거리의 햄버거를 먹을 수 있기 때문에. 0 \u0026lt;= j \u0026lt; n 의 조건을 만족하고 arr[j]가 햄버거라면 arr의 해당 번호를 이미 먹은 표시로 - 로 변경하고 res + 1, break 💾 느낀점 그리디는 개념자체로는 이해가 쉬우나 막상 문제를 풀면 머리안에서 꼬여버리는 경우가 많다. 앞으로 그리디를 풀 때는 마음을 내려놓고 천천히 생각해보는 습관을 길러야겠다 ","permalink":"https://jxun-h.github.io/posts/ps/boj-19941-%ED%96%84%EB%B2%84%EA%B1%B0-%EB%B6%84%EB%B0%B0-with-python/","summary":"📌 BOJ 19941 햄버거 분배 💡 조건 식탁의 길이가 N이다.\n사람들(P)은 자신의 위치에서 거리가 K 이하인 햄버거를 먹을 수 있다.\n1 \u0026lt;= N \u0026lt;= 20,000\n1 \u0026lt;= K \u0026lt;= 10 햄버거를 먹을 수 있는 사람의 최대 수를 구하는 프로그램을 작성. 그리디 알고리즘 유형의 문제 🖥 소스 코드 from sys import stdin n, k = map(int, stdin.readline().split()) arr = list(stdin.readline().rstrip()) res = 0 for i in range(n): if arr[i] == \u0026#39;P\u0026#39;: for j in range(i - k, i + k + 1): if -1 \u0026lt; j \u0026lt; n: if arr[j] == \u0026#39;H\u0026#39;: arr[j] = \u0026#39;-\u0026#39; res += 1 break print(res) 🔖 예제 및 실행결과 예제 20 1 HHPHPPHHPPHPPPHPHPHP 실행결과 8 ⌨️ 문제 풀이 식탁의 길이 N과 햄버거를 먹을 수 있는 거리 K 를 입력받는다.","title":"[BOJ] 19941 햄버거 분배 with Python"},{"content":"\n📌 BOJ 11048 이동하기 💡 조건 N×M 크기의 미로 (1 ≤ N, M ≤ 1,000) (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동가능. 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하는 문제 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 3 1 2 3 6 5 4 7 8 9 12 11 10 실행결과 47 ⌨️ 문제 풀이 다이나믹 프로그래밍 유형의 문제입니다. 준규가 이동하면서 사탕을 모두 가져갈 수 있습니다. arr 리스트에 각 사탕이 놓여져 있는 숫자를 입력받습니다. candy 리스트는 준규가 챙긴 숫자의 최댓값을 저장할 리스트 입니다. candy[0][0] 은 arr[0][0] 이 되겠습니다.\n왜냐하면 준규는 (1, 1)에 위치하고 있기 때문입니다. 1부터 각각 n, m 만큼 이중 반복문으로 순회해줍니다.\ncandy[i][j] 의 숫자를 최댓값으로 갱신합니다. 준규가 움직일 수 있는 방향은 (0, 1), (1, 0), (1, 1) 이며\n이동 방향에 따라서 최댓값을 선택해서 candy를 갱신하고 (n - 1, m - 1) 인덱스에 있는 값을 출력합니다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [] candy = [[0] * m for _ in range(n)] res = 0 for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) candy[0][0] = arr[0][0] for i in range(1, m): candy[0][i] = arr[0][i] + candy[0][i - 1] for i in range(1, n): candy[i][0] = arr[i][0] + candy[i - 1][0] for i in range(1, n): for j in range(1, m): candy[i][j] = max(candy[i - 1][j], candy[i][j - 1], candy[i - 1][j - 1]) + arr[i][j] print(candy[n - 1][m - 1]) 💾 느낀점 실버 수준의 다이나믹프로그래밍 유형의 문제였는데, 이 유형을 풀어본 적이 있다면 풀 수 있는 문제였습니다. 그리디 문제도 이런 문제가 비슷하게 있는데, 입력받은 N과 M의 값을 보고 쎄한 느낌을 느끼고 그리디가 아닐 것이라는 생각을 했습니다. 점화식을 짜는게 아직 어렵습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-11048-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 11048 이동하기 💡 조건 N×M 크기의 미로 (1 ≤ N, M ≤ 1,000) (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동가능. 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하는 문제 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다. 다이나믹프로그래밍 유형의 문제 🔖 예제 및 실행결과 예제 4 3 1 2 3 6 5 4 7 8 9 12 11 10 실행결과 47 ⌨️ 문제 풀이 다이나믹 프로그래밍 유형의 문제입니다.","title":"[BOJ] 11048 이동하기 with Python"},{"content":"\n📌 BOJ 13565 침투 💡 조건 격자의 크기를 나타내는 M (2 ≤ M ≤ 1,000) 과 N (2 ≤ N ≤ 1,000) M줄에 걸쳐서, N개의 0 또는 1 이 공백 없이 주어진다. 0은 전류가 잘 통하는 흰색, 1은 전류가 통하지 않는 검은색 격자임을 뜻한다. 맨 윗줄에서 받은 전기가 맨 밑 줄까지 갈 수 있다면 True, 아니면 False BFS 유형의 문제 🔖 예제 및 실행결과 예제 5 6 010101 010000 011101 100011 001011 실행결과 NO ⌨️ 문제 풀이 전류판을 board 리스트에 입력받아 저장합니다.\n방문처리를 할 visited 를 set() 자료형으로 생성합니다. bfs 함수는 너비우선탐색의 로직을 기본적으로만 구현한 형태입니다.\n상하좌우로 움직이면서 큐에 다음 이동할 좌표를 넣으며, 이동할 수 있는 좌표를 큐에 넣었을 땐 visited 에 넣어줍니다.\n만약 n - 1 과 현재 큐에서 뽑은 x 좌표의 값이 같다면 맨 밑으로 전류가 전달 된 것이니 true 를 반환합니다.\n아니라면 None 이 반환됩니다. 가장 윗줄을 볼 것이기 때문에 m만큼 순회를 시작합니다.(j)\nborad[0][i] 가 0이고 (0, j) 좌표가 이미 검사한 좌표가 아니라면 bfs에 넣습니다. bfs의 결과 값이 true가 반환되었다면 res_tf 를 true로 갱신하고 순회를 종료합니다. res_tf 가 true 라면 YES, 아니라면 NO 를 출력합니다 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) board = [] visited = set() for _ in range(n): board.append(list(map(int, list(stdin.readline().rstrip())))) dx, dy = [0, 0, -1, 1], [1, -1, 0, 0] res_tf = False def bfs(x, y): q = deque() q.append((x, y)) visited.add((x, y)) while q: x, y = q.popleft() if x == n - 1: return True for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m and (nx, ny) not in visited: if board[nx][ny] == 0: q.append((nx, ny)) visited.add((nx, ny)) for j in range(m): if board[0][j] == 0 and (0, j) not in visited: if bfs(0, j) is True: res_tf = True break print(\u0026#39;YES\u0026#39;) if res_tf else print(\u0026#39;NO\u0026#39;) 💾 느낀점 간단한 너비우선탐색의 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-13565-%EC%B9%A8%ED%88%AC-with-python/","summary":"📌 BOJ 13565 침투 💡 조건 격자의 크기를 나타내는 M (2 ≤ M ≤ 1,000) 과 N (2 ≤ N ≤ 1,000) M줄에 걸쳐서, N개의 0 또는 1 이 공백 없이 주어진다. 0은 전류가 잘 통하는 흰색, 1은 전류가 통하지 않는 검은색 격자임을 뜻한다. 맨 윗줄에서 받은 전기가 맨 밑 줄까지 갈 수 있다면 True, 아니면 False BFS 유형의 문제 🔖 예제 및 실행결과 예제 5 6 010101 010000 011101 100011 001011 실행결과 NO ⌨️ 문제 풀이 전류판을 board 리스트에 입력받아 저장합니다.","title":"[BOJ] 13565 침투 with Python"},{"content":"\n📌 BOJ 2477 참외밭 💡 조건 m2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1 ≤ K ≤ 20) 참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여\n반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다. 참외밭은 ㄱ-자 모양이거나 ㄱ-자를 90도, 180도, 270도 회전한 모양(┏, ┗, ┛ 모양)의 육각형이다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 7 4 50 2 160 3 30 1 60 3 20 1 100 실행결과 47600 ⌨️ 문제 풀이 6개의 방향과 변의 길이를 각각 direction, length 라는 변수에 입력받는다\n동시에, 변의 길이는 nums 리스트에 저장해주고, direction이 1 이거나 2 일 때 x 리스트에, 아닐 경우에는 y 리스트에 저장한다. x 축으로 움직이는 변의 길이 중 가장 긴 것을 max_x 에 저장한다.\ny 축으로 움직이는 변의 길이 중 가장 긴 것을 max_y 에 저장한다. (2)에서 구한 max_x, max_y 값이 x 리스트, y 리스트에서 인덱스 값이 몇인지 구한다. 가장 긴 가로변(xi) 양측에 있는 가로 변의 길이 의 차이가 전체 사각형 길이에서 내가 빼줄 사각형의 가로 길이\n만약 xi + i 가 6보다 크거나 같으면 nums[xi-1] - nums[0] 가장 긴 세로변(xi) 양측에 있는 세로 변의 길이 의 차이가 전체 사각형 길이에서 내가 빼줄 사각형의 세로 길이\n만약 yi + i 가 6보다 크거나 같으면 nums[yi-1] - nums[0] 사각형 최대 넓이 - 작은 사각형의 넓이를 구한다. 사각형 최대 넓이 : max_x * max_y 작은 사각형 넓이 : x * y 면적 당 참외의 개수를 출력해야하니, (6)에서 구한 면적에 * n 을 해준 값을 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) nums = [] x, y = [], [] for _ in range(6): direction, length = map(int, stdin.readline().split()) nums.append(length) if direction == 1 or direction == 2: x.append(length) else: y.append(length) max_x = max(x) max_y = max(y) xi = nums.index(max_x) yi = nums.index(max_y) if xi + 1 \u0026gt;= 6: x = abs(nums[xi - 1] - nums[0]) else: x = abs(nums[xi - 1] - nums[xi + 1]) if yi + 1 \u0026gt;= 6: y = abs(nums[yi - 1] - nums[0]) else: y = abs(nums[yi - 1] - nums[yi + 1]) print(((max_x * max_y) - (x * y)) * n) 💾 느낀점 문제 풀이에 써놓은 4, 5번 을 떠올리지 못해서 헤맸던 문제였다. 블로그를 쓰려고 다시 보는데 또 헷갈려서 다시 풀었다. 이런 수학적인 사고를 하는 문제, DP 문제는 아직도 어렵다. 연습만이 살길이다. 다시 한 번 쓰면서 생각해보고 풀어서 다행이라고 생각한다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2477-%EC%B0%B8%EC%99%B8%EB%B0%AD-with-python/","summary":"📌 BOJ 2477 참외밭 💡 조건 m2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1 ≤ K ≤ 20) 참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여\n반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다. 참외밭은 ㄱ-자 모양이거나 ㄱ-자를 90도, 180도, 270도 회전한 모양(┏, ┗, ┛ 모양)의 육각형이다. 구현 유형의 문제 🔖 예제 및 실행결과 예제 7 4 50 2 160 3 30 1 60 3 20 1 100 실행결과 47600 ⌨️ 문제 풀이 6개의 방향과 변의 길이를 각각 direction, length 라는 변수에 입력받는다","title":"[BOJ] 2477 참외밭 with Python"},{"content":"\n📌 BOJ 9663 N-Queen 💡 조건 N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제. 1 \u0026lt;= N \u0026lt; 15 브루트포스, 백트래킹 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 8 실행결과 92 ⌨️ 문제 풀이 퀸은 각 줄마다 반드시 하나씩 들어가야한다.\n퀸이 있는 자리 기준으로 대각선, 세로선에는 다른 퀸이 존재할 수 없다.\n퀸의 좌표를 하나하나 확인하면서 문제를 해결하려고 하면 시간초과가 난다.\ndfs 함수에서 퀸을 놓은 개수가 n개가 되었으면 res + 1 후 return한다.\n(2)번의 기준에 따라, a는 세로줄, b, c는 대각선을 체크해주는 리스트이다.\nn의 길이만큼 순회하면서 a, b, c 리스트의 인덱스에 해당하는 값이 하나라도 True 일 경우\n퀸을 놓지 못하는 자리이기 때문에 continue\na, b, c 리스트의 인덱스에 해당하는 값이 모두 False 인 경우, 모두 True 로 갱신한 뒤 dfs(x + 1) 재귀호출\n빠져나온 후에는 백트래킹을 위해 a, b, c 리스트의 인덱스에 해당하는 부부을 False로 갱신\n🖥 소스 코드 from sys import stdin a, b, c = [False for _ in range(15)], [False for _ in range(30)], [False for _ in range(30)] n = int(stdin.readline()) res = 0 def dfs(x): global res if x == n: res += 1 return for y in range(n): if a[y] or b[x + y] or c[x + (n - y)]: continue a[y] = True b[x + y] = True c[x + (n - y)] = True dfs(x + 1) a[y] = False b[x + y] = False c[x + (n - y)] = False dfs(0) print(res) 💾 느낀점 백트래킹의 대표적인 문제라고 하지만, 대표적으로 어려운 문제라고 하는게 맞는 것 같다. 대각선과 세로의 각 좌표를 일일히 검사하려고 해서 시간초과를 피하지 못했다. 풀이를 보고 일차원 리스트를 세 개 만들어 검사하는 것을 보고, 놀랐던 기억이 있다. 문제를 포스팅하면서 다시 한 번 풀이를 생각해보는 것이 큰 도움이 되었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9663-n-queen-with-python/","summary":"📌 BOJ 9663 N-Queen 💡 조건 N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제. 1 \u0026lt;= N \u0026lt; 15 브루트포스, 백트래킹 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 8 실행결과 92 ⌨️ 문제 풀이 퀸은 각 줄마다 반드시 하나씩 들어가야한다.\n퀸이 있는 자리 기준으로 대각선, 세로선에는 다른 퀸이 존재할 수 없다.\n퀸의 좌표를 하나하나 확인하면서 문제를 해결하려고 하면 시간초과가 난다.\ndfs 함수에서 퀸을 놓은 개수가 n개가 되었으면 res + 1 후 return한다.","title":"[BOJ] 9663 N-Queen with Python"},{"content":"\n📌 BOJ 1759 암호 만들기 💡 조건 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과\n최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것.\n즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성.\n각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 문자들은 알파벳 소문자이며, 중복되는 것은 없다. 브루트포스, 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 4 6 a t c i s w 실행결과 acis acit aciw acst acsw actw aist aisw aitw astw cist cisw citw istw ⌨️ 문제 풀이 L, C 를 입력받고, C 개의 암호로 사용되었을 법한 문자를 리스트로 입력받는다. C 개의 암호로 사용되었을 법한 문자를 순회하면서, 모음 (a, e, i, o, u) 가 있는지 확인하여\nmo_um 리스트에 저장한다. 결과를 저장할 res 변수를 중복을 방지하기 위해 set() 자료형으로 생성한다. combinations 함수를 사용해 l의 길이로 된 조합을 만든다. set() 으로 감싸서 중복을 제거해준다. length 변수에 l을 저장해주고, 만들어진 조합을 순회한다.(i)\nmo_um을 순회하면서 i에 해당 모음이 있는지 확인하고, 있다면 length - 1 해준다. 암호는 최소 한 개의 모음을 가지고 있고, 두 개 이상의 자음을 가지고 있어야 한다.\nlength 가 2보다 작거나 l과 같을 경우 continue 해주고, 아니라면 res에 저장한다. res 를 한줄씩 출력한다. 🖥 소스 코드 from sys import stdin from itertools import combinations mo_um = [] l, c = map(int, stdin.readline().split()) alpha = list(stdin.readline().rstrip().split()) for i in alpha: if i in (\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;): mo_um.append(i) res = set() for i in list(set(combinations(alpha, l))): length = l for k in mo_um: if k in i: length -= 1 if length \u0026lt; 2 or length == l: continue else: res.add(tuple(sorted(list(i)))) for i in list(sorted(res)): print(\u0026#39;\u0026#39;.join(i)) 💾 느낀점 약 7회 시도 끝에 정답을 맞췄습니다.\n조건문이 잘못되어 틀렸습니다. length 변수를 만들어 조건을 사용할 생각을 하지 못해서 틀린 경우가 많았습니다. 다른 골드 난이도보다는 조금 쉬운 난이도의 문제였던 것 같습니다. 브루트포스, 백트래킹 문제를 더 많이 풀어보고 경험해봐야할 것 같습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1759-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-with-python/","summary":"📌 BOJ 1759 암호 만들기 💡 조건 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과\n최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것.\n즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성.\n각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력 두 정수 L, C가 주어진다.","title":"[BOJ] 1759 암호 만들기 with Python"},{"content":"\n📌 BOJ 2422 한윤정이 이탈리아에 가서 아이스크림을 사먹는데 💡 조건 아이스크림 가게에는 N종류의 아이스크림이 있다.\n모든 아이스크림은 1부터 N까지 번호가 매겨져있다.\n어떤 종류의 아이스크림을 함께먹으면, 맛이 아주 형편없어진다. 정수 N과 M이 주어진다. (1 ≤ N ≤ 200, 0 ≤ M ≤ 10,000)\nN은 아이스크림 종류의 수이고, M은 섞어먹으면 안 되는 조합의 개수이다. 같은 조합은 두 번 이상 나오지 않는다. 브루트포스 알고리즘, 그래프 이론유형의 문제 🔖 예제 및 실행결과 예제 5 3 1 2 3 4 1 3 실행결과 3 ⌨️ 문제 풀이 저는 브루트포스 알고리즘 보다 그래프 이론으로 풀이하는게 쉬웠습니다. 그래프로 사용할 nope dict 자료형 변수를 생성합니다.\n키 값은 각 아이스크림의 번호이며, value는 set()으로 설정했습니다.\n아이스크림의 번호가 매겨져 있는 ice_cream set() 자료형 변수를 생성합니다. 섞이면 안되는 각 아이스크림의 번호를 입력받아 처리를 해줍니다.\na 와 b 가 섞이면 안되는 조합이라면, nope[a]에 b를 넣어주고, nope[b]에 a 를 넣어줍니다. 1번부터 N번까지 아이스크림에서 세가지 조합을 찾아야하기에, combinations 함수를 사용하여 조합을 만들어줍니다.\n중복방지를 위해서 set()으로 둘러싸주고 순회를 시작합니다. 조합으로 선택된 세 개의 번호를 가진 아이스크림을 nope 자료구조에 키값으로 넣었을 때, 번호가 해당하는 곳에 없다면\n섞여도 되는 조합이기에 결과를 저장할 res 변수에 +1 을 해줍니다.\ndict 자료형에 섞이면 안되는 조합을 양방향으로 저장해두었기에, nope[x] 에서 x의 값은 소스코드마다 달라질 수 있습니다. res를 출력합니다. 🖥 소스 코드 from sys import stdin from itertools import combinations n, m = map(int, stdin.readline().split()) ice_cream = set(x for x in range(1, n + 1)) nope = {x: set() for x in range(1, n + 1)} for _ in range(m): a, b = map(int, stdin.readline().split()) nope[a].add(b) nope[b].add(a) res = 0 for comb in list(set(combinations(ice_cream, 3))): if comb[1] not in nope[comb[0]] and comb[2] not in nope[comb[0]] and comb[1] not in nope[comb[2]]: res += 1 print(res) 💾 느낀점 해시맵 자료구조(dict) 를 통해서 문제해결을 할 때 기분이 좋습니다. 브루트포스 알고리즘이라고 되어있는데, 사실 그래프 이론 문제로 들어가야하는게 아닌가 싶습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2422-%ED%95%9C%EC%9C%A4%EC%A0%95%EC%9D%B4-%EC%9D%B4%ED%83%88%EB%A6%AC%EC%95%84%EC%97%90-%EA%B0%80%EC%84%9C-%EC%95%84%EC%9D%B4%EC%8A%A4%ED%81%AC%EB%A6%BC%EC%9D%84-%EC%82%AC%EB%A8%B9%EB%8A%94%EB%8D%B0-with-python/","summary":"📌 BOJ 2422 한윤정이 이탈리아에 가서 아이스크림을 사먹는데 💡 조건 아이스크림 가게에는 N종류의 아이스크림이 있다.\n모든 아이스크림은 1부터 N까지 번호가 매겨져있다.\n어떤 종류의 아이스크림을 함께먹으면, 맛이 아주 형편없어진다. 정수 N과 M이 주어진다. (1 ≤ N ≤ 200, 0 ≤ M ≤ 10,000)\nN은 아이스크림 종류의 수이고, M은 섞어먹으면 안 되는 조합의 개수이다. 같은 조합은 두 번 이상 나오지 않는다. 브루트포스 알고리즘, 그래프 이론유형의 문제 🔖 예제 및 실행결과 예제 5 3 1 2 3 4 1 3 실행결과 3 ⌨️ 문제 풀이 저는 브루트포스 알고리즘 보다 그래프 이론으로 풀이하는게 쉬웠습니다.","title":"[BOJ] 2422 한윤정이 이탈리아에 가서 아이스크림을 사먹는데 with Python"},{"content":"\n📌 BOJ 11655 ROT13 💡 조건 ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.\n\u0026ldquo;Baekjoon Online Judge\u0026quot;를 ROT13으로 암호화하면 \u0026ldquo;Onrxwbba Bayvar Whqtr\u0026quot;가 된다.\nROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. S를 ROT13으로 암호화한 내용을 출력하는 문제 구현, 문자열유형의 문제 🔖 예제 및 실행결과 예제 Baekjoon Online Judge 실행결과 Onrxwbba Bayvar Whqtr ⌨️ 문제 풀이 각 문자열을 순회하면서 아스키코드에 해당하는 숫자를 대문자일 경우와 소문자일 경우를 나눠 처리를 하고\n각 아스키코드 숫자에 +13을 해주어 바꾸어주고 출력하면 된다. 만약 아스키코드 숫자가 알파벳 문자 범위를 넘어간다면, -26을 해주어 다시 그 범위안으로 들어가주게 한 뒤 출력한다. 🖥 소스 코드 from sys import stdin for i in list(stdin.readline().rstrip()): if i == \u0026#39; \u0026#39;: print(\u0026#39; \u0026#39;, end=\u0026#39;\u0026#39;) elif i.isnumeric(): print(i, end=\u0026#39;\u0026#39;) else: if i.isupper(): temp = ord(i) + 13 if temp \u0026gt; 90: print(chr(temp - 26), end=\u0026#39;\u0026#39;) else: print(chr(temp), end=\u0026#39;\u0026#39;) else: temp = ord(i) + 13 if temp \u0026gt; 122: print(chr(temp - 26), end=\u0026#39;\u0026#39;) else: print(chr(temp), end=\u0026#39;\u0026#39;) 💾 느낀점 재미있는 문자열, 구현 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-11655-rot13-with-python/","summary":"📌 BOJ 11655 ROT13 💡 조건 ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.\n\u0026ldquo;Baekjoon Online Judge\u0026quot;를 ROT13으로 암호화하면 \u0026ldquo;Onrxwbba Bayvar Whqtr\u0026quot;가 된다.\nROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. S를 ROT13으로 암호화한 내용을 출력하는 문제 구현, 문자열유형의 문제 🔖 예제 및 실행결과 예제 Baekjoon Online Judge 실행결과 Onrxwbba Bayvar Whqtr ⌨️ 문제 풀이 각 문자열을 순회하면서 아스키코드에 해당하는 숫자를 대문자일 경우와 소문자일 경우를 나눠 처리를 하고","title":"[BOJ] 11655 ROT13 with Python"},{"content":"\n📌 BOJ 1236 성 지키기 💡 조건 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다.\n영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다. 성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 문제 0 \u0026lt;= N, M \u0026lt;= 50 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다. 구현, 시뮬레이션유형의 문제 🔖 예제 및 실행결과 예제 4 4 .... .... .... .... 실행결과 4 ⌨️ 문제 풀이 각 열과 행에 모두 경비원이 있었으면 좋겠다고 생각을 했으니, 열과 행에 경비원이 있는지 체크할 col, row 리스트를 생성한다.\n이 리스트는 각 원소를 False 로 초기화 한 상태로 생성한다. 경비원의 값을 저장할 r1, r2 변수를 생성한다. 성의 크기만큼 순회하면서 (i, j) 에 X 가 있을 경우, row[i], col[j] 를 각각 True로 갱신한다. 각 성의 가로 크기(i -\u0026gt; n), 세로 크기(j -\u0026gt; m)만큼 순회하면서 row[i], col[j] 가 각각 False 일 경우\nr1, r2 에 각각 + 1을 더해준다. r1, r2 중 가장 큰 값을 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [] col = [False] * m row = [False] * n r1, r2 = 0, 0 for i in range(n): data = list(stdin.readline().rstrip()) arr.append(data) for i in range(n): for j in range(m): if arr[i][j] == \u0026#39;X\u0026#39;: row[i] = True col[j] = True for i in range(n): if not row[i]: r1 += 1 for j in range(m): if not col[j]: r2 += 1 print(max(r1, r2)) 💾 느낀점 구현 문제이지만, 어디에 경비원이 있어야 각 열과 행이 모두 True 값을 가지는지 생각하는 것이 헷갈렸다. 브론즈라고 했지만, 구현은 역시 그 이상의 티어로 봐야하는 것 같다. 논리적인 사고력이 약하다는 것을 다시 한 번 느끼게 해주는 문제였다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1236-%EC%84%B1-%EC%A7%80%ED%82%A4%EA%B8%B0-with-python/","summary":"📌 BOJ 1236 성 지키기 💡 조건 직사각형 모양의 성을 가지고 있다. 성의 1층은 몇 명의 경비원에 의해서 보호되고 있다.\n영식이는 모든 행과 모든 열에 한 명 이상의 경비원이 있으면 좋겠다고 생각했다. 성의 크기와 경비원이 어디있는지 주어졌을 때, 몇 명의 경비원을 최소로 추가해야 영식이를 만족시키는지 구하는 문제 0 \u0026lt;= N, M \u0026lt;= 50 성의 상태는 .은 빈칸, X는 경비원이 있는 칸이다. 구현, 시뮬레이션유형의 문제 🔖 예제 및 실행결과 예제 4 4 .","title":"[BOJ] 1236 성 지키기 with Python"},{"content":"\n📌 BOJ 14248 점프 점프 💡 조건 돌다리의 돌 개수 n이 주어진다.(1≤n≤100,000) 그 위치에서 점프할 수 있는 거리 Ai (1≤Ai≤100,000) 현재위치에서 다른 돌을 적절히 밟아 해당하는 위치로 이동이 가능하다고 할 때, 영우가 방문 가능한 돌들의 개수를 구하는 문제. 탐색 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 5 1 4 2 2 1 3 실행결과 5 ⌨️ 문제 풀이 입력으로 받은 점프할 수 있는 거리를 그래프에 넣어준다.\n인덱스 에러를 방지하기 위해 arr 리스트의 크기는 n + 1로 해준다. (1) 번 작업에서, 현재 위치에서 이동할 수 있는 거리를 빼거나 더했을 때, 리스트 인덱스의 범위인지 확인하고 넣는다. BFS 알고리즘을 이용하여 방문처리 배열을 만들고 방문해준다. 정답은 영우가 방문 할 수 있는 돌들의 개수이니, visited 리스트의 길이 + 1을 출력한다. 영우가 처음 밟은 돌도 포함이니까 + 1 해준다.\n시작하는 돌을 visited에 먼저 넣어주고 시작했다면 + 1을 굳이 하지 않아도 된다. 🖥 소스 코드 from sys import stdin from collections import deque n = int(stdin.readline()) arr = [0] + list(map(int, stdin.readline().split())) graph = [[] for _ in range(n + 1)] s = int(stdin.readline()) for i in range(1, n + 1): if 0 \u0026lt; i + arr[i] \u0026lt; n + 1: graph[i].append(i + arr[i]) if 0 \u0026lt; i - arr[i] \u0026lt; n + 1: graph[i].append(i - arr[i]) def solve(s): q = deque() q.append(s) visited = set() while q: now = q.popleft() for x in graph[now]: if x not in visited: visited.add(x) q.append(x) return len(visited) print(solve(s) + 1) 💾 느낀점 재미있는 BFS 문제였습니다. 개굴 개굴 ","permalink":"https://jxun-h.github.io/posts/ps/boj-14248-%EC%A0%90%ED%94%84-%EC%A0%90%ED%94%84-with-python/","summary":"📌 BOJ 14248 점프 점프 💡 조건 돌다리의 돌 개수 n이 주어진다.(1≤n≤100,000) 그 위치에서 점프할 수 있는 거리 Ai (1≤Ai≤100,000) 현재위치에서 다른 돌을 적절히 밟아 해당하는 위치로 이동이 가능하다고 할 때, 영우가 방문 가능한 돌들의 개수를 구하는 문제. 탐색 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 5 1 4 2 2 1 3 실행결과 5 ⌨️ 문제 풀이 입력으로 받은 점프할 수 있는 거리를 그래프에 넣어준다.\n인덱스 에러를 방지하기 위해 arr 리스트의 크기는 n + 1로 해준다.","title":"[BOJ] 14248 점프 점프 with Python"},{"content":"\n📌 BOJ 6603 로또 💡 조건 집합 S에서 K개의 숫자를 골라 뽑아 낼 수 있는 경우의 수를 모두 출력하는 문제 입력이 여러개 들어오며, 0이 들어왔을 때 종료 백트래킹, 재귀, 조합유형의 문제 🔖 예제 및 실행결과 예제 7 1 2 3 4 5 6 7 8 1 2 3 5 8 13 21 34 0 실행결과 1 2 3 4 5 6 1 2 3 4 5 7 1 2 3 4 6 7 1 2 3 5 6 7 1 2 4 5 6 7 1 3 4 5 6 7 2 3 4 5 6 7 1 2 3 5 8 13 1 2 3 5 8 21 1 2 3 5 8 34 1 2 3 5 13 21 1 2 3 5 13 34 1 2 3 5 21 34 1 2 3 8 13 21 1 2 3 8 13 34 1 2 3 8 21 34 1 2 3 13 21 34 1 2 5 8 13 21 1 2 5 8 13 34 1 2 5 8 21 34 1 2 5 13 21 34 1 2 8 13 21 34 1 3 5 8 13 21 1 3 5 8 13 34 1 3 5 8 21 34 1 3 5 13 21 34 1 3 8 13 21 34 1 5 8 13 21 34 2 3 5 8 13 21 2 3 5 8 13 34 2 3 5 8 21 34 2 3 5 13 21 34 2 3 8 13 21 34 2 5 8 13 21 34 3 5 8 13 21 34 ⌨️ 문제 풀이 조합을 이용하여 S 수열에 있는 K개의 숫자를 뽑아낸 조합의 경우의 수를 구하되, 가능한 조합을 모두 출력하는 문제. combinations 를 사용하여 조합을 모두 뽑아내고, res 라는 리스트에 넣어 출력했다. 🖥 소스 코드 from sys import stdin from itertools import combinations while 1: data = list(map(int, stdin.readline().split())) if len(data) == 1 and data[0] == 0: break else: a, arr = data[0], data[1:] res = [] for x in list(set(combinations(arr, 6))): if len(set(x)) == 6: temp = sorted(list(x)) if temp not in res: res.append(temp) for x in sorted(list(res)): print(*x) print() 💾 느낀점 백트래킹 문제는 재귀로 풀어보는 것이 도움이 된다. N과 M 시리즈를 풀면서 재귀로 백트래킹을 연습하는 것도 좋을 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-6603-%EB%A1%9C%EB%98%90-with-python/","summary":"📌 BOJ 6603 로또 💡 조건 집합 S에서 K개의 숫자를 골라 뽑아 낼 수 있는 경우의 수를 모두 출력하는 문제 입력이 여러개 들어오며, 0이 들어왔을 때 종료 백트래킹, 재귀, 조합유형의 문제 🔖 예제 및 실행결과 예제 7 1 2 3 4 5 6 7 8 1 2 3 5 8 13 21 34 0 실행결과 1 2 3 4 5 6 1 2 3 4 5 7 1 2 3 4 6 7 1 2 3 5 6 7 1 2 4 5 6 7 1 3 4 5 6 7 2 3 4 5 6 7 1 2 3 5 8 13 1 2 3 5 8 21 1 2 3 5 8 34 1 2 3 5 13 21 1 2 3 5 13 34 1 2 3 5 21 34 1 2 3 8 13 21 1 2 3 8 13 34 1 2 3 8 21 34 1 2 3 13 21 34 1 2 5 8 13 21 1 2 5 8 13 34 1 2 5 8 21 34 1 2 5 13 21 34 1 2 8 13 21 34 1 3 5 8 13 21 1 3 5 8 13 34 1 3 5 8 21 34 1 3 5 13 21 34 1 3 8 13 21 34 1 5 8 13 21 34 2 3 5 8 13 21 2 3 5 8 13 34 2 3 5 8 21 34 2 3 5 13 21 34 2 3 8 13 21 34 2 5 8 13 21 34 3 5 8 13 21 34 ⌨️ 문제 풀이 조합을 이용하여 S 수열에 있는 K개의 숫자를 뽑아낸 조합의 경우의 수를 구하되, 가능한 조합을 모두 출력하는 문제.","title":"[BOJ] 6603 로또 with Python"},{"content":"\n📌 BOJ 2535 아시아 정보올림피아드 💡 조건 대회참가 학생 수를 나타내는 N, 3 ≤ N ≤ 100. N개의 줄에는 각 줄마다 한 학생의 소속 국가 번호, 학생 번호, 그리고 성적이 하나의 빈칸을 사이에 두고 주어진다. 국가 번호는 1부터 순서대로 하나의 정수로 주어지며, 각 학생번호는 각 나라별로 1부터 순서대로 하나의 정수로 주어진다. 점수는 0 이상 1000 이하의 정수이고, 동점자는 없다고 가정한다. 정렬, 구현유형의 문제. 🔖 예제 및 실행결과 예제 9 1 1 230 1 2 210 1 3 205 2 1 100 2 2 150 3 1 175 3 2 190 3 3 180 3 4 195 실행결과 1 1 1 2 3 4 ⌨️ 문제 풀이 입력을 받아 리스트에 저장할 때, 점수, 참가국, 학생번호 순으로 저장한다.\n이후, sort 를 해주면 점수순으로 정렬이 된다. 수상을 한 이력을 담을 h 딕셔너리 변수를 하나만들고, 정렬된 grade 리스트를 순회한다.\ngrade 리스트를 순회하면서\n만약 해당 국가 (grade[i][1])가 수상 이력이 없으면 수상한 국가의 수 cnt + 1\n수상 이력에 grade[i][1] 를 추가하고 값을 1로 한다. 만약 해당 국가 (grade[i][1])가 수상 이력이 있고, 수상 이력의 수가 2 미만이면 수상한 국가의 수 cnt + 1\n수상 이력에 해당 국가에 + 1 한다. 만약 수상한 국가가 3이라면 반복문을 멈춘다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) grade = [] for i in range(n): a,b,c = map(int, stdin.readline().split()) grade.append((c, a, b)) h = {} grade.sort(reverse=True) cnt = 0 for i in range(n): if cnt == 3: break if grade[i][1] not in h: print(*grade[i][1:]) cnt += 1 h[grade[i][1]] = 1 else: if h[grade[i][1]] \u0026lt; 2: print(*grade[i][1:]) h[grade[i][1]] += 1 cnt += 1 else: continue 💾 느낀점 정렬을 하고 약간의 조건문만 추가해주면 쉽게 풀 수 있는 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2535-%EC%95%84%EC%8B%9C%EC%95%84-%EC%A0%95%EB%B3%B4%EC%98%AC%EB%A6%BC%ED%94%BC%EC%95%84%EB%93%9C-with-python/","summary":"📌 BOJ 2535 아시아 정보올림피아드 💡 조건 대회참가 학생 수를 나타내는 N, 3 ≤ N ≤ 100. N개의 줄에는 각 줄마다 한 학생의 소속 국가 번호, 학생 번호, 그리고 성적이 하나의 빈칸을 사이에 두고 주어진다. 국가 번호는 1부터 순서대로 하나의 정수로 주어지며, 각 학생번호는 각 나라별로 1부터 순서대로 하나의 정수로 주어진다. 점수는 0 이상 1000 이하의 정수이고, 동점자는 없다고 가정한다. 정렬, 구현유형의 문제. 🔖 예제 및 실행결과 예제 9 1 1 230 1 2 210 1 3 205 2 1 100 2 2 150 3 1 175 3 2 190 3 3 180 3 4 195 실행결과 1 1 1 2 3 4 ⌨️ 문제 풀이 입력을 받아 리스트에 저장할 때, 점수, 참가국, 학생번호 순으로 저장한다.","title":"[BOJ] 2535 아시아 정보올림피아드 with Python"},{"content":"\n📌 BOJ 1940 주몽 💡 조건 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 문제 정렬, 투 포인터 유형의 문제 🔖 예제 및 실행결과 예제 6 9 2 7 4 1 5 3 실행결과 2 ⌨️ 문제 풀이 정렬을 해서 투포인터를 사용해 문제를 푸는 것이 이 문제의 요점인 것 같다. 나는 파이썬 bisect 라이브러리의 bisect_left 를 써서 쉽게 풀수 있었다. 재료들의 각 고유번호를 입력받아 놓은 arr이라는 변수를 정렬하고 순회한다. (3)번을 통해 순회하는 값인 i가 있다.\n갑옷이 만들어지기 위한 값 m 에서 i를 뺀 값이 arr 리스트에 위치하고 있는지\nbisect_left 를 통해 이분탐색해준 결과를 f 변수에 저장한다.\nf 가 n 보다 작고, arr[f]가 i와 같지 않다면, i + f는 m이다. (4)에서 나온 결과 값이 참인지 확인하고, (arr[f], i) 의 쌍이 한번도 나온적 없는 조합이라면\nres + 1을 해주고, (arr[f], i), (i, arr[f]) 를 visited에 저장해 이미 나온 조합이라고 표시해둔다. (1)~(5) 과정을 거치고 난 후, res를 출력해준다. 🖥 소스 코드 from sys import stdin from bisect import bisect_left n = int(stdin.readline()) m = int(stdin.readline()) arr = sorted(list(map(int, stdin.readline().split()))) res = 0 visited = set() arr.sort() for i in arr: f = bisect_left(arr, m-i) if f \u0026lt; n and arr[f] != i: temp = arr[f] if temp + i == m and (temp, i) not in visited: visited.add((temp, i)) visited.add((i, temp)) res += 1 print(res) 💾 느낀점 투포인터로 풀면 훨씬 쉬웠을 것 같은데, 3달 전의 나는 왜 bisect 라이브러리를 사용했을까? 투포인터를 연습하기 매우 좋은 문제인 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1940-%EC%A3%BC%EB%AA%BD-with-python/","summary":"📌 BOJ 1940 주몽 💡 조건 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 문제 정렬, 투 포인터 유형의 문제 🔖 예제 및 실행결과 예제 6 9 2 7 4 1 5 3 실행결과 2 ⌨️ 문제 풀이 정렬을 해서 투포인터를 사용해 문제를 푸는 것이 이 문제의 요점인 것 같다.","title":"[BOJ] 1940 주몽 with Python"},{"content":"\n📌 BOJ 1292 쉽게 푸는 문제 💡 조건 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고\n어느 일정한 구간을 주면 그 구간의 합을 구하는 문제 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다.\n수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다. 다이나믹 프로그래밍, 수학, 구현유형의 문제 🔖 예제 및 실행결과 예제 3 7 실행결과 15 ⌨️ 문제 풀이 리스트에 구간합에 대해 값을 저장하여 arr[m] - arr[n-1]을 하여 출력하면 된다. 구간합의 값을 가진 리스트 arr 에서는 arr[m] - arr[n-1]을 아래와 같이 말할 수 있다.\n(첫번째부터 m번째 숫자까지의 합) - (첫번째부터 n-1번째 숫자까지의 합)과 같다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = [0, 1] for i in range(2, m + 1): for j in range(i): arr.append(arr[-1] + i) print(arr[m] - arr[n - 1]) 💾 느낀점 문제 제목대로 쉽게 푸는 문제였고, 매우 친절한 구간합 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1292-%EC%89%BD%EA%B2%8C-%ED%91%B8%EB%8A%94-%EB%AC%B8%EC%A0%9C-with-python/","summary":"📌 BOJ 1292 쉽게 푸는 문제 💡 조건 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 .. 이러한 수열을 만들고\n어느 일정한 구간을 주면 그 구간의 합을 구하는 문제 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다.\n수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다. 다이나믹 프로그래밍, 수학, 구현유형의 문제 🔖 예제 및 실행결과 예제 3 7 실행결과 15 ⌨️ 문제 풀이 리스트에 구간합에 대해 값을 저장하여 arr[m] - arr[n-1]을 하여 출력하면 된다.","title":"[BOJ] 1292 쉽게 푸는 문제 with Python"},{"content":"\n📌 BOJ 16234 인구 이동 💡 조건 N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다.\nN, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100) 인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다. 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다. 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 연합을 해체하고, 모든 국경선을 닫는다. 각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성해야한다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100) BFS 알고리즘, 구현유형의 문제 🔖 예제 및 실행결과 예제 2 20 50 50 30 30 40 실행결과 1 ⌨️ 문제 풀이 board 리스트에 각 국가의 인구수를 입력 받고, 인구 이동 횟수를 저장할 cnt 변수를 0으로 초기화. 인구 이동이 일어나지 않을 때까지 while 반복을 통해서 체크를 해줄 것. 인구 이동이 일어났을 때, 인구 이동 후의 인구 수와 인구 이동이 일어난 도시의 좌표를 담을 리스트 변수 tf를 생성한다. board 를 순회하면서, 각 좌표에서 연합이 될 수 있는 국가를 체크하여 반환된 값을 temp에 저장한다.\n만약, temp 가 False라면 인구이동이 일어나지 않은 것이다.\n반대로 False 가 아니라면 인구이동이 일어난 것이다. board 전체를 순회했음에도 인구이동이 일어나지 않아 tf가 비어있다면, 그대로 while 문 밖으로 나온다. tf가 비어있지 않다면, 인구이동 횟수(cnt)를 + 1 해준 뒤,\ntf 를 순차적으로 순회하면서, 연합끼리의 인구 이동을 한 좌표에 해당하는 인구 수로 board 값을 갱신한다. check() 함수의 로직은 아래와 같다. BFS 알고리즘을 이용하여 매개변수로 받은 좌표와 연합이 될 수 있는 모든 국가를 찾는다. 다음 이동하려는 좌표가 방문하지 않았어야하고,\n그 좌표에 해당하는 board의 값이 l \u0026lt;= 국경을 공유하는 국가들의 인구 차이 \u0026lt;= r 의 조건을 지켜야한다. 또한 (1), (2) 의 조건을 지킨 경우, 연합들의 각 인구수는 vals 리스트에 저장해 평균 인구수를 계산할 수 있게 한다. check 함수 내의 인구이동 판별 변수인 tf 에 인구이동을 했을 시, True 값을 저장한다. 🖥 소스 코드 from sys import stdin from collections import deque n, l, r = map(int, stdin.readline().split()) if l \u0026gt; r: l, r = r, l board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) dx, dy = [1, 0, 0, -1], [0, -1, 1, 0] def check(x, y): visited = set() q = deque() visited.add((x, y)) q.append((x, y, board[x][y])) vals = [board[x][y]] tf = False while q: x, y, cost = q.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; n: if l \u0026lt;= abs(cost - board[nx][ny]) \u0026lt;= r and (nx, ny) not in visited: visited.add((nx, ny)) q.append((nx, ny, board[nx][ny])) vals.append(board[nx][ny]) tf = True if not tf: return False else: res = int(sum(vals) / len(vals)) return [res, visited] cnt = 0 while 1: tf = [] for i in range(n): for j in range(n): temp = check(i, j) if temp is not False: tf.append(temp) if not tf: break else: cnt += 1 for val, visited in tf: for x, y in visited: board[x][y] = val print(cnt) 💾 느낀점 국경선을 공유하는 두 국가의 인구 차이 조건을 넣는 것에서 한번 헤맸다. 연합으로 구성된 국가들의 인구 평균 수를 구하는 방법에서 고민을 했었다. 모든 연합을 따로 구해서 연합끼리의 평균 인구 수로 갱신하는 부분이 한번에 이루어져야 한다. 하지만 (3)의 방식이 아닌 연합이 생길때마다 변경해주어 예제 결과도 다르게 나오는 대참사가 있었다. BFS 알고리즘 중에서도 조건이 꽤 있어서 구현이 조금 묻어나온 문제 같았고, 풀기 조금 힘이 들었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-16234-%EC%9D%B8%EA%B5%AC-%EC%9D%B4%EB%8F%99-with-python/","summary":"📌 BOJ 16234 인구 이동 💡 조건 N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다.\nN, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100) 인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.","title":"[BOJ] 16234 인구 이동 with Python"},{"content":"\n📌 BOJ 14500 테트로미노 💡 조건 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다. 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 해야한다. 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다. 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500) N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다.\n입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다. S의 문제 🔖 예제 및 실행결과 예제 5 5 1 2 3 4 5 5 4 3 2 1 2 3 4 5 6 6 5 4 3 2 1 2 1 2 1 실행결과 19 ⌨️ 문제 풀이 테트로미노가 될 수 있는 모든 경우의 좌표를 tetro 라는 딕셔너리에 저장한다. 종이의 크기와 종이에 써있는 숫자를 입력받아 각 변수 및 리스트에 저장한다. 각 테트로미노가 위치할 수 있는 모양에 대해서 순회하면서, 각 좌표에서 놓을 수 있는 테트로미노 모양이 가질 수 있는 값 중 최댓값을 구한다.\n테트로미노의 좌표는 tetro 라는 변수에서 이미 가지고 있기 때문에, 기준이 되는 좌표 (i, j)에서 놓을 수 있는지 없는지도 구분할 수 있다.\nres 라는 변수가 최종적으로 답을 출력할 변수, value 가 좌표 (i, j) 의 위치에서 놓을 수 있는 테트로미노 모양에서의 값을 의미한다. 각 테트로미노, 좌표값을 순회하고 갱신한 값 중 최댓값을 가지고 있는 res 를 출력한다. 🖥 소스 코드 from sys import stdin tetro = { # ㅁ 0: [[(0, 0), (0, 1), (1, 0), (1, 1)]], # ㄱ,ㄴ 1: [[(0, 0), (0, 1), (0, 2), (-1, 0)], [(0, 0), (0, 1), (0, 2), (1, 0)], [(0, 0), (0, 1), (0, 2), (1, 2)], [(0, 0), (0, 1), (0, 2), (-1, 2)], [(0, 0), (-1, 0), (-2, 0), (0, 1)], [(0, 0), (-1, 0), (-2, 0), (0, -1)], [(0, 0), (1, 0), (2, 0), (0, -1)], [(0, 0), (1, 0), (2, 0), (0, 1)]], # ㅡ, ㅣ 2: [[(0, 0), (0, 1), (0, 2), (0, 3)], [(0, 0), (1, 0), (2, 0), (3, 0)]], # ㅗ, ㅓ 3: [[(0, 0), (1, -1), (1, 0), (1, 1)], [(0, 0), (-1, -1), (-1, 0), (-1, 1)], [(0, 0), (0, 1), (-1, 1), (1, 1)], [(0, 0), (0, -1), (-1, -1), (1, -1)]], # ㄹ - = 4: [[(0, 0), (1, 0), (1, 1), (2, 1)], [(0, 0), (0, 1), (-1, 1), (-1, 2)], [(0, 0), (1, 0), (1, -1), (2, -1)], [(0, 0), (0, 1), (1, 1), (1, 2)]] } n, m = map(int, stdin.readline().split()) board = [] for _ in range(n): board.append(list(map(int, stdin.readline().split()))) def get_value(x, y, blocks): global res for block in blocks: value = 0 for i, j in block: nx, ny = i + x, j + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: value += board[nx][ny] else: break res = max(res, value) res = -int(1e9) for x in range(5): blocks = tetro[x] for i in range(n): for j in range(m): get_value(i, j, blocks) print(res) 💾 느낀점 테트로미노 모양을 일일히 좌표로 정해두고 풀어야한다고 생각하지 못했다. (1)번과 같은 생각을 해야하는 문제가 아닌, 시작점부터 bfs로 테트로미노 모양을 계산해서 풀어야한다고 생각했다가 큰 코 다칠뻔했다. 테트로미노 모양을 좌표로 정해두고 나서는 그리 어려운 문제가 아니었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8-with-python/","summary":"📌 BOJ 14500 테트로미노 💡 조건 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다. 테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 해야한다. 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다. 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500) N개의 줄에 종이에 쓰여 있는 수가 주어진다.","title":"[BOJ] 14500 테트로미노 with Python"},{"content":"\n📌 BOJ 15658 연산자 끼워넣기 (2) 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN\nN(2 ≤ N ≤ 11), (1 ≤ Ai ≤ 100) 입력 값중 셋째 줄에 4N보다 작거나 같은 4개의 정수가 주어지는데,\n차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다. 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다. 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 나눗셈은 정수 나눗셈으로 몫만 취한다. 또한 음수를 나눌 때에는 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾸어야 한다. 백트래킹, DFS 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 2 3 4 5 6 3 2 1 1 실행결과 72 -48 ⌨️ 문제 풀이 DFS 알고리즘과 백트래킹을 이용한 문제 풀이를 했다. DFS에 매개변수로 들어가는 val 의 값은 수열의 순서를 바꾸면 안되기 때문에 무슨 짓을 해도 수열[0] 의 값과 같다. DFS에 매개변수로 들어가는 num은 입력받은 수열의 index 1번부터 들어가면 된다. DFS가 종료되는 시점은 num 이라는 리스트가 비어있을 때이며 이 때, 최댓값과 최솟값을 갱신하면서 종료된다.\n최댓값은 -int(1e9), 최솟값은 int(1e9)이다. arr 리스트는 각각 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)의 개수이며, 입력으로 받는다. 만약 DFS가 넘겨받는 num 리스트가 비어있지 않다면, 반복문을 0부터 3까지 반복을 한다.\n반복하면서, 각 i 의 숫자에 따라 arr[i]의 값이 0보다 클 때, val 변수에 해당하는 연산을 해준 뒤, 재귀호출을 한다. 재귀호출을 할 때, num[1:] 을 매개변수로 넘겨주어 중복 계산을 방지한다.\n이렇게 재귀호출을 하게 되면 넘겨주는 리스트는 길이가 앞에서부터 하나씩 없어지게 되는데,\n재귀 호출 전, arr[i]를 -1 해주고 재귀 호출 후 +1 해준다. 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) n = int(stdin.readline()) n_num = list(map(int, stdin.readline().split())) arr = list(map(int, stdin.readline().split())) def dfs(num, val): global max_res, min_res if not num: max_res = max(val, max_res) min_res = min(val, min_res) return else: for i in range(4): if i == 0: if arr[i] \u0026gt; 0: arr[i] -= 1 dfs(num[1:], val + num[0]) arr[i] += 1 else: continue if i == 1: if arr[i] \u0026gt; 0: arr[i] -= 1 dfs(num[1:], val - num[0]) arr[i] += 1 else: continue if i == 2: if arr[i] \u0026gt; 0: arr[i] -= 1 dfs(num[1:], val * num[0]) arr[i] += 1 else: continue if i == 3: if arr[i] \u0026gt; 0: arr[i] -= 1 if val \u0026lt; 0: temp = abs(val) // num[0] * -1 else: temp = val // num[0] dfs(num[1:], temp) arr[i] += 1 else: continue max_res = -int(1e9) min_res = int(1e9) dfs(n_num[1:], n_num[0]) print(max_res, min_res, sep=\u0026#39;n\u0026#39;) 💾 느낀점 단순히 permutations 혹은 combinations 로 풀지 않았고,\n정확하게 DFS 및 백트래킹을 활용하여 풀이했는데, 이것이 N과 M 시리즈를 푸는데에 좋은 연습이 됐다. 조건이 크게 없었지만, division error를 조심해야 했고,\n음수일 경우에 나눗셈의 방식이 조금 다르기 때문에 간단한 조건 추가하는 것만 조심하면 되는 문제였던 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15658-%EC%97%B0%EC%82%B0%EC%9E%90-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-2-with-python/","summary":"📌 BOJ 15658 연산자 끼워넣기 (2) 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN\nN(2 ≤ N ≤ 11), (1 ≤ Ai ≤ 100) 입력 값중 셋째 줄에 4N보다 작거나 같은 4개의 정수가 주어지는데,\n차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다. 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다. 식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다.","title":"[BOJ] 15658 연산자 끼워넣기 (2) with Python"},{"content":"\n📌 BOJ 1904 01타일 💡 조건 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다. 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다.\n결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다. N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.)\n또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다. N이 주어진다.\n(1 ≤ N ≤ 1,000,000) 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다. DP 유형의 문제 🔖 예제 및 실행결과 예제 4 실행결과 5 ⌨️ 문제 풀이 N이 100만까지 들어올 수 있다. 그러므로, DP 리스트의 크기는 1000001 이 되어야한다. N의 값이 3일 때까지 직접 계산을 해보면 dp[3] 까지의 값은 아래와 같다. 1, 2, 3 dp[i] = (dp[i-1] + dp[i-2]) % 15746\n위와 같은 점화식을 만들 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) dp = [0 for _ in range(1000001)] dp[1], dp[2], dp[3], dp[4] = 1, 2, 3, 5 for i in range(5, n + 1): num = ((dp[i-1] + dp[i-2]) % 15746) dp[i] = num print(dp[n]) 💾 느낀점 다이나믹프로그래밍을 이용해 문제를 풀이할 수 있는 문제였습니다. 다른 DP 문제와 다르게 친절하고, 쉽고 재미있었습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1904-01%ED%83%80%EC%9D%BC-with-python/","summary":"📌 BOJ 1904 01타일 💡 조건 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다. 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다.\n결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다. N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.)\n또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.","title":"[BOJ] 1904 01타일 with Python"},{"content":"\n📌 BOJ 9933 민균이의 비밀번호 💡 조건 민균이의 비밀번호가 \u0026ldquo;tulipan\u0026quot;인 경우에 목록에는 \u0026ldquo;napilut\u0026quot;도 존재해야 한다. 민균이의 파일에 적혀있는 단어가 모두 주어졌을 때, 비밀번호의 길이와 가운데 글자를 출력하는 프로그램을 작성하라. 단어의 수 N (2 ≤ N ≤ 100)이 주어진다. 단어는 알파벳 소문자로만 이루어져 있으며, 길이는 2보다 크고 14보다 작은 홀수이다. 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 4 las god psala sal 실행결과 3 a ⌨️ 문제 풀이 data 리스트에 입력되는 n개의 비밀번호를 저장한다. temp 변수에 data 리스트의 i번째 비밀번호를 복사한다.\ntemp에 있는 리스트를 뒤집어준다. temp가 만약 data 안에 있다면, data 의 가운데 글자와 비밀번호의 길이를 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) data = [] for _ in range(n): data.append(list(stdin.readline().rstrip())) def solve(): for i in range(n): temp = data[i][:] temp.reverse() if temp in data: length = len(temp) mid = data[i][length // 2] return length, mid print(*solve()) 💾 느낀점 간단한 구현 및 문자열 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9933-%EB%AF%BC%EA%B7%A0%EC%9D%B4%EC%9D%98-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-with-python-copy/","summary":"📌 BOJ 9933 민균이의 비밀번호 💡 조건 민균이의 비밀번호가 \u0026ldquo;tulipan\u0026quot;인 경우에 목록에는 \u0026ldquo;napilut\u0026quot;도 존재해야 한다. 민균이의 파일에 적혀있는 단어가 모두 주어졌을 때, 비밀번호의 길이와 가운데 글자를 출력하는 프로그램을 작성하라. 단어의 수 N (2 ≤ N ≤ 100)이 주어진다. 단어는 알파벳 소문자로만 이루어져 있으며, 길이는 2보다 크고 14보다 작은 홀수이다. 구현, 문자열 유형의 문제 🔖 예제 및 실행결과 예제 4 las god psala sal 실행결과 3 a ⌨️ 문제 풀이 data 리스트에 입력되는 n개의 비밀번호를 저장한다.","title":"[BOJ] 9933 민균이의 비밀번호 with Python"},{"content":"\n📌 BOJ 1058 친구 💡 조건 어떤 사람 A가 또다른 사람 B의 2-친구가 되기 위해선, 두 사람이 친구이거나, A와 친구이고, B와 친구인 C가 존재해야 된다. 여기서 가장 유명한 사람은 2-친구의 수가 가장 많은 사람이다. 가장 유명한 사람의 2-친구의 수를 출력하는 프로그램을 작성하시오. A와 B가 친구면, B와 A도 친구이고, A와 A는 친구가 아니다. 사람의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.\n둘째 줄부터 N개의 줄에 각 사람이 친구이면 Y, 아니면 N이 주어진다.\n가장 유명한 사람의 2-친구의 수를 출력한다. 플로이드-와샬 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 10 NNNNYNNNNN NNNNYNYYNN NNNYYYNNNN NNYNNNNNNN YYYNNNNNNY NNYNNNNNYN NYNNNNNYNN NYNNNNYNNN NNNNNYNNNN NNNNYNNNNN 실행결과 8 ⌨️ 문제 풀이 플로이드-와샬 알고리즘 알고리즘을 사용하여 문제를 풀이한다. Y를 1로, N을 0으로 변환한 뒤, arr에 입력받은 데이터를 저장한다. test 배열에 arr배열을 복사한 뒤, 플로이드-와샬 알고리즘을 돌리기 위한 3중 반복문을 순회한다. arr[i][k] 와 arr[k][j] 가 1이라면, test[i][j]에 1을 저장한다.\ni와 j 가 한다리 건너서 친구인지 확인하는 구간이다. test 배열을 순회하면서 test[i]의 합이 최댓값인 것을 찾아서 결과값을 저장할 res 변수에 저장하고, 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) arr = [] for i in range(n): temp = stdin.readline().rstrip().replace(\u0026#34;N\u0026#34;, \u0026#39;0\u0026#39;).replace(\u0026#34;Y\u0026#34;, \u0026#39;1\u0026#39;) data = list(map(int, list(temp))) arr.append(data) res = [0] * n test = [item[:] for item in arr] for k in range(n): for i in range(n): for j in range(n): if i != j: if arr[i][k] and arr[k][j]: test[i][j] = 1 res = 0 for i in range(n): friends = sum(test[i]) if res \u0026lt; friends: res = friends print(res) 💾 느낀점 플로이드-와샬 알고리즘의 응용문제였다. 모든 노드에서의 최단거리를 찾는 방식이 아닌,\n모든 노드에서 친구가 될 수 있는 경우를 찾아 test 배열에 저장하는 방식으로 풀이했다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1058-%EC%B9%9C%EA%B5%AC-with-python/","summary":"📌 BOJ 1058 친구 💡 조건 어떤 사람 A가 또다른 사람 B의 2-친구가 되기 위해선, 두 사람이 친구이거나, A와 친구이고, B와 친구인 C가 존재해야 된다. 여기서 가장 유명한 사람은 2-친구의 수가 가장 많은 사람이다. 가장 유명한 사람의 2-친구의 수를 출력하는 프로그램을 작성하시오. A와 B가 친구면, B와 A도 친구이고, A와 A는 친구가 아니다. 사람의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.\n둘째 줄부터 N개의 줄에 각 사람이 친구이면 Y, 아니면 N이 주어진다.","title":"[BOJ] 1058 친구 with Python"},{"content":"\n📌 BOJ 1094 막대기 💡 조건 64cm인 막대를 가지고 있다.\n지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다. 아래는 막대를 자르는 방법이다. 지민이가 가지고 있는 막대의 길이를 모두 더한다.\n처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.\n1-1) 가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.\n1-2) 만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면,2) 이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다. 위에서 자른 막대의 절반 중 하나를 버린다. X는 64보다 작거나 같은 자연수 DFS, 수학, 비트마스킹 유형의 문제 🔖 예제 및 실행결과 예제 23 실행결과 4 ⌨️ 문제 풀이 DFS 알고리즘을 사용해서 풀이했다. 결과값을 저장할 res 변수와 분리되지 않은 막대기 64가 들어가있는 sticks 리스트를 생성한다. solve() 함수의 로직은 아래와 같습니다. sticks 리스트의 합이 입력받은 값 x 보다 클 경우,\nsticks 에서 heapq.heappop() 함수를 통해 가장 작은 값을 빼낸다.\n빼낸 값을 2로 나눈 몫을 다시 heapq.heappush()로 다시 넣어준다. 만약, sticks 리스트의 합에서 heapq.heappop() 함수를 통해 가장 작은 값을 뺀 값이 x보다 크거나 같다면\nheapq.heappop() 함수를 통해 가장 작은 값을 빼낸다.\nsolve() 함수를 재귀호출한다. 위의 조건에 해당하지 않고, sticks의 리스트의 합이 x보다 크거나 같다면 다시 solve() 함수를 재귀호출한다. sticks 리스트의 길이를 출력한다. 🖥 소스 코드 from sys import stdin, setrecursionlimit import heapq setrecursionlimit(10 ** 6) x = int(stdin.readline()) res = 0 sticks = [64] def solve(sticks): global res val = sum(sticks) if val \u0026gt; x: temp = heapq.heappop(sticks) heapq.heappush(sticks, temp // 2) heapq.heappush(sticks, temp // 2) if sum(sticks) - (temp // 2) \u0026gt;= x: heapq.heappop(sticks) solve(sticks) elif sum(sticks) \u0026gt;= x: solve(sticks) solve(sticks) print(len(sticks)) 💾 느낀점 heapq를 사용하여 재귀호출을 통해 답을 구하는 문제였습니다. 막대기를 자르는 방법을 충실히 구현하여 재귀호출하는 방법을 사용한다면 어렵지 않게 풀 수 있는 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1094-%EB%A7%89%EB%8C%80%EA%B8%B0-with-python/","summary":"📌 BOJ 1094 막대기 💡 조건 64cm인 막대를 가지고 있다.\n지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다. 아래는 막대를 자르는 방법이다. 지민이가 가지고 있는 막대의 길이를 모두 더한다.\n처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다.\n1-1) 가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다.\n1-2) 만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면,2) 이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다.","title":"[BOJ] 1094 막대기 with Python"},{"content":"\n📌 BOJ 1021 회전하는 큐 💡 조건 N개의 원소를 포함하고 있는 양방향 순환 큐 1 \u0026lt;= N \u0026lt;= 50 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, \u0026hellip;, ak이었던 것이 a2, \u0026hellip;, ak와 같이 된다. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 a2, \u0026hellip;, ak, a1이 된다. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 ak, a1, \u0026hellip;, ak-1이 된다. 그 원소를 주어진 순서대로 뽑아내는데 드는 2번, 3번 연산의 최솟값을 출력하는 문제. Queue, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 32 6 27 16 30 11 6 23 실행결과 59 ⌨️ 문제 풀이 큐의 크기만큼 1부터 N까지의 수를 포함한 리스트를 만들어준다. 결과값을 저장할 res 변수를 0으로 초기화해준다. 추출하려고 하는 수를 저장한 arr 를 순회하면서 break 명령이 떨어질 때 까지 while 반복한다. 만약 큐의 첫번째 원소가 뽑아내려는 수와 일치 하는 경우, 바로 원소를 뽑아낸 뒤 while을 종료한다 만약 큐의 첫번째 원소가 뽑아내려는 수와 일치 하지 않는 경우, 큐의 길이를 2로 나눈 몫이 큐에서 뽑아 내려는 값의 인덱스보다 크거나 같다면 왼쪽에서 원소를 뽑아 오른쪽에 붙인다. 큐의 길이를 2로 나눈 몫이 큐에서 뽑아 내려는 값의 인덱스보다 작다면 오른쪽에서 원소를 뽑아 왼쪽에 붙인다. 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) q = deque() for i in range(1, n + 1): q.append(i) res = 0 for i in arr: while 1: if q[0] != i: if len(q) // 2 \u0026gt;= q.index(i): temp = q.popleft() q.append(temp) res += 1 else: q.appendleft(q.pop()) res += 1 else: q.popleft() break print(res) 💾 느낀점 python 의 deque 는 매우 강력하다. appendleft는 두고두고 쓸 함수일 것 같다는 생각이 들었습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1021-%ED%9A%8C%EC%A0%84%ED%95%98%EB%8A%94-%ED%81%90-with-python/","summary":"📌 BOJ 1021 회전하는 큐 💡 조건 N개의 원소를 포함하고 있는 양방향 순환 큐 1 \u0026lt;= N \u0026lt;= 50 큐에서 다음과 같은 3가지 연산을 수행할 수 있다. 첫 번째 원소를 뽑아낸다. 이 연산을 수행하면, 원래 큐의 원소가 a1, \u0026hellip;, ak이었던 것이 a2, \u0026hellip;, ak와 같이 된다. 왼쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 a2, \u0026hellip;, ak, a1이 된다. 오른쪽으로 한 칸 이동시킨다. 이 연산을 수행하면, a1, \u0026hellip;, ak가 ak, a1, \u0026hellip;, ak-1이 된다.","title":"[BOJ] 1021 회전하는 큐 with Python"},{"content":"\n📌 BOJ 1026 보물 💡 조건 길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자. S = A[0] × B[0] + ... + A[N-1] × B[N-1] S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다. 정렬, 사칙연산 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 1 6 0 2 7 8 3 1 실행결과 18 ⌨️ 문제 풀이 가장 큰 수와 가장 작은 수를 곱하여 더하면 최솟값이 나온다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) a = sorted(list(map(int, stdin.readline().split()))) b = sorted(list(map(int, stdin.readline().split())), reverse=True) print(sum([a * b for a, b in zip(a, b)])) 💾 느낀점 정렬하여 쉽게 풀었던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1026-%EB%B3%B4%EB%AC%BC-with-python/","summary":"📌 BOJ 1026 보물 💡 조건 길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자. S = A[0] × B[0] + ... + A[N-1] × B[N-1] S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다. 정렬, 사칙연산 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 1 6 0 2 7 8 3 1 실행결과 18 ⌨️ 문제 풀이 가장 큰 수와 가장 작은 수를 곱하여 더하면 최솟값이 나온다.","title":"[BOJ] 1026 보물 with Python"},{"content":"\n📌 BOJ 14916 거스름돈 💡 조건 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈 액수 n(1 ≤ n ≤ 100,000) DP, 수학 유형의 문제 🔖 예제 및 실행결과 예제 13 실행결과 5 ⌨️ 문제 풀이 5원 동전이 몇 개 일때 최소인지 구하면 된다. int(1e9)로 결과값을 초기하화 해두고, n // 5 개부터 한개씩 5원짜리를 줄여가며 최소 갯수를 구한다. 5원 개수에 해당하는 금액만큼 n에서 뺀 후, 2 로 나누어 떨어지지 않을 경우 continue 5월 개수에 해당하는 금액만큼 n에서 뺀 나머지 금액이 2로 나누어 떨어지면 res 갱신 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) res = int(1e9) for i in range(n // 5, -1, -1): money = n - i * 5 cnt = i if money % 2 != 0: continue else: cnt += money // 2 res = min(cnt, res) print(res) if res != int(1e9) else print(-1) 💾 느낀점 분류에는 DP라고 되어 있었지만, 메모이제이션은 필요가 없고, 식만 세우면 풀이가 가능한 문제였다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-14916-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-with-python/","summary":"📌 BOJ 14916 거스름돈 💡 조건 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈 액수 n(1 ≤ n ≤ 100,000) DP, 수학 유형의 문제 🔖 예제 및 실행결과 예제 13 실행결과 5 ⌨️ 문제 풀이 5원 동전이 몇 개 일때 최소인지 구하면 된다. int(1e9)로 결과값을 초기하화 해두고, n // 5 개부터 한개씩 5원짜리를 줄여가며 최소 갯수를 구한다. 5원 개수에 해당하는 금액만큼 n에서 뺀 후, 2 로 나누어 떨어지지 않을 경우 continue 5월 개수에 해당하는 금액만큼 n에서 뺀 나머지 금액이 2로 나누어 떨어지면 res 갱신 🖥 소스 코드 from sys import stdin n = int(stdin.","title":"[BOJ] 14916 거스름돈 with Python"},{"content":"\n📌 BOJ 20291 파일 정리 💡 조건 바탕화면에 있는 파일의 개수 N (1 \u0026lt;= N \u0026lt;= 50000) 파일의 이름은 알파벳 소문자와 점(.)으로만 구성되어 있다.\n점은 정확히 한 번 등장하며, 파일 이름의 첫 글자 또는 마지막 글자로 오지 않는다.\n각 파일의 이름의 길이는 최소 3, 최대 100이다. 확장자의 이름과 그 확장자 파일의 개수를 한 줄에 하나씩 출력한다.\n확장자가 여러 개 있는 경우 확장자 이름의 사전순으로 출력한다. 해시맵 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 8 sbrus.txt spc.spc acm.icpc korea.icpc sample.txt hello.world sogang.spc example.txt 실행결과 icpc 2 spc 2 txt 3 world 1 ⌨️ 문제 풀이 확장자의 이름과 개수를 저장할 dict 자료형 변수 하나를 만든다. split() 함수를 사용해 \u0026lsquo;.\u0026lsquo;을 기준으로 분리한 후 확장자 명이 dict에 있을 경우 + 1, 없으면 새로 추가한 후 1값을 넣는다. dict_name.items() 함수를 사용하여, key, value 쌍을 res 리스트에 넣고 정렬한 뒤 출력한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) file_name = {} for i in range(n): data = stdin.readline().rstrip().split(\u0026#39;.\u0026#39;) if data[1] in file_name: file_name[data[1]] += 1 else: file_name[data[1]] = 1 res = [] for key, item in file_name.items(): res.append((key, item)) res.sort() for i in res: print(*i) 💾 느낀점 해시맵을 사용해 간단하게 풀었던 문제였습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-20291-%ED%8C%8C%EC%9D%BC-%EC%A0%95%EB%A6%AC-with-python/","summary":"📌 BOJ 20291 파일 정리 💡 조건 바탕화면에 있는 파일의 개수 N (1 \u0026lt;= N \u0026lt;= 50000) 파일의 이름은 알파벳 소문자와 점(.)으로만 구성되어 있다.\n점은 정확히 한 번 등장하며, 파일 이름의 첫 글자 또는 마지막 글자로 오지 않는다.\n각 파일의 이름의 길이는 최소 3, 최대 100이다. 확장자의 이름과 그 확장자 파일의 개수를 한 줄에 하나씩 출력한다.\n확장자가 여러 개 있는 경우 확장자 이름의 사전순으로 출력한다. 해시맵 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 8 sbrus.","title":"[BOJ] 20291 파일 정리 with Python"},{"content":"\n📌 BOJ 14502 연구소 💡 조건 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8) 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다. DFS + BFS, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 7 7 2 0 0 0 1 1 0 0 0 1 0 1 2 0 0 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 0 실행결과 27 ⌨️ 문제 풀이 맵의 정보를 입력받으면서, 바이러스의 위치를 virus_xy 리스트에 저장한다. 안전 영역의 최댓값을 담을 변수 score 를 -int(1e9)로 초기화한다. 이 문제의 풀이를 위해서 사용할 함수는 총 3개이다. get_score(board) : 안전 영역의 크기를 계산하여 최댓값일 경우 score 갱신 insfection(x, y, board) : 벽을 세우고, 바이러스가 이동하며 감염. 보드를 갱신. BFS 알고리즘을 사용. solutions(cnt) : 3개의 벽을 세울 수 있게 cnt를 파라미터로 사용. DFS 알고리즘을 사용. 설치한 벽의 개수가 3개가 될 때까지 DFS 알고리즘을 사용해 맵을 갱신한다.\n벽이 3개가 설치 되었다면, 새로운 보드를 만들고 감염을 시켜준다. 새로운 보드를 감염시킨 후, score 계산을 한다.\n계산한 score 값이 최댓값일 경우, 갱신한다. 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) board = [] virus_xy = [] for i in range(n): data = list(map(int, stdin.readline().split())) board.append(data) for j in range(len(data)): if data[j] == 2: virus_xy.append((i, j)) score = -1e9 dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] def get_score(board): global score cnt = 0 for x in range(n): for y in range(m): if board[x][y] == 0: cnt += 1 score = max(score, cnt) def insfection(x, y, board): q = deque() q.append((x, y)) while q: a, b = q.popleft() for i in range(4): nx, ny = a + dx[i], b + dy[i] if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: if board[nx][ny] == 0: board[nx][ny] = 2 q.append((nx, ny)) def solutions(cnt): if cnt == 3: new_board = [item[:] for item in board] for x, y in virus_xy: insfection(x, y, new_board) get_score(new_board) else: for x in range(n): for y in range(m): if board[x][y] == 0: board[x][y] = 1 cnt += 1 solutions(cnt) cnt -= 1 board[x][y] = 0 solutions(0) print(score) 💾 느낀점 PyPy3 로 채점하여 통과했다. DFS를 사용하여 벽을 3개 설치한 후, BFS를 사용하여 감염, score 계산하는 로직을 이해하는 것이 처음엔 어려웠다. 문제를 풀고서 매우 뒤늦게 블로그 포스팅을 하는 것인데, 로직을 이해하니 비슷한 유형의 문제를 푸는 것이 확실히 수월해졌다. 여기서 조금 더 응용을 하자면, 벽을 설치했는지 안했는지의 state를 저장할\ndp 배열을 만들면 메모리제이션을 통해 시간복잡도를 줄일 수 있는 유사문제도 있었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-14502-%EC%97%B0%EA%B5%AC%EC%86%8C-with-python/","summary":"📌 BOJ 14502 연구소 💡 조건 연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다. 벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8) 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.","title":"[BOJ] 14502 연구소 with Python"},{"content":"\n📌 BOJ 14888 연산자 끼워넣기 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자\n연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 수의 개수 N(2 ≤ N ≤ 11)\nA1, A2, \u0026hellip;, AN이 주어진다. (1 ≤ Ai ≤ 100) 첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 6 0 0 1 0 실행결과 30 30 ⌨️ 문제 풀이 permutations 라이브러리 import 연산자를 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷) 순서대로 담은 gi 리스트 선언. 연산자의 개수 리스트를 입력받아 각 연산자의 개수만큼 곱하여 cg 리스트에 extend 해준다. cg 리스트의 길이는 입력받은 수열의 길이 - 1이다.\npermutaions 함수를 통해 순열을 통해 연산자의 경우를 뽑아 calculation 함수에 넣고 계산한다. calculation 함수에서 zero division 에러를 조심해야한다. calculation 함수에서 계산한 결과값으로 최솟값과 최댓값을 갱신해준다. 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.readline().rstrip()) num = list(map(int, stdin.readline().split())) cal_ = list(map(int, stdin.readline().split())) gi = [\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;/\u0026#39;] cg = [] vmax = -1e9 vmin = 1e9 def calculation(sign, num): global vmax, vmin calc_num = num[0] for idx in range(1, len(num)): if sign[idx - 1] == \u0026#39;+\u0026#39;: calc_num += num[idx] elif sign[idx - 1] == \u0026#39;-\u0026#39;: calc_num -= num[idx] elif sign[idx - 1] == \u0026#39;*\u0026#39;: calc_num *= num[idx] elif sign[idx - 1] == \u0026#39;/\u0026#39;: if num[idx] \u0026lt; 0 or calc_num \u0026lt; 0: calc_num = abs(calc_num) // abs(num[idx]) * -1 else: calc_num //= num[idx] vmax = max(vmax, calc_num) vmin = min(vmin, calc_num) for i in range(4): cg.extend([gi[i]] * cal_[i]) for sign in list(set(permutations(cg, n - 1))): calculation(sign, num) print(vmax) print(vmin) 💾 느낀점 permutations 함수를 사용하여 간단하게 풀 수 있어 매우 착한 문제였다고 생각합니다. 시간초과가 안나게 하기 위해서 permutations 함수 결과를 set() 으로 둘러싸서 중복을 제거했습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-14888-%EC%97%B0%EC%82%B0%EC%9E%90-%EB%81%BC%EC%9B%8C%EB%84%A3%EA%B8%B0-with-python/","summary":"📌 BOJ 14888 연산자 끼워넣기 💡 조건 N개의 수로 이루어진 수열 A1, A2, \u0026hellip;, AN 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자\n연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 수의 개수 N(2 ≤ N ≤ 11)\nA1, A2, \u0026hellip;, AN이 주어진다. (1 ≤ Ai ≤ 100) 첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 5 6 0 0 1 0 실행결과 30 30 ⌨️ 문제 풀이 permutations 라이브러리 import 연산자를 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷) 순서대로 담은 gi 리스트 선언.","title":"[BOJ] 14888 연산자 끼워넣기 with Python"},{"content":"\n📌 BOJ 10819 차이를 최대로 💡 조건 N개의 정수로 이루어진 배열 A N (3 ≤ N ≤ 8) 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다. 다음 식의 최댓값을 구하는 프로그램을 작성. |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]| 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 20 1 15 8 4 10 실행결과 62 ⌨️ 문제 풀이 최댓값을 저장할 res 정수 생성 itertools 의 permutaions 함수로 가능한 수를 모두 계산하여 v에 저장하고, res 갱신 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) res = -int(1e9) for arr2 in permutations(arr, n): v = 0 for i in range(n-1): v += abs(arr2[i] - arr2[i + 1]) res = max(res, v) print(res) 💾 느낀점 배열의 크기가 최대 8개 밖에 안되기에 permutaions를 썼다. 만약 배열의 크기가 컸다면? ","permalink":"https://jxun-h.github.io/posts/ps/boj-10819-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%B5%9C%EB%8C%80%EB%A1%9C-with-python/","summary":"📌 BOJ 10819 차이를 최대로 💡 조건 N개의 정수로 이루어진 배열 A N (3 ≤ N ≤ 8) 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다. 다음 식의 최댓값을 구하는 프로그램을 작성. |A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]| 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 20 1 15 8 4 10 실행결과 62 ⌨️ 문제 풀이 최댓값을 저장할 res 정수 생성 itertools 의 permutaions 함수로 가능한 수를 모두 계산하여 v에 저장하고, res 갱신 🖥 소스 코드 from sys import stdin from itertools import permutations n = int(stdin.","title":"[BOJ] 10819 차이를 최대로 with Python"},{"content":"\n📌 BOJ 11504 돌려 돌려 돌림판! 💡 조건 첫 번째 줄에 테스트케이스의 개수 T 테스트케이스의 첫 줄에는 돌림판을 N등분할 정수 N (1 ≤ N ≤ 100)\nX, Y의 길이 M (1 ≤ M ≤ 9, M ≤ N)\n다음 3개의 줄에 X의 각 자리수, Y의 각 자리수, 돌림판의 상태 돌림판에서 X ≤ Z ≤ Y를 만족하는 M자리의 수 Z가 몇 개가 있는 지를 출력 X와 Y사이에 있는 수가 123 밖에 없는 데 돌림판에서 2번 나온다면, 1이 아닌 2를 출력 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 8 3 2 0 0 3 1 1 3 7 8 3 1 9 2 7 5 2 8 8 9 9 1 3 2 5 4 6 3 0 0 0 9 9 9 1 2 3 4 5 6 실행결과 1 0 6 ⌨️ 문제 풀이 돌림판의 숫자를 입력받아, m개의 개수만큼 이어붙여 새로운 숫자를 만든다. x 와 y 사이에 있는 숫자인지 확인한 후, res를 갱신한다. res 출력 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): n, m = map(int, stdin.readline().split()) x = int(\u0026#39;\u0026#39;.join(list(stdin.readline().split()))) y = int(\u0026#39;\u0026#39;.join(list(stdin.readline().split()))) data = list(map(int, stdin.readline().split())) data += data[:m] res = 0 for i in range(n): check = int(\u0026#39;\u0026#39;.join(map(str, data[i:i+m]))) if x \u0026lt;= check \u0026lt;= y: res += 1 print(res) 💾 느낀점 구현 \u0026amp; 시뮬레이터 문제 중 브론즈인만큼 매우 쉬운 문제. 문제가 길어서 읽기 귀찮아도 막상 읽어보면 별거 아닌 문제. 구현과 시뮬레이션이라기보다, 문제 읽고 압축하는 연습은 됐다고 생각합니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-11504-%EB%8F%8C%EB%A0%A4-%EB%8F%8C%EB%A0%A4-%EB%8F%8C%EB%A6%BC%ED%8C%90-with-python/","summary":"📌 BOJ 11504 돌려 돌려 돌림판! 💡 조건 첫 번째 줄에 테스트케이스의 개수 T 테스트케이스의 첫 줄에는 돌림판을 N등분할 정수 N (1 ≤ N ≤ 100)\nX, Y의 길이 M (1 ≤ M ≤ 9, M ≤ N)\n다음 3개의 줄에 X의 각 자리수, Y의 각 자리수, 돌림판의 상태 돌림판에서 X ≤ Z ≤ Y를 만족하는 M자리의 수 Z가 몇 개가 있는 지를 출력 X와 Y사이에 있는 수가 123 밖에 없는 데 돌림판에서 2번 나온다면, 1이 아닌 2를 출력 구현, 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 8 3 2 0 0 3 1 1 3 7 8 3 1 9 2 7 5 2 8 8 9 9 1 3 2 5 4 6 3 0 0 0 9 9 9 1 2 3 4 5 6 실행결과 1 0 6 ⌨️ 문제 풀이 돌림판의 숫자를 입력받아, m개의 개수만큼 이어붙여 새로운 숫자를 만든다.","title":"[BOJ] 11504 돌려 돌려 돌림판! with Python"},{"content":"\n📌 BOJ 1535 안녕 💡 조건 첫째 줄에 사람의 수 N(≤ 20). 둘째 줄에 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 입력. 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 입력. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0. 세준이가 얻을 수 있는 최대 기쁨을 출력. 브루트포스 알고리즘, 배낭 알고리즘 유형 문제 🔖 예제 및 실행결과 예제 3 1 21 79 20 30 25 실행결과 50 ⌨️ 문제 풀이 브루트포스 알고리즘 혹은 냅색 알고리즘 으로 풀이할 수 있다.\n나는 냅색 알고리즘을 사용했다. 인사를 할 때 사용하는 스테미너 소모하는 리스트를 stamina_consum 에 [0]에 연결하여 저장한다.\n인사를 할 때 얻을 수 있는 기쁨 리스트를 get_pleasure 에 [0]에 연결하여 저장한다. dp 배열을 만든다. 1명부터 n명까지 인사를 했을 때, 얻을 수 있는 최대의 기쁨의 값을 저장할 배열. i번째 사람에게 인사를 하고, 스테미너 소모량보다 체력 j가 클 때 인사를 해서 얻을 수 있는 기쁨의 양을 계산하여 dp에 저장한다. 체력이 1이 기준이며, 출력할 때 dp[n][100]을 출력하면 세준이가 인사를 하다 죽어버린 경우이니 오답이다. dp[n][99]를 출력한다. 만약 stamina[i] 보다 체력 j 가 적을 경우, dp[i][j] 는 dp[i-1][j]의 값을 가져다 넣는다. 그렇지 않은 경우에는 dp[i-1][j] 와 dp[i-1][j - stamina_consum[i]] 에 get_pleasure[i] 값 중 큰 걸 집어 넣는다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) stamina_consum = [0] + list(map(int, stdin.readline().split())) get_pleasure = [0] + list(map(int, stdin.readline().split())) dp = [[0] * 101 for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, 101): if stamina_consum[i] \u0026lt;= j: dp[i][j] = max(dp[i-1][j], dp[i-1][j - stamina_consum[i]] + get_pleasure[i]) else: dp[i][j] = dp[i-1][j] print(dp[n][99]) 💾 느낀점 냅색 알고리즘은 풀어도 풀어도 헷갈린다. 알고리즘을 알고서 풀어도 어렵고, 까먹으면 답도 없는 것 같다. 냅색 알고리즘 문제를 정리해서 풀어봐야할 것 같다. 문제 풀이 해설을 쓰면서도 헷갈려서 다시 인터넷을 보고 찾아서 이해하고 문제를 해석해서 썼다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1535-%EC%95%88%EB%85%95-with-python/","summary":"📌 BOJ 1535 안녕 💡 조건 첫째 줄에 사람의 수 N(≤ 20). 둘째 줄에 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 입력. 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 입력. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0. 세준이가 얻을 수 있는 최대 기쁨을 출력. 브루트포스 알고리즘, 배낭 알고리즘 유형 문제 🔖 예제 및 실행결과 예제 3 1 21 79 20 30 25 실행결과 50 ⌨️ 문제 풀이 브루트포스 알고리즘 혹은 냅색 알고리즘 으로 풀이할 수 있다.","title":"[BOJ] 1535 안녕 with Python"},{"content":"\n📌 BOJ 9461 파도반 💡 조건 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다.\n(1 ≤ N ≤ 100) 파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 각 테스트 케이스마다 정수 N을 입력받아 P(N)을 출력. Dynamic Programming 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 6 12 실행결과 3 16 ⌨️ 문제 풀이 문제에서 이미 점화식을 짜라고 P(1)부터 P(10)까지 제공해주었다.\n규칙을 찾아 점화식을 세워보자면, dp[i] = dp[i - 3] + dp[i - 2] 이 될 것이다.\n여기서 N의 범위를 살펴보면 1부터 100까지 이다.\n배열의 크기를 101개로 둔 뒤, 문제에서 제공해준 값을 다 넣어도 좋고, 앞의 세개만 넣어 점화식을 통해\n101개의 배열을 채우는 것도 좋다.\n배열을 채우는데에는 큰 시간이 걸리지 않으니, 미리 모두 구해놓고 테스트케이스마다 입력을 받아 처리했다.\n여기서, dp 리스트의 N-1번째를 출력하지 않으면 엉뚱한 답이 나오거나, index에러를 뱉고 죽어버릴 수 있으니 조심하자. 🖥 소스 코드 from sys import stdin dp = [0 for _ in range(101)] dp[0], dp[1], dp[2] = 1, 1, 1 for i in range(3, 101): dp[i] = dp[i - 3] + dp[i - 2] for _ in range(int(stdin.readline())): print(dp[int(stdin.readline()) - 1]) 💾 느낀점 너무나도 상냥하고 친절한 DP문제였다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9461-%ED%8C%8C%EB%8F%84%EB%B0%98-%EC%88%98%EC%97%B4-with-python/","summary":"📌 BOJ 9461 파도반 💡 조건 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다.\n(1 ≤ N ≤ 100) 파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 각 테스트 케이스마다 정수 N을 입력받아 P(N)을 출력. Dynamic Programming 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 2 6 12 실행결과 3 16 ⌨️ 문제 풀이 문제에서 이미 점화식을 짜라고 P(1)부터 P(10)까지 제공해주었다.","title":"[BOJ] 9461 파도반 수열 with Python"},{"content":"\n📌 BOJ 1063 킹 💡 조건 체스판의 크기는 8*8\n체스판에서의 말의 위치는 알파벳 하나와 숫자 하나로 구성되어 있다.\n알파벳은 열(column), 숫자는 행(row)을 상징한다.\n알파벳은 A\n~H, 숫자는 1~\n8까지이다.\n킹이 움직일 수 있는 방법은 8가지가 있으며, 문제에 제시되어 있다.\n체스판에 있는 돌은 킹이 움직인 방향으로 같이 움직인다.\n체스판이나 돌이 입력에서 주어진대로 움직이다가 밖으로 나갈 경우, 그 이동은 건너 뛴다.\n첫째 줄에 킹의 마지막 위치, 둘째 줄에 돌의 마지막 위치를 출력한다.\n구현, 시뮬레이션의 문제\n🔖 예제 및 실행결과 예제 A1 A2 5 B L LB RB LT 실행결과 A1 A2 ⌨️ 문제 풀이 첫 위치를 입력 받고, 주어진 입력의 횟수만큼 이동명령을 받아 처리하면 된다. 대문자 A~H 는 아스키 코드 숫자를 사용하여 처리를 하는 것이 훨씬 편하다. 각 커맨드마다 움직이는 좌표를 수정해주면서 아래의 확인사항을 체크한다. 킹은 움직이지 못하는데 돌이 움직일 수 있는 경우는 그냥 넘어간다. 돌은 움직이지 못하는데 킹이 움직일 수 있는 경우는 그냥 넘어간다. 움직이지 못하는 곳이라면 가볍게 무시하고 다음으로 넘어간다. 🖥 소스 코드 from sys import stdin k, s, n = stdin.readline().rstrip().split() pos_k = [ord(k[0]), int(k[1])] pos_s = [ord(s[0]), int(s[1])] for _ in range(int(n)): com = stdin.readline().rstrip() if com == \u0026#39;R\u0026#39;: if 64 \u0026lt; pos_k[0] + 1 \u0026lt; 73: pos_k[0] += 1 if pos_k == pos_s: if 64 \u0026lt; pos_s[0] + 1 \u0026lt; 73: pos_s[0] += 1 else: pos_k[0] -= 1 elif com == \u0026#39;L\u0026#39;: if 64 \u0026lt; pos_k[0] - 1 \u0026lt; 73: pos_k[0] -= 1 if pos_k == pos_s: if 64 \u0026lt; pos_s[0] - 1 \u0026lt; 73: pos_s[0] -= 1 else: pos_k[0] += 1 elif com == \u0026#39;B\u0026#39;: if 0 \u0026lt; pos_k[1] - 1 \u0026lt; 9: pos_k[1] -= 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] - 1 \u0026lt; 9: pos_s[1] -= 1 else: pos_k[1] += 1 elif com == \u0026#39;T\u0026#39;: if 0 \u0026lt; pos_k[1] + 1 \u0026lt; 9: pos_k[1] += 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] + 1 \u0026lt; 9: pos_s[1] += 1 else: pos_k[1] -= 1 elif com == \u0026#39;RT\u0026#39;: if 0 \u0026lt; pos_k[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] + 1 \u0026lt; 73: pos_k[0] += 1 pos_k[1] += 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] + 1 \u0026lt; 73: pos_s[0] += 1 pos_s[1] += 1 else: pos_k[0] -= 1 pos_k[1] -= 1 elif com == \u0026#39;LT\u0026#39;: if 0 \u0026lt; pos_k[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] - 1 \u0026lt; 73: pos_k[0] -= 1 pos_k[1] += 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] + 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] - 1 \u0026lt; 73: pos_s[0] -= 1 pos_s[1] += 1 else: pos_k[0] += 1 pos_k[1] -= 1 elif com == \u0026#39;RB\u0026#39;: if 0 \u0026lt; pos_k[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] + 1 \u0026lt; 73: pos_k[0] += 1 pos_k[1] -= 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] + 1 \u0026lt; 73: pos_s[0] += 1 pos_s[1] -= 1 else: pos_k[0] -= 1 pos_k[1] += 1 elif com == \u0026#39;LB\u0026#39;: if 0 \u0026lt; pos_k[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_k[0] - 1 \u0026lt; 73: pos_k[0] -= 1 pos_k[1] -= 1 if pos_k == pos_s: if 0 \u0026lt; pos_s[1] - 1 \u0026lt; 9 and 64 \u0026lt; pos_s[0] - 1 \u0026lt; 73: pos_s[0] -= 1 pos_s[1] -= 1 else: pos_k[0] += 1 pos_k[1] += 1 print(\u0026#39;{}\u0026#39;.format(chr(pos_k[0]) + str(pos_k[1]))) print(\u0026#39;{}\u0026#39;.format(chr(pos_s[0]) + str(pos_s[1]))) 💾 느낀점 위치를 저장하는 알파벳과, 숫자를 계산하여 상태를 저장하면 되는 문제였다. 열과 행에 해당하는 알파벳과 숫자를 핸들링하여 상태가 변화할 때 가능한 움직임인지 체크하는 부분이 확실히 헷갈리고 어려웠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1063-%ED%82%B9-with-python/","summary":"📌 BOJ 1063 킹 💡 조건 체스판의 크기는 8*8\n체스판에서의 말의 위치는 알파벳 하나와 숫자 하나로 구성되어 있다.\n알파벳은 열(column), 숫자는 행(row)을 상징한다.\n알파벳은 A\n~H, 숫자는 1~\n8까지이다.\n킹이 움직일 수 있는 방법은 8가지가 있으며, 문제에 제시되어 있다.\n체스판에 있는 돌은 킹이 움직인 방향으로 같이 움직인다.\n체스판이나 돌이 입력에서 주어진대로 움직이다가 밖으로 나갈 경우, 그 이동은 건너 뛴다.\n첫째 줄에 킹의 마지막 위치, 둘째 줄에 돌의 마지막 위치를 출력한다.","title":"[BOJ] 1063 킹 with Python"},{"content":"\n📌 BOJ 18511 큰 수 구성하기 💡 조건 N보다 작거나 같은 자연수 중에서, 집합 K의 원소로만 구성된 가장 큰 수를 출력하는 프로그램을 작성.\n(10 ≤ N ≤ 100,000,000, 1 ≤ K의 원소의 개수 ≤ 3) K의 모든 원소는 1부터 9까지의 자연수로만 구성된다. 첫째 줄에 N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수를 출력 브루트포스 알고리즘, 재귀함수 유형의 문제 🔖 예제 및 실행결과 예제 657 3 1 5 7 실행결과 577 ⌨️ 문제 풀이 n을 문자열로 바꾸었을 때의 길이를 le 라는 변수에 저장한다. n보다 같거나 작은 자연수 중에 주어진 수열 arr로 만들 수 있는\n최댓값을 만들기 위해서 solve() 함수 안에서 수행해야할 로직은 다음과 같다. itertools의 product() 함수를 사용하여 수열 arr로 만들 있는 모든 경우의 k자리의 수를 모두 구해 변수 temp에 저장한다. temp의 원소들을 하나씩 순회하면서, 각 원소에 해당하는 t가 n보다 작거나 같은지 확인한다 위의 조건이 만족될 경우, 결과값 res보다 t가 클 경우 res를 갱신한다. 만약 temp를 모두 순회했지만 res가 갱신이 안되어 -int(1e9) 일 경우, le - 1\n갱신이 되었다면 res반환하고 출력 🖥 소스 코드 from sys import stdin from itertools import product n, k = map(str, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) arr.sort(reverse=True) le = len(n) res = -int(1e9) def solve(le): global res while 1: temp = list(product(arr, repeat=le)) for i in temp: t = int(\u0026#39;\u0026#39;.join(map(str, i))) if int(t) \u0026lt;= int(n): res = max(res, t) if res == -int(1e9): le -= 1 else: return res solve(le) print(res) 💾 느낀점 temp를 모두 순회했을 때 res가 갱신이 안된 경우를 처리하지 못해 골치아팠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-18511-%ED%81%B0-%EC%88%98-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 18511 큰 수 구성하기 💡 조건 N보다 작거나 같은 자연수 중에서, 집합 K의 원소로만 구성된 가장 큰 수를 출력하는 프로그램을 작성.\n(10 ≤ N ≤ 100,000,000, 1 ≤ K의 원소의 개수 ≤ 3) K의 모든 원소는 1부터 9까지의 자연수로만 구성된다. 첫째 줄에 N보다 작거나 같은 자연수 중에서, K의 원소로만 구성된 가장 큰 수를 출력 브루트포스 알고리즘, 재귀함수 유형의 문제 🔖 예제 및 실행결과 예제 657 3 1 5 7 실행결과 577 ⌨️ 문제 풀이 n을 문자열로 바꾸었을 때의 길이를 le 라는 변수에 저장한다.","title":"[BOJ] 18511 큰 수 구성하기 with Python"},{"content":"\n📌 BOJ 20546 🐜 기적의 매매법 🐜 💡 조건 모든 거래는 전량 매수와 전량 매도로 이루어진다. 현재 가지고 있는 현금이 100원이고 주가가 11원이라면 99원어치의 주식을 매수하는 것이다. 단, 현금이 100원 있고 주가가 101원이라면 주식을 살 수 없다. 성민이는 빚을 내서 주식을 하지는 않는다. 3일 연속 가격이 전일 대비 상승하는 주식은 다음날 무조건 가격이 하락한다고 가정한다. 따라서 현재 소유한 주식의 가격이 3일째 상승한다면, 전량 매도한다. 전일과 오늘의 주가가 동일하다면 가격이 상승한 것이 아니다. 3일 연속 가격이 전일 대비 하락하는 주식은 다음날 무조건 가격이 상승한다고 가정한다. 따라서 이러한 경향이 나타나면 즉시 주식을 전량 매수한다. 전일과 오늘의 주가가 동일하다면 가격이 하락한 것이 아니다. 1월 14일의 자산은 (현금 + 1월 14일의 주가 × 주식 수)로 계산한다. 1월 14일 기준 준현이의 자산이 더 크다면 \u0026ldquo;BNP\u0026quot;를, 성민이의 자산이 더 크다면 \u0026ldquo;TIMING\u0026quot;을 출력한다. Stack, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 100 10 20 23 34 55 30 22 19 12 45 23 44 34 38 실행결과 BNP ⌨️ 문제 풀이 문제에서 요구한 33 매매법의 세가지 룰을 먼저 정리하고 구현을 하면 좋습니다. 🖥 소스 코드 from sys import stdin m = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) jm, sm, j, s, status = m, m, 0, 0, [0, \u0026#39;\u0026#39;] yesterday = arr[0] for i in range(14): # 준현 if jm // arr[i] != 0: temp = jm // arr[i] j += (jm // arr[i]) jm -= temp * arr[i] # 성민 change = 0 if yesterday \u0026lt; arr[i]: if status[1] == \u0026#39;-\u0026#39;: change = 1 status[1] = \u0026#39;+\u0026#39; elif yesterday \u0026gt; arr[i]: if status[1] == \u0026#39;+\u0026#39;: change = 1 status[1] = \u0026#39;-\u0026#39; yesterday = arr[i] if change: status[0] = 1 elif status[1] != \u0026#39;\u0026#39;: status[0] += 1 if status[0] \u0026gt;= 3: if status[1] == \u0026#39;+\u0026#39;: if sm // arr[i] != 0: sm += s * arr[i] s = 0 if status[1] == \u0026#39;-\u0026#39;: temp = sm // arr[i] s += (sm // arr[i]) sm -= temp * arr[i] last_day = arr[-1] sm += (s * last_day) jm += (j * last_day) if sm == jm: print(\u0026#34;SAMESAME\u0026#34;) elif sm \u0026gt; jm: print(\u0026#34;TIMING\u0026#34;) else: print(\u0026#34;BNP\u0026#34;) 💾 느낀점 단순한 구현문제였다. 문제를 잘 읽고 문제를 압축하고 정리하는 연습이 필요하겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-20546-%EA%B8%B0%EC%A0%81%EC%9D%98-%EB%A7%A4%EB%A7%A4%EB%B2%95-with-python-copy/","summary":"📌 BOJ 20546 🐜 기적의 매매법 🐜 💡 조건 모든 거래는 전량 매수와 전량 매도로 이루어진다. 현재 가지고 있는 현금이 100원이고 주가가 11원이라면 99원어치의 주식을 매수하는 것이다. 단, 현금이 100원 있고 주가가 101원이라면 주식을 살 수 없다. 성민이는 빚을 내서 주식을 하지는 않는다. 3일 연속 가격이 전일 대비 상승하는 주식은 다음날 무조건 가격이 하락한다고 가정한다. 따라서 현재 소유한 주식의 가격이 3일째 상승한다면, 전량 매도한다. 전일과 오늘의 주가가 동일하다면 가격이 상승한 것이 아니다.","title":"[BOJ] 20546 🐜 기적의 매매법 🐜 with Python"},{"content":"\n📌 BOJ 13900 순서쌍의 곱의 합 💡 조건 N개의 정수 중 서로 다른 위치의 두 수를 뽑는 모든 경우의 두 수의 곱을 구하라. (2 ≤ N ≤ 100,000)\nN개의 정수는 (0 \u0026lt;= x \u0026lt;= 100000) 수학 유형의 문제 🔖 예제 및 실행결과 예제 3 2 3 4 실행결과 26 ⌨️ 문제 풀이 숫자의 개수 N을 입력 받고, N개의 정수를 입력받아 list 에 저장한다.\n결과를 출력할 r 이라는 변수를 생성하고, N개의 정수를 입력받아 저장한 list를 sum() 함수를 사용해\ns에 저장한다. 순서쌍의 곱은 아래와 같이 나타낼 수 있다. 만약 a, b, c, d의 숫자가 있다고 가정한다면\na * b + a * c + a * d로 나타낼 수 있다. 쉽게 표현하자면, ab + ac + ad 로 표현할 수 있다. 2번에서 표현한 식을 결합법칙을 통해 묶어주게 된다면 아래와 같이 변한다.\na(b+c+d) 여기서 (b+c+d) 는 s-a[i]라고 할 수 있다.\n그래서 결국 식은 a[i] * (s - a[i]) 과 같으며, r에 쭉 더해준다. 여기서, ab는 ba와 같은데 표현은 저렇게 할 수 있다는 것을 기억해야한다.\n그러므로 r // 2를 통해 반으로 나누어 주면 답이 출력 될 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) a = list(map(int, stdin.readline().split())) r, s = 0, sum(a) for i in range(n): r += a[i] * (s - a[i]) print(r // 2) 💾 느낀점 결합법칙이 중요합니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-13900-%EC%88%9C%EC%84%9C%EC%8C%8D%EC%9D%98-%EA%B3%B1%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 13900 순서쌍의 곱의 합 💡 조건 N개의 정수 중 서로 다른 위치의 두 수를 뽑는 모든 경우의 두 수의 곱을 구하라. (2 ≤ N ≤ 100,000)\nN개의 정수는 (0 \u0026lt;= x \u0026lt;= 100000) 수학 유형의 문제 🔖 예제 및 실행결과 예제 3 2 3 4 실행결과 26 ⌨️ 문제 풀이 숫자의 개수 N을 입력 받고, N개의 정수를 입력받아 list 에 저장한다.\n결과를 출력할 r 이라는 변수를 생성하고, N개의 정수를 입력받아 저장한 list를 sum() 함수를 사용해","title":"[BOJ] 13900 순서쌍의 곱의 합 with Python"},{"content":"\n📌 BOJ 14620 꽃길 💡 조건 꽃밭은 N * N 의 격자 모양이고, 씨앗을 (1, 1) ~ (N, N)의 지점 중 한곳에 심을 수 있다.\n1년 후 상하좌우로 꽃잎이 펼쳐진다. 어떤 씨앗이 꽃이 핀 뒤, 다른 꽃잎 혹은 꽃술과 닿게 될 경우 꽃이 둘 다 죽어버린다. 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하려고 한다.\n진아가 꽃을 심을 수 있는 최소비용을 구하는 문제이다. 한 변의 길이 N(6 ≤ N ≤ 10) 화단의 지점당 가격(0 ≤ G ≤ 200) 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 0 2 3 3 4 1 1 1 1 1 1 0 0 1 1 1 1 3 9 9 0 1 99 9 11 3 1 0 3 12 3 0 0 0 1 실행결과 12 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n = int(stdin.readline()) arr = [] res = [int(1e9)] visited = set() dx, dy = [1, 0, 0, -1], [0, 1, -1, 0] for _ in range(n): arr.append(list(map(int, stdin.readline().split()))) def solve(cnt, cost, v): if cnt == 3: res[0] = min(res[0], cost) else: for i in range(1, n - 1): for j in range(1, n - 1): temp_visit = set() temp_visit.add((i, j)) tf = 1 temp = arr[i][j] for k in range(4): nx, ny = i + dx[k], j + dy[k] if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; n: if (nx, ny) not in v: temp += arr[nx][ny] temp_visit.add((nx, ny)) else: tf = 0 break else: tf = 0 break if tf and temp_visit: v.update(temp_visit) solve(cnt + 1, cost + temp, v) v -= temp_visit solve(0, 0, visited) print(*res) ⌨️ 문제 풀이 DFS 알고리즘을 사용했다. 심은 씨앗이 3개가 되지 않으면, 계속 씨앗을 심어준다.\n전체 좌표를 순회하면서 작업을 한다. 씨앗을 심은 부분을 기준으로 상하좌우의 좌표를 visited 집합 자료형에 넣어주어서,\nvisited의 좌표들에도 씨앗을 심을 수 없게 한다. solve(심은 씨앗의 갯수, 화단을 빌리는 비용, 꽃잎이 피어 심을 수 없는 구역들) 에 심은 씨앗의 개수를 하나씩 늘려준다. 심은 씨앗이 3개가 된다면 최소비용인지 확인하여 res 값에 저장한다. 💾 느낀점 ","permalink":"https://jxun-h.github.io/posts/ps/boj-14620-%EA%BD%83%EA%B8%B8-with-python/","summary":"📌 BOJ 14620 꽃길 💡 조건 꽃밭은 N * N 의 격자 모양이고, 씨앗을 (1, 1) ~ (N, N)의 지점 중 한곳에 심을 수 있다.\n1년 후 상하좌우로 꽃잎이 펼쳐진다. 어떤 씨앗이 꽃이 핀 뒤, 다른 꽃잎 혹은 꽃술과 닿게 될 경우 꽃이 둘 다 죽어버린다. 서로 다른 세 씨앗을 모두 꽃이 피게하면서 가장 싼 가격에 화단을 대여하려고 한다.\n진아가 꽃을 심을 수 있는 최소비용을 구하는 문제이다. 한 변의 길이 N(6 ≤ N ≤ 10) 화단의 지점당 가격(0 ≤ G ≤ 200) 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 1 0 2 3 3 4 1 1 1 1 1 1 0 0 1 1 1 1 3 9 9 0 1 99 9 11 3 1 0 3 12 3 0 0 0 1 실행결과 12 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n = int(stdin.","title":"[BOJ] 14620 꽃길 with Python"},{"content":"\n📌 BOJ 1411 비슷한 단어 💡 조건 문자열 A를 숌스럽게 바꾸어 B로 만들었다면, 그 단어는 비슷한 단어라고한다. 숌스럽게 바꾼다는 것은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다. 단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 문제. 단어의 길이는 최대 50\nN은 100보다 작거나 같은 자연수이다.\n모든 단어의 길이는 같고, 중복되지 않는다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 12 cacccdaabc cdcccaddbc dcdddbccad bdbbbaddcb bdbcadbbdc abaadcbbda babcdabbac cacdbaccad dcddabccad cacccbaadb bbcdcbcbdd bcbadcbbca 실행결과 13 ⌨️ 문제 풀이 가능한 각 단어들의 쌍을 combinations 함수를 사용해 만들고 순차적으로 순회한다.\n이미 변환했던 단어를 저장할 집합 자료형 use를 생성하고, 단어의 길이만큼 순회하면서 아래의 조건에 해당하는지 확인한다.\n순회하고 있는 알파벳이 서로 같지않고, a[i]번 째 단어가 사용되지 않고, change에 없다. 2번에 있는 조건이 참일 경우\nchange[a[i]] = b[i] use.add(b[i]) a[i] = b[i] 2번에 있는 조건이 거짓일 경우, a[i]가 change에 있는지 확인한다.\n참일 경우, a[i] = change[a[i]] 4번의 조건이 거짓일 경우, a[i]가 use에 있는지 확인한다.\n있는 경우에 tf를 False로 저장하고, 반복문을 멈춘다.\n없는 경우는 아래의 코드를 실행한다.\nchange[a[i]] = b[i] use.add(b[i]) 순회를 마치면 a와 b가 같은지, tf가 True인지 확인한다.\n참이면, 문자열 쌍을 배열에 저장한다.\n배열의 길이를 출력한다.\n🖥 소스 코드 from sys import stdin from itertools import combinations words = [] res = set() tc = int(stdin.readline()) if tc == 1: print(res) else: for _ in range(tc): words.append(stdin.readline().rstrip()) for pair in list(set(combinations(words, 2))): change = dict() use = set() tf = True x, y = pair a, b = pair a, b = list(a), list(b) n, m = len(a), len(b) if n != m: continue else: for i in range(n): if a[i] != b[i] and b[i] not in use and a[i] not in change: change[a[i]] = b[i] use.add(b[i]) a[i] = b[i] else: if a[i] in change: a[i] = change[a[i]] else: if a[i] in use: tf = False break else: change[a[i]] = b[i] use.add(b[i]) if a == b and tf: res.add((x, y)) print(len(res)) 💾 느낀점 실버 II 티어의 문제인데, 생각보다 조건이 까다로워서 구현하는데에 애를 먹었다. 생각보다 부르트포스 알고리즘 유형이 풀기 까다롭다는 생각을 하게 된 문제였다 ","permalink":"https://jxun-h.github.io/posts/ps/boj-1411-%EB%B9%84%EC%8A%B7%ED%95%9C-%EB%8B%A8%EC%96%B4-with-python/","summary":"📌 BOJ 1411 비슷한 단어 💡 조건 문자열 A를 숌스럽게 바꾸어 B로 만들었다면, 그 단어는 비슷한 단어라고한다. 숌스럽게 바꾼다는 것은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다. 단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 문제. 단어의 길이는 최대 50\nN은 100보다 작거나 같은 자연수이다.\n모든 단어의 길이는 같고, 중복되지 않는다. 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 12 cacccdaabc cdcccaddbc dcdddbccad bdbbbaddcb bdbcadbbdc abaadcbbda babcdabbac cacdbaccad dcddabccad cacccbaadb bbcdcbcbdd bcbadcbbca 실행결과 13 ⌨️ 문제 풀이 가능한 각 단어들의 쌍을 combinations 함수를 사용해 만들고 순차적으로 순회한다.","title":"[BOJ] 1411 비슷한 단어 with Python"},{"content":"\n📌 BOJ 1515 수 이어 쓰기 💡 조건 1부터 N까지 모든 수를 차례대로 공백없이 한 줄에 다 썼다. 다솜이가 숫자의 일부를 지웠고, 지워지기 전의 숫자를 다시 쓰려고 하니 N이 기억나지 않는다. 남은 수를 이어 붙인 수가 주어질 경우, N의 최솟값을 구하는 문제. 일부 숫자를 지우고 남은 수를 이어붙인 수가 주어지며, 이 수는 최대 3000자리. 구현, 문자열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 00000000000000000000000000000000000000000000000000000000000000000000000 실행결과 400 ⌨️ 문제 풀이 1부터 수를 늘려가면서 완전탐색을 실행하면 된다.\ni, s 는 각각 1과 '' 로 초기화 한 뒤, while 1: 반복으로 i를 늘려주며 순회한다. s 에 str(i)를 이어 붙이고 check() 함수에서 검사를 실시한다. check 함수에서는 사용자에게 입력받은 data와 while 반복문을 통해서 이어 붙인 숫자의 길이를 검사한다.\n만약, 길이가 같지 않으면 ' '를 리턴해준다.\n만약, 길이가 같다면 data 배열과 이어 붙인 숫자의 각 자리를 검사하여 틀린것은 pop() 으로 빼준다\n길이가 같은 경우, 각 자리가 모두 동일했다면 chk 변수는 0이고 data의 길이만큼 반환\n길이가 다른 경우, 각 자리를 검사하고 pop()을 사용해 숫자를 뺀 이어 붙인 수를 반환 check 함수에서 반환받은 tf 변수는 ' ' 혹은 3번의 결과값을 가지고 있다.\n만약 tf 변수가 data의 길이와 tf의 길이 중 짧은 길이만큼 잘라냈을 때, data의 길이와 같다면\n현재의 i를 출력해주고 while을 종료한다. 4번에서 종료가 안되었고 tf 가 ' '과 다르다면, s는 tf로 저장해주고, i 를 1만큼 증가시켜준다. 이 때 tf는 이어 붙인 수에서 숫자를 지운 상태이다.* 4번에서 종료가 안되었고, tf 가 ' '과 같다면, i 를 1만큼 증가시켜준다. data 변수와 단 한자리도 같지 않아 이어 붙인 수가 pop()에 의해 다 뽑힌 것.* 🖥 소스 코드 from sys import stdin data = stdin.readline().rstrip() s, i = \u0026#39;\u0026#39;, 1 def check(s): t = list(s) k = list(data) while 1: if len(t) \u0026lt; len(data): return \u0026#39; \u0026#39; else: i = 0 chk = 0 while 1: if i \u0026gt;= len(k) or i \u0026gt;= len(t): if chk: return \u0026#39;\u0026#39;.join(t) else: return \u0026#39;\u0026#39;.join(t[:len(data)]) if t[i] != k[i]: t.pop(i) chk = 1 else: i += 1 while 1: s += str(i) # check tf = check(s) if tf[:min(len(tf), len(data))] == data: print(i) break # tf = False if tf != \u0026#39; \u0026#39;: s = tf i += 1 else: i += 1 💾 느낀점 틀렸습니다와 런타임에러가 날 괴롭혔다.\n그 이유는 아래와 같다. 문자열을 이어 붙이다 보면 10의 자리를 붙이게 되는데 그 순간 data 변수의 길이보다 이어 붙인 수의 길이가 길어질 때 검사하다가 오류. 반환할 때도 이미 data 변수와 길이가 같거나 혹은 길이가 길게나와서 답도 제대로 안나왔다. 인덱싱에 매우 약하다. 이를 극복하려면 반복 밖에는 없을 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1515-%EC%88%98-%EC%9D%B4%EC%96%B4-%EC%93%B0%EA%B8%B0-with-python/","summary":"📌 BOJ 1515 수 이어 쓰기 💡 조건 1부터 N까지 모든 수를 차례대로 공백없이 한 줄에 다 썼다. 다솜이가 숫자의 일부를 지웠고, 지워지기 전의 숫자를 다시 쓰려고 하니 N이 기억나지 않는다. 남은 수를 이어 붙인 수가 주어질 경우, N의 최솟값을 구하는 문제. 일부 숫자를 지우고 남은 수를 이어붙인 수가 주어지며, 이 수는 최대 3000자리. 구현, 문자열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 00000000000000000000000000000000000000000000000000000000000000000000000 실행결과 400 ⌨️ 문제 풀이 1부터 수를 늘려가면서 완전탐색을 실행하면 된다.","title":"[BOJ] 1515 수 이어 쓰기 with Python"},{"content":"\n📌 BOJ 2615 오목 💡 조건 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있다. board의 크기는 19 * 19\n검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시\n가로, 세로 또는 대각선 방향 모두 포함해서 같은 색의 바둑돌이 5개 놓여져 있다면 승리한다.\n5개 초과 또는 미만의 개수는 승리할 수 없다\n검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성.\n검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력\n은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알의 가로줄, 세로줄 번호를 출력한다.\n세로로 놓인 경우, 그 중 가장 위에 있는 바둑알의 가로, 세로줄 번호를 출력한다. 브루트포스 알고리즘 \u0026amp; 구현 유형의 문제\n🔖 예제 및 실행결과 예제 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 2 2 2 1 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 실행결과 1 3 2 ⌨️ 문제 풀이 바둑판은 19 * 19의 크기로 제한되어 있다. solve() 함수에서 이중 반복문으로 바둑판의 칸을 모두 순회한다.\n순회하면서 검은 바둑돌이 놓여진 곳과 흰 바둑알이 놓여진 곳을 발견하게 된다면, check() 함수를 호출한다.\ncheck(돌의 색, x 좌표, y 좌표)\n의 형식으로 호출하여 반환 받은 결과가 빈 배열이 아니라면, 이긴 바둑 돌의 색의 번호와 바둑돌의 좌표들을 반환한다. check() 함수는 오른쪽, 아래, 좌측 아래, 우측 아래의 네 방향을 검사한다.\n입력받은 좌표를 기준으로 위에서 말한 네 방향을 검사하면서, 넘겨받은 바둑돌의 색깔과 일치하는 돌이 있다면\nres 집합 자료형 변수에 넣어주고, 5개인지 확인하여 맞다면 res를 list로 변환하여 반환, 아니라면 반복문을 종료한다.\nsolve() 함수 호출 후 작업이 끝났다면, code 와 v를 반환받게 되는데,\ncode는 이긴 바둑돌을 뜻하며 v는 바둑돌의 좌표들을 뜻한다.\n세로로 세워진 바둑돌인지 확인 한 후, tf의 값에 따라 v를 정렬하고 이긴 바둑돌의 색과 좌표를 출력한다.\ntf 가 1일 때, 세로로 놓여진 다섯개의 바둑돌이다.\ntf 가 0일 때, 세로가 아닌 방향으로 놓여진 바둑돌이다.\nsolve() 함수에 반환받은 v가 False 라면 무승부이기 때문에 0을 출력한다.\n🖥 소스 코드 from sys import stdin dx, dy = [0, 1, 1, 1], [1, 0, -1, 1] board = [] visited = [set() for _ in range(4)] for i in range(19): board.append(list(map(int, stdin.readline().split()))) def check(code, i, j): for z in range(4): cnt = 1 res = set() res.add((i, j)) nx, ny = i + dx[z], j + dy[z] while 1: if 0 \u0026lt;= nx \u0026lt; 19 and 0 \u0026lt;= ny \u0026lt; 19: if board[nx][ny] == code and ((nx, ny) not in visited[z]): cnt += 1 res.add((nx, ny)) visited[z].add((nx, ny)) nx += dx[z] ny += dy[z] else: if cnt == 5: return list(res) else: break else: if cnt == 5: return list(res) break return [] def solve(): for i in range(19): for j in range(19): if board[i][j] == 1: v = check(1, i, j) if v: return 1, v elif board[i][j] == 2: v = check(2, i, j) if v: return 2, v return 0, False code, v = solve() if v is False: print(0) else: tf = 1 x = v[0][1] for i in range(1, 5): if x != v[i][1]: tf = 0 break if tf: v.sort(key=lambda x: (x[0])) print(code) print(*(v[0][0] + 1, v[0][1] + 1)) else: print(code) v.sort(key=lambda x: (x[1])) print(*(v[0][0] + 1, v[0][1] + 1)) 💾 느낀점 바둑돌이 여섯개 일 때 조건문을 통해 걸러내는 법에서 헤맸다. 구현을 할 때 조금 더 꼼꼼히 생각해보자. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2615-%EC%98%A4%EB%AA%A9-with-python/","summary":"📌 BOJ 2615 오목 💡 조건 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있다. board의 크기는 19 * 19\n검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시\n가로, 세로 또는 대각선 방향 모두 포함해서 같은 색의 바둑돌이 5개 놓여져 있다면 승리한다.\n5개 초과 또는 미만의 개수는 승리할 수 없다\n검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성.\n검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력","title":"[BOJ] 2615 오목 with Python"},{"content":"\n📌 Programmers 블록 이동하기 with Python 💡 조건 board의 한 변의 길이는 5 이상 100 이하.\nboard의 원소는 0(이동가능 블록) 또는 1(이동불가 벽). 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어진다. 로봇은 회전할 수 있다. BFS, 시뮬레이션의 문제 (N, N) 좌표까지 도달하는 최소시간을 구하는 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]])) 실행결과 7 🖥 소스 코드 from collections import deque def get_next_pos(pos, board): next_pos = [] pos = list(pos) pos1_x, pos1_y, pos2_x, pos2_y = pos[0][0], pos[0][1], pos[1][0], pos[1][1] dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1] for i in range(4): pos1_next_x, pos1_next_y, pos2_next_x, pos2_next_y = pos1_x + dx[i], pos1_y + dy[i], pos2_x + dx[i], pos2_y + dy[i] if board[pos1_next_x][pos1_next_y] == 0 and board[pos2_next_x][pos2_next_y] == 0: next_pos.append({(pos1_next_x, pos1_next_y), (pos2_next_x, pos2_next_y)}) if pos1_x == pos2_x: for i in [-1, 1]: if board[pos1_x + i][pos1_y] == 0 and board[pos2_x + i][pos2_y] == 0: next_pos.append({(pos1_x, pos1_y), (pos1_x + i, pos1_y)}) next_pos.append({(pos2_x, pos2_y), (pos2_x + i, pos2_y)}) elif pos1_y == pos2_y: for i in [-1, 1]: if board[pos1_x][pos1_y + i] == 0 and board[pos2_x][pos2_y + i] == 0: next_pos.append({(pos1_x, pos1_y), (pos1_x, pos1_y + i)}) next_pos.append({(pos2_x, pos2_y), (pos2_x, pos2_y + i)}) return next_pos def solution(board): n = len(board) new_board = [[1] * (n + 2) for _ in range(n + 2)] for i in range(n): for j in range(n): new_board[i + 1][j + 1] = board[i][j] q = deque() visited = [] pos = {(1, 1), (1, 2)} q.append((pos, 0)) visited.append(pos) while q: pos, cost = q.popleft() if (n, n) in pos: return cost for next_pos in get_next_pos(pos, new_board): if next_pos not in visited: q.append((next_pos, cost + 1)) visited.append(next_pos) return 0 ⌨️ 문제 풀이 가장 먼저, (n * n) 크기의 맵을 (n + 2) * (n + 2) 맵으로 새로 만들어\n맵 주변을 1로 둘러주어 이동하지 못하는 곳을 확실히 만들어준다. 시작 위치는 {(1, 1), (1, 2)} 로 pos에 저장한 뒤 큐에 넣는다.\n물론 방문한 기록을 남길 visited 리스트에도 저장한다. BFS의 방식으로 Queue가 빌 때까지 순회를 한다.\n단, 현재 위치에서 이동이 가능하거나 회전이 가능한 위치를 큐에 저장한다. 3번에서 말한 이동 및 회전이 가능한 좌표는 함수 get_next_pos()에서 반환하는 좌표값들을 기준으로 한다. get_next_pos 에서는 현재 위치에서 이동 및 가능한 좌표를 반환하는데, 아래의 조건을 잘 확인해야한다. 상하좌우 네 방향으로 이동이 가능한지 현재 로봇이 가로로 놓여져 있는 경우 회전이 가능한지 현재 로봇이 세로로 놓여져 있는 경우 회전이 가능한지 get_next_pos 에서 반환받은 좌표들 중, 이미 방문한 장소가 아니라면 방문처리를 하고 cost(걸린 시간) 을 큐와 함께 넣어준다. 💾 느낀점 로봇이 90도 회전하는 좌표에 대해서 처리하고 반환하는 것이 어려웠다. 좌표 계산이 헷갈려 힘이 들었다. 좌표 및 인덱싱에 대해 연습이 많이 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EB%B8%94%EB%A1%9D-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-with-python/","summary":"📌 Programmers 블록 이동하기 with Python 💡 조건 board의 한 변의 길이는 5 이상 100 이하.\nboard의 원소는 0(이동가능 블록) 또는 1(이동불가 벽). 로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어진다. 로봇은 회전할 수 있다. BFS, 시뮬레이션의 문제 (N, N) 좌표까지 도달하는 최소시간을 구하는 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]])) 실행결과 7 🖥 소스 코드 from collections import deque def get_next_pos(pos, board): next_pos = [] pos = list(pos) pos1_x, pos1_y, pos2_x, pos2_y = pos[0][0], pos[0][1], pos[1][0], pos[1][1] dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1] for i in range(4): pos1_next_x, pos1_next_y, pos2_next_x, pos2_next_y = pos1_x + dx[i], pos1_y + dy[i], pos2_x + dx[i], pos2_y + dy[i] if board[pos1_next_x][pos1_next_y] == 0 and board[pos2_next_x][pos2_next_y] == 0: next_pos.","title":"[Programmers] 블록 이동하기 with Python"},{"content":"\n📌 BOJ 11497 통나무 건너뛰기 💡 조건 첫 줄에 통나무의 개수를 나타내는 정수 (5 ≤ N ≤ 10,000)\n둘째 줄에 각 통나무의 높이를 나타내는 정수 (1 ≤ Li ≤ 100,000) 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다.\n가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 그리디 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 3 7 13 10 12 11 10 11 12 5 2 4 5 7 9 8 6 6 6 6 6 6 6 6 실행결과 1 4 0 ⌨️ 문제 풀이 단순히 정렬을 해도 되지만, 첫 통나무와 마지막 통나무가 인접해있다는 조건이 있다. 1번에서 말한 조건 때문에, 가장 큰 값을 기준으로 양쪽에 점점 작게 배치를 하면\n크기의 차이를 가장 많이 줄일 수 있다. 즉, 인덱스 값이 2씩 차이나는 값들 중 가장 큰 값이 최대 높이 차가 된다. 🖥 소스 코드 from sys import stdin for _ in range(int(stdin.readline())): n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() res = 0 for i in range(2, n): res = max(res, abs(arr[i] - arr[i-2])) print(res) 💾 느낀점 문제 풀이에서 2번과 3번에 대해서 이해하지 못해서 힘이 들었다. 이해하고 다시 풀어보기를 반복해야할 문제이다. 2021/12/06 다시 풀어보았는데 또 틀렸다. 해설을 보니 기억이 나긴하는데 또 이해가 안된다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-11497-%ED%86%B5%EB%82%98%EB%AC%B4-%EA%B1%B4%EB%84%88%EB%9B%B0%EA%B8%B0-with-python/","summary":"📌 BOJ 11497 통나무 건너뛰기 💡 조건 첫 줄에 통나무의 개수를 나타내는 정수 (5 ≤ N ≤ 10,000)\n둘째 줄에 각 통나무의 높이를 나타내는 정수 (1 ≤ Li ≤ 100,000) 통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다.\n가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 그리디 알고리즘유형의 문제 🔖 예제 및 실행결과 예제 3 7 13 10 12 11 10 11 12 5 2 4 5 7 9 8 6 6 6 6 6 6 6 6 실행결과 1 4 0 ⌨️ 문제 풀이 단순히 정렬을 해도 되지만, 첫 통나무와 마지막 통나무가 인접해있다는 조건이 있다.","title":"[BOJ] 11497 통나무 건너뛰기 with Python"},{"content":"\n📌 Programmers 외벽 점검 with Python 💡 조건 외벽의 총 둘레길이 (1 \u0026lt;= n \u0026lt;= 200)\n취약 지점의 위치가 담긴 배열 (1\u0026lt; = weak \u0026lt;= 15) 서로 다른 두 취약점의 위치가 같을 경우는 없다. 취약지점의 위치는 오름차순이다. (0 \u0026lt;= weak의 원소 \u0026lt;= n-1) 친구가 1시간 동안 이동할 수 있는 거리 (1\u0026lt;= dist \u0026lt;= 8) 친구들을 최소한으로 투입시켜서 외벽 점검을 해야한다.\n만약 친구들이 모두 투입되어도 외벽을 모두 점검할 수 없다면, -1을 출력. 순열, 브루트포스 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 print(solution(12, [1, 5, 6, 10], [1, 2, 3, 4], 2)) 실행결과 2 ⌨️ 문제 풀이 점검 해야할 외벽의 길이를 구하기 위해 weak의 길이를 leng 이라는 변수에 담아준다.\n총 n 만큼의 외벽이 있으니, weak 의 길이만큼 순회하면서 weak 의 원소에 n을 더하여\n원형 모양의 외벽을 펼쳐준다고 생각하자.\nanswer의 값은 점검을 투입할 수 있는 친구들의 수(dist의 길이)보다 1 많게 저장한다.\n이 과정이 있어야 모두 투입시켜도 안될 때 -1을 출력하게 할 수 있다.\n취약점 어디서부터 시작할지에 따라서 인원의 수가 적어질 수도, 많아질 수도 있다.\n그렇기 때문에 start(출발지점) 을 weak의 길이만큼 순회시켜 돌게하고,\n친구들이 투입될 순서는 permutations 함수를 통해 변경한다.\ncount = 0으로 초기화 한 뒤, position을 정한다.\n취약점 배열에서 start 번째에서\n친구들의 1시간동안 이동거리를 permutations로 뽑아낸 배열의 count - 1 번째의 값을\n빼준 것이 position 값이다.\n그렇다면, 취약점 시작부분(start) 부터 취약점 시작부분(start) + 취약점의 개수(leng)까지 순회하면서(index)\n현재 포지션 값이 취약점배열의 index에 해당하는 값보다 작다면 count += 1 을 해준다.\ncount 가 혹시 친구의 수를 넘었다면 바로 중단한다.\n그게 아니라면 작업을 한 후, position을 갱신한다.\nanswer 와 count 중에 가장 작은 것을 answer에 담아 갱신한 뒤, answer가 dist의 길이보다 크다면 -1을 반환하고\n그게 아니라면 answer를 반환한다.\n🖥 소스 코드 from itertools import permutations def solution(n, weak, dist): leng = len(weak) for x in range(leng): weak.append(weak[x] + n) answer = len(dist) + 1 for start in range(leng): for friends in list(permutations(dist, len(dist))): count = 0 position = weak[start] - friends[count - 1] for index in range(start, start + leng): if position \u0026lt; weak[index]: count += 1 if count \u0026gt; len(dist): break position = weak[index] + friends[count - 1] answer = min(answer, count) if answer \u0026gt; len(dist): return -1 return answer 💾 느낀점 외벽을 평면으로 펼칠 아이디어를 떠올리지 못하고 해설을 본 후 큰 충격을 받았다. 이후, 외벽 점점을 해야할 취약점 중 한 부분을 골라 취약점의 길이만큼 점검하는 로직을 구현하는데에\n많은 노력과 긴 시간이 필요했다. 스스로 구현이 약하다는 것을 알고 있다. 조금 더 구현할 때 그림을 그리긋 설계하고, 짧아도 구현계획을 써내려가야겠다. 스스로 검증하는 부분에서 큰 약점이 있다는 것을 느꼈다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%99%B8%EB%B2%BD-%EC%A0%90%EA%B2%80-with-python/","summary":"📌 Programmers 외벽 점검 with Python 💡 조건 외벽의 총 둘레길이 (1 \u0026lt;= n \u0026lt;= 200)\n취약 지점의 위치가 담긴 배열 (1\u0026lt; = weak \u0026lt;= 15) 서로 다른 두 취약점의 위치가 같을 경우는 없다. 취약지점의 위치는 오름차순이다. (0 \u0026lt;= weak의 원소 \u0026lt;= n-1) 친구가 1시간 동안 이동할 수 있는 거리 (1\u0026lt;= dist \u0026lt;= 8) 친구들을 최소한으로 투입시켜서 외벽 점검을 해야한다.\n만약 친구들이 모두 투입되어도 외벽을 모두 점검할 수 없다면, -1을 출력.","title":"[Programmers] 외벽 점검 with Python"},{"content":"\n📌 BOJ 2841 외계인의 기타 연주 💡 조건 멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생. 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000) 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다. 손가락의 가장 적게 움직이는 회수를 구하는 프로그램을 작성. Stack, 자료구조 유형의 문제 🔖 예제 및 실행결과 예제 7 15 1 5 2 3 2 5 2 7 2 4 1 5 1 3 실행결과 9 ⌨️ 문제 풀이 기타의 줄을 의미하는 stack 2차원 리스트를 생성한다.\n스택의 각 원소에 해당하는 리스트에는 누르고 있는 프렛 숫자 데이터가 저장된다. 입력을 받으면서, 프렛 숫자를 각 줄에 해당하는 리스트에 저장한다. 입력받은 줄에 해당하는 리스트에 이미 누르고 있는 프렛에 해당하는 데이터가 있다면,\n입력받은 프렛 번호가 이미 누르고 있는 프렛의 번호보다 작아질 때까지 pop()을 해주면서 res += 1을 해준다.\n만약 pop() 을 할 필요가 없다면 바로 추가해준다. 프렛의 번호가 겹치면 더 해당 줄에 프렛 번호를 추가하지 않고, 겹치지 않는다면 추가하고, res += 1을 해준다. n만큼 반복했다면, res 를 출력한다. 🖥 소스 코드 from sys import stdin import heapq n, p = map(int, stdin.readline().split()) stack = [[] for _ in range(7)] res = 0 for _ in range(n): j, f = map(int, stdin.readline().split()) if not stack[j]: heapq.heappush(stack[j], f) res += 1 elif stack[j][-1] \u0026lt; f: heapq.heappush(stack[j], f) res += 1 elif stack[j][-1] \u0026gt; f: while 1: if not stack[j]: res += 1 stack[j].append(f) break if stack[j][-1] \u0026lt;= f: if stack[j][-1] \u0026lt; f: heapq.heappush(stack[j], f) res += 1 break stack[j].pop() res += 1 print(res) 💾 느낀점 stack 자료구조를 활요하는 문제였다. 아이디어를 떠올리기까지 시간이 꽤 걸린 문제였다. stack 의 개념을 알면, 이를 다양한 방면으로 활용할 수 있다는 것을 알게 해주었다. 자료구조 문제는 좋은 아이디어를 떠올릴 수 있게 많이 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2841-%EC%99%B8%EA%B3%84%EC%9D%B8%EC%9D%98-%EA%B8%B0%ED%83%80-%EC%97%B0%EC%A3%BC-with-python/","summary":"📌 BOJ 2841 외계인의 기타 연주 💡 조건 멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생. 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000) 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다.","title":"[BOJ] 2841 외계인의 기타 연주 with Python"},{"content":"\n📌 BOJ 6118 숨바꼭질 💡 조건 헛간의 개수 (2 \u0026lt;= N \u0026lt;= 20,000), 1부터 세아린다. 모든 헛간은 (1\u0026lt;= M \u0026lt;= 50,000)개의 양방향 길로 이어져 있다. 냄새는 1번 헛간에서의 거리가 멀어질수록 감소한다.\n거리 = 지나야 하는 길의 최소 개수. 숨어야 하는 가장 거리가 먼 헛간 번호, 가장 거리가 먼 헛간까지의 거리, 가장 거리가 먼 헛간과 같은 거리를 가지는 헛간의 수\n를 차례대로 출력하며, 가장 거리가 먼 헛간 번호가 여러개라면 가장 작은 수를 출력한다. **너비 우선 탐색(BFS)**유형의 문제 🔖 예제 및 실행결과 예제 6 7 3 6 4 3 3 2 1 3 1 2 2 4 5 2 실행결과 4 2 3 ⌨️ 문제 풀이 양방향으로 움직일 수 있는 노드들을 연결하기 위해 2차원 리스트인 arr을 생성한 후 데이터를 입력한다. 결과 값을 저장하고, 헛간의 번호를 의미하는 res 2차원 리스트를 생성한다.\n가장 먼 헛간의 거리를 저장할 max_dist 변수도 생성한다. 너비 우선 탐색 알고리즘을 호출하는데, 큐에는 (거리, 노드번호)를 넣어준다.\n큐가 빌 때까지 반복하면서, 해당 헛간과 연결되어 있는 헛간을 순차적으로 방문한다.\n큐에서 데이터를 pop() 하여 나온 거리 데이터가 현재 max_dist 보다 크다면 갱신한다. 방문한 헛간은 이미 방문했던 헛간이라는 정보를 저장하기 위해 visited 집합 자료형에 노드번호를 저장한다. 헛간의 거리는 모두 1씩이기에, 큐에 (현재 헛간과의 거리 + 1, 노드번호) 를 저장한다. res 리스트에 거리 + 1에 해당하는 리스트에 노드 번호를 저장한다.\nres 리스트에는 가장 먼 거리에 해당하는 원소 리스트에 같은 거리를 가진 헛간의 번호들이 저장된다. 문제에서 요구한 것들을 출력한다.\n숨어야 하는 헛간의 번호 = min(res[max_dist])\n숨어야 하는 헛간까지의 거리 = max_dist\n숨어야 하는 헛간까지의 거리와 같은 거리를 가진 헛간들 = len(res[max_dist]) 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) arr = [[] for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) arr[a].append(b) arr[b].append(a) res = [[] for _ in range(20001)] max_dist = -1e9 def bfs(n): global max_dist q = deque() q.append((0, n)) visited = set() visited.add(n) while q: dist, now = q.popleft() max_dist = max(max_dist, dist) for node in arr[now]: if node not in visited: visited.add(node) q.append((dist + 1, node)) res[dist + 1].append(node) bfs(1) print(min(res[max_dist]), max_dist, len(res[max_dist])) 💾 느낀점 BFS 응용 문제이기 때문에 풀이를 하는데에는 오래 걸리지 않았다. 그래프 이론 및 BFS 문제는 조금씩 더 풀어서 내것으로 만들어도 더 좋을 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-6118-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88-with-python/","summary":"📌 BOJ 6118 숨바꼭질 💡 조건 헛간의 개수 (2 \u0026lt;= N \u0026lt;= 20,000), 1부터 세아린다. 모든 헛간은 (1\u0026lt;= M \u0026lt;= 50,000)개의 양방향 길로 이어져 있다. 냄새는 1번 헛간에서의 거리가 멀어질수록 감소한다.\n거리 = 지나야 하는 길의 최소 개수. 숨어야 하는 가장 거리가 먼 헛간 번호, 가장 거리가 먼 헛간까지의 거리, 가장 거리가 먼 헛간과 같은 거리를 가지는 헛간의 수\n를 차례대로 출력하며, 가장 거리가 먼 헛간 번호가 여러개라면 가장 작은 수를 출력한다.","title":"[BOJ] 6118 숨바꼭질 with Python"},{"content":"\n📌 BOJ 2304 창고 다각형 💡 조건 기둥의 개수를 나타내는 정수 (1 \u0026lt;= N \u0026lt;= 1000)\n각 기둥의 왼쪽 면의 위치를 나타내는 정수 (1 \u0026lt;= L \u0026lt;= 1000)\n각 기둥의 높이를 나타내는 정수 (1 \u0026lt;= H \u0026lt;= 1000)\n창고 다각형의 면적을 구하는 문제\n모든 기둥이 들어가는 창고를 지으려고 할 때, 지붕이 될 수 있는 조건은 아래와 같다.\n지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다. 지붕의 가장자리는 땅에 닿아야 한다. 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다. 자료구조, 브루트포스 알고리즘유형의 문제\n🔖 예제 및 실행결과 예제 7 2 4 11 4 15 8 4 6 5 3 8 10 13 6 실행결과 98 ⌨️ 문제 풀이 간단하게 생각하면 매우 좋은 문제이다. 문제에서 제시된 그림에서도 보이듯, 기둥들 중에서 가장 높이 값이 큰 기둥이 있다.\n그 가장 높이가 높은 기둥을 중심으로 나누어서 왼쪽에서 오른쪽으로 면적을 구하고, 오른쪽에서 왼쪽으로 면적을 구해 더한 후 출력하면 된다. index를 잘 구별해서 써야 헷길리지 않을 수 있다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) max_pillar = -1e9 idx = 0 arr = [[] for _ in range(1001)] res = 0 last_idx = 0 for _ in range(n): a, b = map(int, stdin.readline().split()) if max_pillar \u0026lt; b: max_pillar = b idx = a arr[a].append(b) last_idx = max(last_idx, a) part1 = arr[:idx+1] part2 = arr[idx+1:last_idx+1] now = 0 for i in part1: if not i: res += now else: if now \u0026gt; i[0]: res += now else: now = i[0] res += now part2.reverse() now = 0 for i in part2: if not i: res += now else: if now \u0026gt; i[0]: res += now else: now = i[0] res += now print(res) 💾 느낀점 푼지 조금 오래된 문제이지만, 바로 바자마자 풀이가 생각이 났다. 지금 소스코드를 다시 작성한다면 더 간결하고 이쁘게 구현할 수 있을 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2304-%EC%B0%BD%EA%B3%A0-%EB%8B%A4%EA%B0%81%ED%98%95-with-python/","summary":"📌 BOJ 2304 창고 다각형 💡 조건 기둥의 개수를 나타내는 정수 (1 \u0026lt;= N \u0026lt;= 1000)\n각 기둥의 왼쪽 면의 위치를 나타내는 정수 (1 \u0026lt;= L \u0026lt;= 1000)\n각 기둥의 높이를 나타내는 정수 (1 \u0026lt;= H \u0026lt;= 1000)\n창고 다각형의 면적을 구하는 문제\n모든 기둥이 들어가는 창고를 지으려고 할 때, 지붕이 될 수 있는 조건은 아래와 같다.\n지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.","title":"[BOJ] 2304 창고 다각형 with Python"},{"content":"\n📌 Programmers 자물쇠와 열쇠 with Python 💡 조건 key는 M x M(3 ≤ M ≤ 20, M은 자연수) 크기 2차원 배열\nlock은 N x N(3 ≤ N ≤ 20, N은 자연수) 크기 2차원 배열\nM은 항상 N 이하, key와 lock의 원소는 0 또는 1 자물쇠는 홈이 있으며, 열쇠도 돌기가 있다. 열쇠는 회전이 가능하다. 자물쇠 부분이 회전할 수 있는 열쇠와 겹쳐져서 모두 1이 된다면 열 수 있으니 True, 열 수 없다면 False를 반환 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0], [1, 0, 0], [0, 1, 1]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0]])) 실행결과 true ⌨️ 문제 풀이 N과 M의 최대 크기가 20이니, 열쇠의 최소크기인 3만큼 자물쇠의 길이에 곱해서 맵을 뻥튀기 시킨다.\n이 작업은 열쇠를 움직이기 편하기 위해서 전체 맵의 크기를 키우는 것.\n맵의 크기를 세배로 넓혔다면, 원래 자물쇠를 가운데 위치에 위치시킨다.\nfor i in range(lock_l): for j in range(lock_l): new_lock[i + lock_l][j + lock_l] = lock[i][j] 열쇠는 총 4방향으로 돌 수 있으니, 열쇠를 미리 한 번 돌리고 이동시키면서 자물쇠가 열리는지 체크하면 된다.\nkey = turn_key(key_l, key) def turn_key(l, key): new_key = [item[:] for item in key] for i in range(l): for j in range(l): new_key[i][j] = key[l - (j + 1)][i] return new_key 열쇠를 0, 0 부터 new_lock 의 크기에서 key의 길이만큼 뺀 값까지 이동시키면서 반복순회를 한다. def check(lock, lock_l): for i in range(lock_l): for j in range(lock_l): if lock[i + lock_l][j + lock_l] != 1: return False return True 🖥 소스 코드 def turn_key(l, key): new_key = [item[:] for item in key] for i in range(l): for j in range(l): new_key[i][j] = key[l - (j + 1)][i] return new_key def check(lock, lock_l): for i in range(lock_l): for j in range(lock_l): if lock[i + lock_l][j + lock_l] != 1: return False return True def solution(key, lock): key_l = len(key) lock_l = len(lock) new_lock = [[0] * (lock_l * 3) for _ in range(lock_l * 3)] new_len = len(new_lock) for i in range(lock_l): for j in range(lock_l): new_lock[i + lock_l][j + lock_l] = lock[i][j] for i in range(4): key = turn_key(key_l, key) for i in range(new_len - key_l): for j in range(new_len - key_l): for k in range(key_l): for p in range(key_l): new_lock[i + k][j + p] += key[k][p] if check(new_lock, lock_l): return True else: for k in range(key_l): for p in range(key_l): new_lock[i + k][j + p] -= key[k][p] return False 💾 느낀점 열쇠를 돌리는 것에서 헤맬뻔했지만, 반복 숙달덕에 잘 할 수 있었다. 자물쇠의 전체 크기를 키워서 하는 방법은 N, M 의 크기가 작은 것을 확인하고 생각해낼 수 있었다. 역시 시뮬레이션 \u0026amp; 구현 문제는 어렵다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%9E%90%EB%AC%BC%EC%87%A0%EC%99%80-%EC%97%B4%EC%87%A0-with-python/","summary":"📌 Programmers 자물쇠와 열쇠 with Python 💡 조건 key는 M x M(3 ≤ M ≤ 20, M은 자연수) 크기 2차원 배열\nlock은 N x N(3 ≤ N ≤ 20, N은 자연수) 크기 2차원 배열\nM은 항상 N 이하, key와 lock의 원소는 0 또는 1 자물쇠는 홈이 있으며, 열쇠도 돌기가 있다. 열쇠는 회전이 가능하다. 자물쇠 부분이 회전할 수 있는 열쇠와 겹쳐져서 모두 1이 된다면 열 수 있으니 True, 열 수 없다면 False를 반환 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 print(solution([[0, 0, 0], [1, 0, 0], [0, 1, 1]], [[0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [1, 0, 1, 0]])) 실행결과 true ⌨️ 문제 풀이 N과 M의 최대 크기가 20이니, 열쇠의 최소크기인 3만큼 자물쇠의 길이에 곱해서 맵을 뻥튀기 시킨다.","title":"[Programmers] 자물쇠와 열쇠 with Python"},{"content":"\n📌 Programmers 기둥과 보 설치 with Python 💡 조건 5 \u0026lt;= n \u0026lt;= 100\n1 \u0026lt;= 입력받을 기둥과 보의 개수 \u0026lt;= 1000\n`입력받을 기둥 혹은 보의 정보의 데이터 개수 == 4'\n바닥에 보를 설치하는 경우는 없다.\n벽면을 벗어나게 설치하는 경우는 없다.\n구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제한다.\n구조물이 겹치거나, 없는 것을 삭제하는 경우는 없습니다.\n구현\u0026amp;시뮬레이션 문제\n반환하는 데이터는 x, y, 기둥 순으로 정렬하여 반환한다.\n🔖 예제 및 실행결과 예제 n = 5 build_frame = [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] 실행결과 [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] ⌨️ 문제 풀이 build_frame을 순회하면서, 각 frame에서 x, y, a, b 를 구별하여 시뮬레이션을 합니다.\na 는 기둥과 보의 구별, b는 삽입, 삭제의 구별에 사용합니다. 만약 b가 삽입에 해당할 경우, (x, y, a) 를 answer에 저장하고 check()함수를 호출하여\n방금 세운 구조물이 전체적으로 가능한 구조물인지 확인합니다. check 함수에서 False를 반환한 경우, answer에서 (x, y, a)를 삭제합니다.\ncheck 함수에서 True를 반환한 경우, 넘어갑니다. 만약 b가 삭제에 해당할 경우, (x, y, a) 를 answer에서 삭제합니다.\ncheck 함수에서 False를 반환한 경우, answer에서 (x, y, a)를 다시 추가합니다.\ncheck 함수에서 True를 반환한 경우, 넘어갑니다. check 함수에서는 현재 구조물이 정상인지에 대해 판별합니다. 현재 검사하는 구조물의 종류가 보라면 아래의 조건에 해당하지 않는 경우, False를 반환합니다. if y != 0 and([x + 1, y - 1, 0] in answer or [x, y - 1, 0] in answer or ([x - 1, y, 1] in answer and [x + 1, y, 1] in answer)): 현재 검사하는 구조물의 종류가 기둥이라면 아래의 조건에 해당하지 않는 경우, True를 반환합니다. if y == 0 or [x - 1, y, 1] in answer or [x, y, 1] in answer or [x, y - 1, 0] in answer: 🖥 소스 코드 def check(answer): for x, y, a in answer: if a: # 보 \u0026#34;\u0026#34;\u0026#34;보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.\u0026#34;\u0026#34;\u0026#34; if y != 0 and([x + 1, y - 1, 0] in answer or [x, y - 1, 0] in answer or ([x - 1, y, 1] in answer and [x + 1, y, 1] in answer)): continue else: return False else: # 기둥 \u0026#34;\u0026#34;\u0026#34;기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.\u0026#34;\u0026#34;\u0026#34; if y == 0 or [x - 1, y, 1] in answer or [x, y, 1] in answer or [x, y - 1, 0] in answer: continue else: return False return True def solution(n, build_frame): answer = [] for frame in build_frame: x, y, a, b = frame if b: # install answer.append([x, y, a]) if not check(answer): answer.remove([x, y, a]) else: # remove answer.remove([x, y, a]) if not check(answer): answer.append([x, y, a]) return sorted(answer) 💾 느낀점 check 함수를 구현하는 것이 힘이 들었다. 구현 연습은 반복만이 답이 아닌가 싶다. 더 열심히 풀어야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EA%B8%B0%EB%91%A5%EA%B3%BC-%EB%B3%B4-%EC%84%A4%EC%B9%98-with-python/","summary":"📌 Programmers 기둥과 보 설치 with Python 💡 조건 5 \u0026lt;= n \u0026lt;= 100\n1 \u0026lt;= 입력받을 기둥과 보의 개수 \u0026lt;= 1000\n`입력받을 기둥 혹은 보의 정보의 데이터 개수 == 4'\n바닥에 보를 설치하는 경우는 없다.\n벽면을 벗어나게 설치하는 경우는 없다.\n구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제한다.\n구조물이 겹치거나, 없는 것을 삭제하는 경우는 없습니다.\n구현\u0026amp;시뮬레이션 문제\n반환하는 데이터는 x, y, 기둥 순으로 정렬하여 반환한다.","title":"[Programmers] 기둥과 보 설치 with Python"},{"content":"\n📌 Programmers 후보키 with Python 💡 조건 relation 은 2차원 문자열 배열이다.\n1 \u0026lt;= relation 의 컬럼의 길이 \u0026lt;= 8\n1 \u0026lt;= relation 의 로우의 길이 \u0026lt;= 20\n1 \u0026lt;= relation 의 모든 문자열의 길이 \u0026lt;= 8, 알파벳 소문자와 숫자로만 이루어져 있다.\n중복되는 튜플은 없다. 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.\n즉, 학생들을 구별할 수 있는 유일성과 최소성을 지키는 키의 조합의 개수를 구하면 된다. 조합의 개수를 구하는 문제 🔖 예제 및 실행결과 예제 [[\u0026#34;100\u0026#34;,\u0026#34;ryan\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;200\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;math\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;300\u0026#34;,\u0026#34;tube\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;400\u0026#34;,\u0026#34;con\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;4\u0026#34;],[\u0026#34;500\u0026#34;,\u0026#34;muzi\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;600\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;]] 실행결과 2 ⌨️ 문제 풀이 row와 column 의 개수를 구해 변수로 둔다.\n키값이 될 수 있는 1개부터 column 의 길이의 조합을 각각 구해서 candidates에 저장한다.\n1번에서 구한 조합의 경우의 수를 순회하면서 해당되는 relation 의 데이터를 tmp 에 저장한 후\nset() 으로 자료형을 변경하여 중복을 제거한 후, row의 개수와 비교한다.\n만약 같다면, 후보키가 될 수 있는 것이기에 unique 변수에 저장한다\n추출한 데이터가 유일성을 가지는지에 대해서 검사하는 것.\nanswer 변수에 3번 작업을 통해 나온 unique 변수에 있는 데이터를 set() 자료형으로 중복을 제거한 뒤 저장한다.\nunique 변수의 길이만큼 순회하면서 (i)\ni 이후의 각 키조합에 (j) i가 포함이 되어 있다면, answer에서 j를 제거한다.\ni가 j에 포함이 된다면, j는 원소 하나가 빠져도 최소성을 만족하지 않기에 제거하는 것.\nanswer의 길이를 반환\n🖥 소스 코드 from itertools import combinations def solution(relation): col = len(relation[0]) row = len(relation) candidates = [] for i in range(1, col + 1): candidates.extend(combinations(range(col), i)) unique = [] for candi in candidates: tmp = [tuple([item[i] for i in candi]) for item in relation] if len(set(tmp)) == row: unique.append(candi) answer = set(unique) for i in range(len(unique)): for j in range(i + 1, len(unique)): if len(unique[i]) == len(set(unique[i]) \u0026amp; set(unique[j])): answer.discard(unique[j]) return len(answer) 💾 느낀점 조합을 사용하여 문제에서 제시한 최소성과 유일성을 이해하고 문제를 풀이해야했다. 주어진 데이터의 길이의 크기가 작아서 완전탐색을 통해서 할 수 있었다. set() 자료구조의 성질을 통해서 중복을 제거할 수 있다는 것을 알고 있다면 더 편하게 풀 수 있는 문제였다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%ED%9B%84%EB%B3%B4%ED%82%A4-with-python/","summary":"📌 Programmers 후보키 with Python 💡 조건 relation 은 2차원 문자열 배열이다.\n1 \u0026lt;= relation 의 컬럼의 길이 \u0026lt;= 8\n1 \u0026lt;= relation 의 로우의 길이 \u0026lt;= 20\n1 \u0026lt;= relation 의 모든 문자열의 길이 \u0026lt;= 8, 알파벳 소문자와 숫자로만 이루어져 있다.\n중복되는 튜플은 없다. 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.\n즉, 학생들을 구별할 수 있는 유일성과 최소성을 지키는 키의 조합의 개수를 구하면 된다. 조합의 개수를 구하는 문제 🔖 예제 및 실행결과 예제 [[\u0026#34;100\u0026#34;,\u0026#34;ryan\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;200\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;math\u0026#34;,\u0026#34;2\u0026#34;],[\u0026#34;300\u0026#34;,\u0026#34;tube\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;400\u0026#34;,\u0026#34;con\u0026#34;,\u0026#34;computer\u0026#34;,\u0026#34;4\u0026#34;],[\u0026#34;500\u0026#34;,\u0026#34;muzi\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;600\u0026#34;,\u0026#34;apeach\u0026#34;,\u0026#34;music\u0026#34;,\u0026#34;2\u0026#34;]] 실행결과 2 ⌨️ 문제 풀이 row와 column 의 개수를 구해 변수로 둔다.","title":"[Programmers] 후보키 with Python"},{"content":"\n📌 BOJ 14725 개미굴 💡 조건 첫 번째 줄은 로봇 개미가 각 층을 따라 내려오면서 알게 된 먹이의 정보 개수 N \u0026raquo; (1 ≤ N ≤ 1000)\n두 번째 줄부터 N+1 번째 줄까지, 각 줄의 시작은 로봇 개미 한마리가 보내준 먹이 정보 개수 K \u0026raquo; (1 ≤ K ≤ 15)\n다음 K개의 입력은 로봇 개미가 왼쪽부터 순서대로 각 층마다 지나온 방에 있는 먹이 정보이며 먹이 이름 길이 t \u0026raquo; (1 ≤ t ≤ 15) 트라이(Trie) 자료구조를 사용하는 문제. 🔖 예제 및 실행결과 예제 4 2 KIWI BANANA 2 KIWI APPLE 2 APPLE APPLE 3 APPLE BANANA KIWI 실행결과 APPLE --APPLE --BANANA ----KIWI KIWI --APPLE --BANANA ⌨️ 문제 풀이 trie 클래스를 생성하고, 로봇 개미가 보내준 데이터를 Trie 에 담는다.\n클래스 내 insert 함수에서 데이터를 차례대로 넣는다.\ncur_node 변수를 root로 주고, 데이터가 존재한다면 cur_node를 갱신,\n데이터가 존재 하지 않는다면, 추가해준다.\n입력 작업 반복문이 끝이 났다면, 노드의 마지막을 '*' 로 저장해준다.\n마지막 라인에서 클래스 내 출력 함수인, print_trie 를 0 을 넣어 실행해준다.\nl 이 0이라면, cur_node 를 root로 설정해준다.\ncur_node의 키 값을 정렬한 뒤, 반복문을 통해 출력해준다\n여기서 노드의 키 값이 '*' 이라면 출력을 하지 않고, print_trie 함수를 재귀 호출해준다.\n이때, l의 값은 + 1, cur_node는 c노드를 기준으로 넣어준다.\n만약 cur_node 의 키 값이 '*' 이 아니라면 '--' 문자열을 l 만큼 출력한 뒤, 노드를 출력한다\n🖥 소스 코드 from sys import stdin n = int(stdin.readline()) class Trie: def __init__(self): self.root = {} def insert(self, s): cur_node = self.root for c in s: if c not in cur_node: cur_node[c] = {} cur_node = cur_node[c] cur_node[\u0026#39;*\u0026#39;] = {} def print_trie(self, l, cur_node=None): if l == 0: cur_node = self.root for c in sorted(cur_node.keys()): if c != \u0026#39;*\u0026#39;: print(\u0026#39;--\u0026#39; * l, c, sep=\u0026#34;\u0026#34;) self.print_trie(l + 1, cur_node[c]) trie = Trie() for _ in range(n): data = list(stdin.readline().split()) trie.insert(data[1:]) trie.print_trie(0) 💾 느낀점 Trie 자료구조를 공부해야 풀 수 있는 문제였다. 처음보는 자료구조이기에 이해하는데에도 시간이 걸렸고, 부족한 점을 알게 되었다. 로직을 보면서 공부해야할 것을 다시 한번 정리하고 공부해야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-14725-%EA%B0%9C%EB%AF%B8%EA%B5%B4-with-python/","summary":"📌 BOJ 14725 개미굴 💡 조건 첫 번째 줄은 로봇 개미가 각 층을 따라 내려오면서 알게 된 먹이의 정보 개수 N \u0026raquo; (1 ≤ N ≤ 1000)\n두 번째 줄부터 N+1 번째 줄까지, 각 줄의 시작은 로봇 개미 한마리가 보내준 먹이 정보 개수 K \u0026raquo; (1 ≤ K ≤ 15)\n다음 K개의 입력은 로봇 개미가 왼쪽부터 순서대로 각 층마다 지나온 방에 있는 먹이 정보이며 먹이 이름 길이 t \u0026raquo; (1 ≤ t ≤ 15) 트라이(Trie) 자료구조를 사용하는 문제.","title":"[BOJ] 14725 개미굴 with Python"},{"content":"\n📌 Programmers 오픈채팅방 with Python 💡 조건 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record\n모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하 모든 유저는 유저 아이디로 구분한다.\n유저 아이디 사용자가 닉네임으로 채팅방에 입장 - \u0026quot;Enter 유저 아이디 닉네임\u0026quot; (ex. \u0026quot;Enter uid1234 Muzi\u0026quot;) 구현 유형의 문제 🔖 예제 및 실행결과 예제 record = [\u0026#34;Enter uid1234 Muzi\u0026#34;, \u0026#34;Enter uid4567 Prodo\u0026#34;,\u0026#34;Leave uid1234\u0026#34;,\u0026#34;Enter uid1234 Prodo\u0026#34;,\u0026#34;Change uid4567 Ryan\u0026#34;] 실행결과 [\u0026#34;Prodo님이 들어왔습니다.\u0026#34;, \u0026#34;Ryan님이 들어왔습니다.\u0026#34;, \u0026#34;Prodo님이 나갔습니다.\u0026#34;, \u0026#34;Prodo님이 들어왔습니다.\u0026#34;] ⌨️ 문제 풀이 문제의 정답을 출력할 배열 answer, (상태, uid) 정보를 저장할 배열 result,\n입장과 퇴장의 문구가 담긴 배열 status, (uid, 닉네임)이 담겨있는 딕셔너리 id_code 를 생성한다.\nrecord를 순회하면서 가장 첫 정보가 Enter 일 경우, id_code 딕셔너리에 uid: 닉네임 형식으로 데이터를 저장한다.\nresult에 (상태코드, uid) 를 저장한다.\n첫 정보가 Leave 일 경우, result에 (상태코드, uid) 를 저장한다.\n첫 정보가 Change 일 경우, id_code의 uid 에 해당하는 닉네임을 변경한다.\nresult 배열을 순회하면서 id_code 딕셔너리의 uid에 해당하는 닉네임과 스테이터스 번호를 함께 answer 배열에 저장한다.\nanswer를 반환한다.\n🖥 소스 코드 def solution(record): result = [] answer = [] status = [\u0026#34;님이 들어왔습니다.\u0026#34;, \u0026#34;님이 나갔습니다.\u0026#34;] id_code = {} for r in record: l = r.split() if l[0] == \u0026#39;Enter\u0026#39;: id_code[l[1]] = l[2] result.append([0, l[1]]) elif l[0] == \u0026#39;Leave\u0026#39;: result.append([1, l[1]]) else: id_code[l[1]] = l[2] for s, uid in result: answer.append(id_code[uid] + status[s]) return answer 💾 느낀점 uid 번호에 따른 상태와, 닉네임을 변경하여 그에 맞게 출력하는 구현문제였다. 상태를 저장을 어떻게 할지에 대해서 고민을 하다가 오래걸렸었는데, 직접 구현을 하고 보니 짧고 간단한 문제였다. 구현 연습을 더 열심히 해야하겠다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9-with-python/","summary":"📌 Programmers 오픈채팅방 with Python 💡 조건 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record\n모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하 모든 유저는 유저 아이디로 구분한다.\n유저 아이디 사용자가 닉네임으로 채팅방에 입장 - \u0026quot;Enter 유저 아이디 닉네임\u0026quot; (ex. \u0026quot;Enter uid1234 Muzi\u0026quot;) 구현 유형의 문제 🔖 예제 및 실행결과 예제 record = [\u0026#34;Enter uid1234 Muzi\u0026#34;, \u0026#34;Enter uid4567 Prodo\u0026#34;,\u0026#34;Leave uid1234\u0026#34;,\u0026#34;Enter uid1234 Prodo\u0026#34;,\u0026#34;Change uid4567 Ryan\u0026#34;] 실행결과 [\u0026#34;Prodo님이 들어왔습니다.","title":"[Programmers] 오픈채팅방 with Python"},{"content":"\n📌 BOJ 12100 2048(easy) 💡 조건 보드의 크기는 N * N (1 ≤ N ≤ 20)\n0 은 빈칸, 이외의 값은 블록의 값들을 나타낸다.\n블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다.\n블록은 적어도 하나 주어진다. 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 최대 다섯번 이동 시켜서 얻을 수 있는 가장 큰 블록의 값을 출력. 백트래킹 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 3 2 2 2 4 4 4 8 8 8 실행결과 16 ⌨️ 문제 풀이 백트래킹은 재귀가 가장 핵심.\n백트래킹을 수행하며 재귀를 진행할 recursive함수에 파라미터를 cnt 로 주고, 첫 실행시에는 0을 주고 실행시킨다.\nN의 크기가 작기 때문에 deep copy를 이용한 배열복사가 가능하다.\n이를 통해 방향을 바꾸기 전, 이전 보드의 상태를 기억하기 위한 소스코드를 작성한다.\n움직이기 전 보드의 상황을 기억해두지 않으면, 백트래킹이 수행될 수 없다.\nb = [x[:] for x in arr] 네 방향으로 블록을 움직일 수 있으니, 반복문을 통해 네 방향으로 움직여준다.\nmove() 함수에서 k 의 값에 따라 네 방향으로 움직여 준다.\ndef move(k): # arr[i][j] if k == 0: # 위로 이동, 블락들이 위로 모두 이동하면 row index는 0 for j in range(n): for i in range(n): get(i, j) merge(0, j, 1, 0) # row index 1씩 증가하면서 아래쪽 블락들을 합쳐감 elif k == 1: # 아래로 이동, 블락들이 아래로 모두 이동하면 row index는 n-1 for j in range(n): for i in range(n - 1, -1, -1): get(i, j) merge(n - 1, j, -1, 0) # row 인덱스 1씩 감소하면서 위쪽들을 합쳐감 elif k == 2: # 오른쪽으로 이동, column index는 0 for i in range(n): for j in range(n): get(i, j) merge(i, 0, 0, 1) # column 인덱스 증가 오른쪽으로 이동 else: # 왼쪽으로 이동, column index는 n-1 for i in range(n): for j in range(n - 1, -1, -1): get(i, j) merge(i, n - 1, 0, -1) # column 인덱스 감소 왼쪽으로 이동 get() 함수에서 움직일 보드들의 상태를 확인하면서 순차적으로 순회해주고,\n순회하면서 배열 원소의 값이 0이 아닌 경우, 원소의 값을 큐에 넣어준다.\n배열에 넣은 값이 있던 해당 자리는 0으로 바꿔준다.\ndef get(i, j): if arr[i][j]: # 0이 아닌 값이라면 q.append(arr[i][j]) # queue에 arr의 값을 넣는다. arr[i][j] = 0 # 처리가 된 빈 자리는 0으로 값 업데이트 merge() 함수에서 각 이동하려는 방향에 알맞게 인덱스를 조절하며 큐가 빌때까지 반복하며 합쳐준다.\n움직이려는 값의 블록을 큐에서 꺼내온 후, 놓을 곳의 블럭의 값이 0이라면 그냥 두고,\n값이 일치한다면 2의 제곱 꼴이기에 2배를 해준다.\n값이 일치 하지 않는다면 그 자리에 그대로 둔다.\ndef merge(i, j, di, dj): # row index, column index, y방향, x방향 while q: x = q.popleft() # 움직이려는 블록 값을 가져온다. FIFO if not arr[i][j]: # 0이라면 그대로 놓는다. arr[i][j] = x elif arr[i][j] == x: # 값이 일치한다면 arr[i][j] = x * 2 # 합쳐지므로 2배로 증가 i, j = i + di, j + dj else: # 값이 일치하지 않으면 i, j = i + di, j + dj arr[i][j] = x move() 함수의 처리가 끝났다면, cnt + 1 을 파라미터로 주고, recursive 함수를 재귀호출 해준다.\n3번부터 다시 반복하면서, cnt 값이 5, 즉 다섯번 움직였을 때, 보드판을 순회한다.\n각 배열의 최댓값과 정답으로 출력할 ans 값을 비교하여 갱신한다.\n🖥 소스 코드 from sys import stdin, setrecursionlimit from collections import deque setrecursionlimit(int(1e9)) n = int(stdin.readline()) arr = [list(map(int, stdin.readline().split())) for _ in range(n)] answer, q = 0, deque() def get(i, j): if arr[i][j]: q.append(arr[i][j]) arr[i][j] = 0 def merge(i, j, di, dj): while q: x = q.popleft() if not arr[i][j]: arr[i][j] = x elif arr[i][j] == x: arr[i][j] = x * 2 i, j = i + di, j + dj else: i, j = i + di, j + dj arr[i][j] = x def move(k): if k == 0: for j in range(n): for i in range(n): get(i, j) merge(0, j, 1, 0) elif k == 1: for j in range(n): for i in range(n - 1, -1, -1): get(i, j) merge(n - 1, j, -1, 0) elif k == 2: for i in range(n): for j in range(n): get(i, j) merge(i, 0, 0, 1) else: for i in range(n): for j in range(n - 1, -1, -1): get(i, j) merge(i, n - 1, 0, -1) def recursive(count): global arr, answer if count == 5: for i in range(n): answer = max(answer, max(arr[i])) return b = [x[:] for x in arr] for k in range(4): move(k) recursive(count + 1) arr = [x[:] for x in b] recursive(0) print(answer) 💾 느낀점 재귀함수를 얼마나 응용을 할 수 있는지에 대한 문제였다. get(), move() 함수를 구현하는 것이 가장 어려웠으며, 이 부분은 다른 블로그에서 아이디어를 얻어 해결했다. 몇 번이고 다시 풀어보기 좋은 문제인 것 같다. 주말에 다시 한 번 풀어보는 것이 좋겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-12100-2048easy-with-python/","summary":"📌 BOJ 12100 2048(easy) 💡 조건 보드의 크기는 N * N (1 ≤ N ≤ 20)\n0 은 빈칸, 이외의 값은 블록의 값들을 나타낸다.\n블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다.\n블록은 적어도 하나 주어진다. 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 최대 다섯번 이동 시켜서 얻을 수 있는 가장 큰 블록의 값을 출력.","title":"[BOJ] 12100 2048(easy) with Python"},{"content":"\n📌 BOJ 13334 철로 💡 조건 사람 수를 나타내는 양의 정수 n (1 ≤ n ≤ 100,000)\nn개의 각 줄에 정수 쌍 (hi, oi)가 주어진다.\n−100,000,000 ≤ hi ≤ 100,000,000\n−100,000,000 ≤ oi ≤ 100,000,000\noi != hi\n철로의 길이를 나타내는 정수 d (1 ≤ d ≤ 200,000,000) 집과 사무실 모두가 철로 길이 안에 들어갈 수 있는 최대의 개수를 구하는 문제. 우선순위 큐, 즉 자료구조를 활용하는 문제. 🔖 예제 및 실행결과 예제 8 5 40 35 25 10 20 10 25 30 50 50 60 30 25 80 100 30 실행결과 4 ⌨️ 문제 풀이 가장 먼저 집과 사무실의 위치를 입력받는데, 그 위치가 정렬이 된 데이터가 아니기에 계산을 용이하도록 하기 위해\n데이터를 전처리를 해준 후, data 리스트에 넣는다.\n철로의 길이를 입력받는다.\ndata를 순회하면서, 집과 사무실의 거리가 철로의 길이보다 짧을 경우에만 roads 리스트에 넣어준다.\n모든 곳에서의 선분 d(철로의 길이) 안에 집과 사무실이 모두 안에 들어가야 하기 때문이다.\n3번을 수행시켜 얻은 roads 리스트를 정렬시킨다.\n정렬시킨 roads 배열을 다시 순회하면서, heapq 를 만들어 큐가 비어있을 경우 정렬된 데이터를 넣는다.\n큐의 시작점 위치가 (현재 지정된 road의 끝나는 지점 - 철로 길이) 보다 짧으면 큐에서 데이터를 뺀다.\n큐에 들어가 있는 집과 사무실 좌표 순서쌍의 개수가 정답이기 때문에\n철로의 길이 범위 밖으로 좌표가 나가는 애들은 과함하게 잘라준다.\n🖥 소스 코드 from sys import stdin import heapq n = int(stdin.readline()) roads, data = [], [] for _ in range(n): data.append(sorted(list(map(int, stdin.readline().split())))) train_road_length = int(stdin.readline()) for road in data: s, e = road if (e - s) \u0026lt;= train_road_length: roads.append(road) roads.sort(key=lambda x: x[1]) answer = 0 q = [] for road in roads: if not q: heapq.heappush(q, road) else: while q[0][0] \u0026lt; road[1] - train_road_length: heapq.heappop(q) if not q: break heapq.heappush(q, road) answer = max(answer, len(q)) print(answer) 💾 느낀점 우선순위 큐를 사용해서 푸는 문제였지만, 문제를 이해하고 푸는데에 애를 먹었다. 누적합을 사용해서 풀어보려고 했는데 올바른 풀이가 아니었는지, 코딩을 하다가 몇 번 뒤집었다. 이 문제 또한 반드시 한번 더 풀어보고 개념을 익혀야할 문제인 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-13334-%EC%B2%A0%EB%A1%9C-with-python/","summary":"📌 BOJ 13334 철로 💡 조건 사람 수를 나타내는 양의 정수 n (1 ≤ n ≤ 100,000)\nn개의 각 줄에 정수 쌍 (hi, oi)가 주어진다.\n−100,000,000 ≤ hi ≤ 100,000,000\n−100,000,000 ≤ oi ≤ 100,000,000\noi != hi\n철로의 길이를 나타내는 정수 d (1 ≤ d ≤ 200,000,000) 집과 사무실 모두가 철로 길이 안에 들어갈 수 있는 최대의 개수를 구하는 문제. 우선순위 큐, 즉 자료구조를 활용하는 문제. 🔖 예제 및 실행결과 예제 8 5 40 35 25 10 20 10 25 30 50 50 60 30 25 80 100 30 실행결과 4 ⌨️ 문제 풀이 가장 먼저 집과 사무실의 위치를 입력받는데, 그 위치가 정렬이 된 데이터가 아니기에 계산을 용이하도록 하기 위해","title":"[BOJ] 13334 철로 with Python"},{"content":"\n📌 BOJ 1043 거짓말 💡 조건 N, M은 50 이하의 자연수 각각 사람의 수, 파티의 수\n진실을 아는 사람의 수는 0 이상 50 이하의 정수\n각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수 지민이는 모든 파티에 참가해야한다.\n지민이는 이야기를 과장되게 한다. 또한 지민이는 거짓말쟁이가 되기 싫다.\n이야기의 진실을 아는 사람이 파티에 있으면 과장해서 말할 수 없다. 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 문제. 자료구조의 활용을 요구하는 유형의 문제 🔖 예제 및 실행결과 예제 4 5 1 1 1 1 1 2 1 3 1 4 2 4 1 실행결과 2 ⌨️ 문제 풀이 cnt라는 리스트에 파티의 수만큼 원소를 만들어주고, 각 값을 1로 둔다.\n이는 파티에서 과장되게 말을 할 수 있다는 가정하에 1로 둔 것.\n또한 각 파티의 구성원을 party 리스트에 각각 집어넣어준다. 파티의 수만큼 다시 순회하면서 각 party의 번호와 구성원을 뽑아 반복문을 돌리기 위해 enumerate 를 사용해준다.\nenumerate 함수는 리스트를 순회하면서 리스트의 각 원소의 인덱스와 원소를 반환한다. 파티의 구성원과 진실을 아는 사람들간에 교집합이 존재한다면, cnt 리스트의 해당 번호에 해당하는 값을 0으로 변경한다.\n그 파티는 진실만을 말할 수 있는 파티라는 것이다.\n그 후, 파티원을 진실을 알고 있는 사람들이 저장되어 있는 set() 자료형에 update 시켜준다.\nupdate 와 |= 이 둘은 같은 효과를 볼 수 있다. cnt 리스트의 합을 구해 출력한다. 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) trues = set(list(map(int, stdin.readline().split()))[1:]) party = [] cnt = [] for _ in range(m): data = set(map(int, stdin.readline().split()[1:])) if data: party.append(data) cnt.append(1) for _ in range(m): for i, p in enumerate(party): if trues \u0026amp; p: cnt[i] = 0 trues |= p print(sum(cnt)) 💾 느낀점 set 집합자료형의 강력함을 알 수 있는 문제였다. 문제를 잘 읽고 자료구조를 활용하면 풀 수 있는 문제였다. 이 문제를 한번에 풀지 못했다. 아직 활용이 부족한 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1043-%EA%B1%B0%EC%A7%93%EB%A7%90-with-python/","summary":"📌 BOJ 1043 거짓말 💡 조건 N, M은 50 이하의 자연수 각각 사람의 수, 파티의 수\n진실을 아는 사람의 수는 0 이상 50 이하의 정수\n각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수 지민이는 모든 파티에 참가해야한다.\n지민이는 이야기를 과장되게 한다. 또한 지민이는 거짓말쟁이가 되기 싫다.\n이야기의 진실을 아는 사람이 파티에 있으면 과장해서 말할 수 없다. 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 문제. 자료구조의 활용을 요구하는 유형의 문제 🔖 예제 및 실행결과 예제 4 5 1 1 1 1 1 2 1 3 1 4 2 4 1 실행결과 2 ⌨️ 문제 풀이 cnt라는 리스트에 파티의 수만큼 원소를 만들어주고, 각 값을 1로 둔다.","title":"[BOJ] 1043 거짓말 with Python"},{"content":"\n📌 BOJ 2343 기타 레슨 💡 조건 강의의 수 N (1 ≤ N ≤ 100,000)\n블루레이의 수 M (1 ≤ M ≤ N) 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 각 강의의 길이가 분 단위(자연수)로 주어진다. 가능한 블루레이의 크기 중 최소를 구하는 문제. 이분탐색 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 9 3 1 2 3 4 5 6 7 8 9 실행결과 17 ⌨️ 문제 풀이 이분탐색을 위해 left, right, mid 변수를 초기화 해줍니다.\nleft는 입력받은 강의 시간 배열의 가장 큰 값 right는 입력받은 강의 시간 배열의 합 mid = (left + right) // 2 블루레이의 크기에 몇개의 강의가 들어가는지 검사하여 반환하는 함수를 만들어줍니다.\n여기서 블루레이의 크기는 mid를 기준으로 검사를 해준다.\ndef get_cnt(): count = 0 temp = 0 for i in range(n): if temp + arr[i] \u0026gt; mid: count += 1 temp = 0 temp += arr[i] if temp: count += 1 return count\nleft변수가 right 변수보다 크거나 같을 때까지 반복하여 진행한 뒤, left, right, mid 중 가장 큰 값을 출력한다.\n블루레이의 크기가 모두 같아야하기 때문에 최댓값을 출력하는 것이다.\n🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) arr = list(map(int, stdin.readline().split())) def get_cnt(): count = 0 temp = 0 for i in range(n): if temp + arr[i] \u0026gt; mid: count += 1 temp = 0 temp += arr[i] if temp: count += 1 return count left, right = max(arr), sum(arr) while left \u0026lt;= right: mid = (left + right) // 2 cnt = get_cnt() if cnt \u0026gt; m: left = mid + 1 elif cnt \u0026lt;= m: right = mid - 1 print(max(left, right, mid)) 💾 느낀점 이분탐색을 통해서 풀어내는 문제였다. 문제를 이해하지 못해서 조금 헤맸던 문제였다. get_cnt 함수를 구현하려다가 순서가 바뀌면 안된다는 조건을 보고 구현할 수 있었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2343-%EA%B8%B0%ED%83%80-%EB%A0%88%EC%8A%A8-with-python/","summary":"📌 BOJ 2343 기타 레슨 💡 조건 강의의 수 N (1 ≤ N ≤ 100,000)\n블루레이의 수 M (1 ≤ M ≤ N) 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 각 강의의 길이가 분 단위(자연수)로 주어진다. 가능한 블루레이의 크기 중 최소를 구하는 문제. 이분탐색 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 9 3 1 2 3 4 5 6 7 8 9 실행결과 17 ⌨️ 문제 풀이 이분탐색을 위해 left, right, mid 변수를 초기화 해줍니다.","title":"[BOJ] 2343 기타 레슨 with Python"},{"content":"\n📌 BOJ 3184 양 💡 조건 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.\nR개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다. 한 칸에서 수평, 수직만으로 이동할수 있다.\n영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대가 많으면 양은 사라진다. 넓이 우선 탐색(BFS) 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 6 ...#.. .##v#. #v.#.# #.o#.# .###.# ...### 실행결과 0 2 ⌨️ 문제 풀이 양과 늑대의 수를 담을 answer 리스트를 각각의 원소를 0으로 초기화하여 생성한다.\n이미 방문했던 곳의 좌표를 담을 set 자료형 visited를 생성한다. 이중 반복문으로 필드를 순회하면서, 다음 두가지에 해당하면 BFS를 수행한다. (i, j) 가 visited 에 방문하지 않았을 때 (i, j) 에 해당하는 필드 값이 v 혹은 o 일 때 bfs 함수에서 vo라는 set()이 두개 담긴 리스트를 생성해준다.\n큐에는 bfs 를 수행하기 위해 받아온 x, y 값을 넣어주고, 큐가 빌 때까지 수행한다. 큐에서 뽑아낸 x, y 좌표가 필드에서 양인지 늑대인지 구문하여 vo[1] 혹은 v[0] 에 저장해준다.\n현재 좌표에서 상하좌우를 순회하며 방문하지 않았고, #이 아닌 필드의 좌표를 큐와 visited 에 넣어준다. 큐가 비어 while 반복문이 종료되면, 양의 수와 늑대의 수를 비교하여\n수가 더 작은 쪽은 0으로, 큰 쪽은 숫자 그대로 반환한다. bfs 함수에서 반환받은 값을 answer 원소에 각각 더해준다. 🖥 소스 코드 from sys import stdin from collections import deque n, m = map(int, stdin.readline().split()) board = [] for n in range(n): board.append(list(stdin.readline().rstrip())) dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] visited = set() def bfs(x, y): vo = [set(), set()] q = deque() q.append((x, y)) visited.add((x, y)) while q: x, y = q.popleft() if board[x][y] == \u0026#39;o\u0026#39;: vo[1].add((x, y)) elif board[x][y] == \u0026#39;v\u0026#39;: vo[0].add((x, y)) for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; n and -1 \u0026lt; ny \u0026lt; m: if board[nx][ny] != \u0026#39;#\u0026#39; and (nx, ny) not in visited: q.append((nx, ny)) visited.add((nx, ny)) if len(vo[0]) \u0026lt; len(vo[1]): return 0, len(vo[1]) else: return len(vo[0]), 0 answer = [0, 0] for i in range(n): for j in range(m): if (board[i][j] == \u0026#39;v\u0026#39; or board[i][j] == \u0026#39;o\u0026#39;) and (i, j) not in visited: v, o = bfs(i, j) answer[0] += o answer[1] += v print(*answer) 💾 느낀점 BFS 문제였고, 쉽게 풀 수 있는 문제였다. 다른 사람이 내 글을 보고 잘 이해할 수 있을지는 모르겠다. 조금 더 쉽게 설명할 수 있게 더 높은 수준의 이해가 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-3184-%EC%96%91-with-python/","summary":"📌 BOJ 3184 양 💡 조건 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.\nR개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다. 한 칸에서 수평, 수직만으로 이동할수 있다.\n영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대가 많으면 양은 사라진다. 넓이 우선 탐색(BFS) 알고리즘 유형의 문제 🔖 예제 및 실행결과 예제 6 6 .","title":"[BOJ] 3184 양 with Python"},{"content":"\n📌 BOJ 1713 후보 추천하기 💡 조건 사진틀의 개수 N이 주어진다. (1 ≤ N ≤ 20)\n총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 9 2 1 4 3 5 6 2 7 2 실행결과 2 6 7 ⌨️ 문제 풀이 추천받은 순서대로 주어진 리스트를 순회하며 student (dict) 에 없으면 새로 추가하고,\nstudent (dict) 에 있으면 + 1을 해준다.\n만약, 새로 추가를 해야하는데 student 길이가 사진틀의 개수보다 같거나 클 경우, 가장 적게 추천 받은 학생 또는 가장 오래된 사진을 뺀다. student에 남아있는 key만 뽑아 정렬한 뒤 반환한다. 🖥 소스 코드 from sys import stdin import heapq def solution(n): student = {} data = list(map(int, stdin.readline().split())) for s in data: if s not in student: if len(student) \u0026gt;= n: # dict를 heapq 모듈을 사용해 최솟값을 뽑아냄 a = heapq.nsmallest(min(student), student, key=student.get) student.pop(a[0]) student[s] = 1 else: student[s] += 1 return sorted(student.keys()) n = int(stdin.readline().rstrip()) r = int(stdin.readline().rstrip()) print(*solution(n)) 💾 느낀점 heapq 에 더 다양한 기능이 있다는 것을 검색을 통해 알았다. 일반 반목 + 조건문으로 코드를 작성한 것보다 훨씬더 보기가 좋았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1713-%ED%9B%84%EB%B3%B4-%EC%B6%94%EC%B2%9C%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 1713 후보 추천하기 💡 조건 사진틀의 개수 N이 주어진다. (1 ≤ N ≤ 20)\n총 추천 횟수는 1,000번 이하이며 학생을 나타내는 번호는 1부터 100까지의 자연수 사진틀의 개수와 전체 학생의 추천 결과가 추천받은 순서대로 주어졌을 때, 최종 후보가 누구인지 결정 구현 \u0026amp; 시뮬레이션 유형의 문제 🔖 예제 및 실행결과 예제 3 9 2 1 4 3 5 6 2 7 2 실행결과 2 6 7 ⌨️ 문제 풀이 추천받은 순서대로 주어진 리스트를 순회하며 student (dict) 에 없으면 새로 추가하고,","title":"[BOJ] 1713 후보 추천하기 with Python"},{"content":"\n📌 BOJ 1743 음식물 피하기 💡 조건 통로의 세로 길이 N(1 ≤ N ≤ 100)\n통로의 가로 길이 M(1 ≤ M ≤ 100)\n음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)\nK개의 줄에 음식물이 떨어진 좌표 (r, c) DFS 유형의 문제(깊이우선탐색) 🔖 예제 및 실행결과 예제 3 4 5 3 2 2 2 3 1 2 3 1 1 실행결과 4 ⌨️ 문제 풀이 m * n 크기의 맵을 만들어 0으로 도배를 한 후, 쓰레기가 있는 곳의 좌표를 받아 1이라고 표시했다.\n쓰레기가 있는 좌표는 따로 foot_t라는 변수에 담았다. food_t 를 순회하면서 어느 좌표에서 가장 쓰레기가 크게 되는지 깊이 우선 탐색을 통해 계산해준다. 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 9) n, m, k = map(int, stdin.readline().split()) arr = [[0] * (m + 1) for _ in range(n + 1)] food_t = [] for _ in range(k): x, y = map(int, stdin.readline().split()) arr[x][y] = 1 food_t.append((x, y)) answer = -1e9 dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] def dfs(x, y): global res if x \u0026lt; 0 or y \u0026lt; 0 or x \u0026gt; n or y \u0026gt; m: return if arr[x][y] == 1: arr[x][y] = 0 res += 1 for i in range(4): dfs(x + dx[i], y + dy[i]) return for x, y in food_t: res = 0 dfs(x, y) answer = max(res, answer) print(answer) 💾 느낀점 recursive 제약이 있어, setrecursionlimit 함수를 사용한다는 것을 매일 까먹는다. 조심해야겠다. DFS로 한번, BFS로 한번 풀어보았다. 이런 문제가 가장 싫었었는데 지금은 가장 좋다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1743-%EC%9D%8C%EC%8B%9D%EB%AC%BC-%ED%94%BC%ED%95%98%EA%B8%B0-with-python/","summary":"📌 BOJ 1743 음식물 피하기 💡 조건 통로의 세로 길이 N(1 ≤ N ≤ 100)\n통로의 가로 길이 M(1 ≤ M ≤ 100)\n음식물 쓰레기의 개수 K(1 ≤ K ≤ N×M)\nK개의 줄에 음식물이 떨어진 좌표 (r, c) DFS 유형의 문제(깊이우선탐색) 🔖 예제 및 실행결과 예제 3 4 5 3 2 2 2 3 1 2 3 1 1 실행결과 4 ⌨️ 문제 풀이 m * n 크기의 맵을 만들어 0으로 도배를 한 후, 쓰레기가 있는 곳의 좌표를 받아 1이라고 표시했다.","title":"[BOJ] 1743 음식물 피하기 with Python"},{"content":"\n📌 BOJ 1244 스위치 켜고 끄기 💡 조건 및 풀이 첫째 줄은 스위치 개수. 스위치 개수는 100 이하인 양의 정수.\n둘째 줄은 각 스위치의 상태. 켜져 있으면 1, 꺼져있으면 0이라고 표시\n셋째 줄에는 학생 수. 학생수는 100 이하인 양의 정수\n넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수. 남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. 여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서,\n그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다. 구현 \u0026amp; 시뮬레이션 유형의 문제 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 문제. 🔖 예제 및 실행결과 예제 8 0 1 0 1 0 0 0 1 2 1 3 2 3 실행결과 1 0 0 0 1 1 0 1 ⌨️ 문제 풀이 학생의 수만큼 순회하여 남자일 때와 여자일 때를 구분하여 작업을 할 수 있도록 조건문을 짠다.\n(내가 문제를 푸는 방식은 이러하다. 이렇게 큰 틀을 짜놓고 구현하면 훨씬 편하다.) 남자는 지문에 나오는 것처럼, 스위치의 상태가 1일 때 0으로, 0일 때 1로 변경해주면 된다. 여자의 경우, 좌우로 대칭하는지 찾기 전에, 현재 학생이 받은 수에 1씩 더하고 빼서 스위치로 입력받은 리스트 범위 내인지부터 확인한다.\n범위 내인 경우, 현재 번호의 양쪽 데이터가 같은지 확인하고, 일치한다면 left, right 변수에 좌측, 우측의 인덱스 번호를 넣어준다. while 반복문으로 양측의 데이터가 같지 않을 때, 리스트의 범위를 벗어날 때 break를 걸어주고\nleft와 right를 갱신한다. while 반복이 끝난 후, range(left, right + 1) 범위의 리스트 원소를 변경해준다.\n0 일때 1, 1 일때, 0 20개씩 출력하는 것은 아래와 같이 for 문에서 조절해주면 된다. for i in range(1, n, 20): print(*switch[i:i+20]) 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) switch = [0] + list(map(int, stdin.readline().split())) for i in range(int(stdin.readline())): g, num = map(int, stdin.readline().split()) if g == 1: for i in range(num, n + 1, num): switch[i] = 1 if switch[i] == 0 else 0 elif g == 2: if num + 1 \u0026gt; n or num - 1 \u0026lt; 1: switch[num] = 1 if switch[num] == 0 else 0 else: if switch[num + 1] == switch[num - 1]: left = num - 1 right = num + 1 while 1: if left - 1 \u0026lt; 1 or right + 1 \u0026gt; n: break if switch[left - 1] != switch[right + 1]: break else: left -= 1 right += 1 for i in range(left, right + 1): switch[i] = 1 if switch[i] == 0 else 0 else: switch[num] = 1 if switch[num] == 0 else 0 for i in range(1, n, 20): print(*switch[i:i+20]) 💾 느낀점 조건문만 충실히 지키면 잘 풀 수 있는 문제였다. 여학생이 바꾸는 스위치들의 조건을 구현하는데에 살짝 힘이 들뻔했다. 링크드리스트로 풀수 있을 것 같다는 생각을 했다. 다음번에는 링크드 리스트로 구현하는 연습을 해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1244-%EC%8A%A4%EC%9C%84%EC%B9%98-%EC%BC%9C%EA%B3%A0-%EB%81%84%EA%B8%B0-with-python/","summary":"📌 BOJ 1244 스위치 켜고 끄기 💡 조건 및 풀이 첫째 줄은 스위치 개수. 스위치 개수는 100 이하인 양의 정수.\n둘째 줄은 각 스위치의 상태. 켜져 있으면 1, 꺼져있으면 0이라고 표시\n셋째 줄에는 학생 수. 학생수는 100 이하인 양의 정수\n넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수. 남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다.","title":"[BOJ] 1244 스위치 켜고 끄기 with Python"},{"content":"\n📌 Programmers - 광고 삽입 💡 조건 및 풀이 동영상에 광고를 넣어야한다. 시청자가 가장 많은 구간에 광고를 넣어야한다.\n= 시청자 수 구간합이 가장 큰 곳에 광고를 넣어야한다. 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time,\n시청자들이 해당 동영상을 재생했던 구간 정보 logs 구간합을 구해 답을 이끌어내는 유형의 문제 play_time, adv_time은 길이 8로 고정된 문자열\nplay_time, adv_time은 HH:MM:SS 형식이며,\n00:00:01 \u0026lt;= play_time, adv_time \u0026lt;= 99:59:59 공익광고 재생시간은 동영상 재생시간보다 짧거나 같다. 1 \u0026lt;= logs \u0026lt;= 300000 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;02:03:55\u0026#34;, \u0026#34;00:14:15\u0026#34;, [\u0026#34;01:20:15-01:45:14\u0026#34;, \u0026#34;00:40:31-01:00:00\u0026#34;, \u0026#34;00:25:50-00:48:29\u0026#34;, \u0026#34;01:30:59-01:53:29\u0026#34;, \u0026#34;01:37:44-02:02:30\u0026#34;])) 실행결과 \u0026#34;01:30:59\u0026#34; ⌨️ 문제 풀이 play_time, adv_time (동영상 재생 길이, 광고 재생 길이)를 각각 str 타입에서 int 타입으로 변경한다. def str_to_int(time): h, m, s = time.split(\u0026#39;:\u0026#39;) return int(h) * 3600 + int(m) * 60 + int(s) 각 구간의 시청자들의 수를 기록할 배열을 만든다. all_time = [0 for i in range(play_time + 1)] logs 를 순회하면서 시청 시작 시간에 시청자 수 + 1\n시청 종료 시간에 시청자 수 - 1 구간별 시청자 기록을 위해 all_time 배열을 순회하면서, 이전 배열의 값을 가지고 현재 배열에 더해주는 작업을 해줍니다. for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] 모든 구간의 시청자 누적 기록을 위해 다시 한번 4번의 작업을 해줍니다. 누적된 구간별 시청자 수의 정보가 저장된 배열을 순회하면서 시청자가 가장 많은 구간을 탐색합니다. # 가장 시청자 수가 많은 구간을 탐색 for i in range(adv_time - 1, play_time): # i가 공익 광고 시청 시간보다 빠를 때 if i \u0026gt;= adv_time: # 지금까지 최대 누적 시청자 수가 (총 누적 시청자 수 - 해당 구간 시청자 수) 보다 작으면? if most_view \u0026lt; all_time[i] - all_time[i - adv_time]: # 지금까지 최대 누적 시청자 수를 갱신 most_view = all_time[i] - all_time[i - adv_time] # 최대 누적 시청자 수에 해당하는 구간을 갱신 max_time = i - adv_time + 1 else: # 최대 시청자 수가 현재 탐색하는 시간대의 총 누적 시청자 수보다 적을 때 if most_view \u0026lt; all_time[i]: # 최대 시청자 수와 그에 해당하는 시간대를 갱신 most_view = all_time[i] max_time = i - adv_time + 1 최대 시청자가 있는 광고 삽입 시간을 HH:MM:SS 형식으로 변환하여 return 합니다. 🖥 소스 코드 def solution(play_time, adv_time, logs): play_time = str_to_int(play_time) adv_time = str_to_int(adv_time) all_time = [0 for i in range(play_time + 1)] for l in logs: start, end = l.split(\u0026#39;-\u0026#39;) start = str_to_int(start) end = str_to_int(end) all_time[start] += 1 all_time[end] -= 1 for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] most_view = 0 max_time = 0 for i in range(adv_time - 1, play_time): if i \u0026gt;= adv_time: if most_view \u0026lt; all_time[i] - all_time[i - adv_time]: most_view = all_time[i] - all_time[i - adv_time] max_time = i - adv_time + 1 else: if most_view \u0026lt; all_time[i]: most_view = all_time[i] max_time = i - adv_time + 1 return int_to_str(max_time) def str_to_int(time): h, m, s = time.split(\u0026#39;:\u0026#39;) return int(h) * 3600 + int(m) * 60 + int(s) def int_to_str(time): h = time // 3600 h = \u0026#39;0\u0026#39; + str(h) if h \u0026lt; 10 else str(h) time = time % 3600 m = time // 60 m = \u0026#39;0\u0026#39; + str(m) if m \u0026lt; 10 else str(m) time = time % 60 s = \u0026#39;0\u0026#39; + str(time) if time \u0026lt; 10 else str(time) return h + \u0026#39;:\u0026#39; + m + \u0026#39;:\u0026#39; + s 💾 느낀점 문자열 타입의 시간 형식 데이터는 각 시간, 분, 초를 합쳐 숫자로 만들어 다루는 것이 편하다. 구간별 시청자 기록과 모든 구간의 시청자 누적 기록을 하는 부분에서 많은 이해가 필요했다.\n스스로 이해하지 못해 다른 블로그를 참고하여 코드를 작성했다. 모든 구간의 시청자 누적 기록을 순회하는 부분에서도 이해가 어려워 여러번 코드를 디버깅했다.\n이해를 하는 방향으로 코드를 보고 나의 방식으로 코드를 작성하는 시간이 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EA%B4%91%EA%B3%A0-%EC%82%BD%EC%9E%85-with-python/","summary":"📌 Programmers - 광고 삽입 💡 조건 및 풀이 동영상에 광고를 넣어야한다. 시청자가 가장 많은 구간에 광고를 넣어야한다.\n= 시청자 수 구간합이 가장 큰 곳에 광고를 넣어야한다. 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time,\n시청자들이 해당 동영상을 재생했던 구간 정보 logs 구간합을 구해 답을 이끌어내는 유형의 문제 play_time, adv_time은 길이 8로 고정된 문자열\nplay_time, adv_time은 HH:MM:SS 형식이며,\n00:00:01 \u0026lt;= play_time, adv_time \u0026lt;= 99:59:59 공익광고 재생시간은 동영상 재생시간보다 짧거나 같다.","title":"[Programmers] 광고 삽입 with Python"},{"content":"\n📌 Programmers - 표 편집 💡 조건 및 풀이 표의 원본 행의 개수를 나타내는 변수 n\n5 ≤ n ≤ 1,000,000 처음에 선택되어 있는 행의 위치 k\n0 ≤ k \u0026lt; n 수행한 명령어들이 담긴 문자열 배열 cmd\n1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 \u0026quot;U X\u0026quot;, \u0026quot;D X\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;Z\u0026quot; 중 하나 Linked List 자료구조 문제 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않는다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) \u0026ldquo;Z\u0026quot;가 명령어로 주어지는 경우는 없다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 🔖 예제 및 실행결과 예제 print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;])) print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;U 1\u0026#34;, \u0026#34;C\u0026#34;])) 실행결과 \u0026#34;OOOOXOOO\u0026#34; \u0026#34;OOXOXOOO\u0026#34; ⌨️ 문제 풀이 Double Linked List 자료구조를 알고, 구현할 수 있다면 풀이가 가능한 문제이다. Double Linked List 는 쉽게 말해 각 노드의 포인터가 다음, 혹은 이전의 노드를 가리키는 정보를 두개 담고 있다. 연결리스트를 사용해 cmd 에 있는 명령을 수행하기 전의 원본 표의 데이터를 입력한다. class Node: def __init__(self, data=None, state=1): # 노드의 정보, 값을 저장 self.value = data # 노드가 가지고 있을 전, 후를 가리키는 값은 None으로 초기화 self.next = None self.priv = None def __init__(self): self.header = Node() self.tail = Node() self.header.next = self.tail self.header.priv = self.header self.tail.next = self.tail self.tail.priv = self.header self.pointer = self.header linkedlist = DoubleLinkedList() pointer = linkedlist.header for i in range(n): # 노드를 추가함 linkedlist.add(Node(i)) 가장 처음에 가리키고 있는 포인터를 정해주어야하기 때문에 현재 연결리스트의 포인터를 k로 맞춰주는 작업을 한다. # 포인터의 값이 k와 다르면 계속 반복 while pointer.value != k: # 포인터는 현재 포인터의 다음 것을 가리킨다. pointer = pointer.next cmd를 순회하면서 요쳉에 대한 작업을 진행한다.\n삭제를 진행하고, 복구를 하는 작업은 stack(list) 을 하나 만들어, 삭제가 진행됐을 때 저장한다.\n복구를 할 때는 리스트에서 pop 을 하여 데이터를 꺼내오면 된다. 삭제의 작업은 다음과 같다.\n삭제될 노드를 미리 stack 에 넣어준 뒤,\n현재의 포인터 기준으로 이전 노드에서 자신을 가리키던 것을 다음 노드를 가리키게 해주면 된다. def delete(self, pointer): if pointer.priv == self.header: self.header.next = pointer.next pointer.next.priv = self.header return self.header.next elif pointer.next == self.tail: _pointer = pointer.priv self.tail.priv = _pointer _pointer.next = self.tail return _pointer else: _pointer = pointer.next pointer.priv.next = pointer.next pointer.next.priv = pointer.priv return _pointer 복구의 작업은 다음과 같다.\n복구될 노드를 stack에서 뽑아 변수에 저장한 뒤, 추가를 해준다. def add(self, node): self.pointer.next = node node.priv = self.pointer node.next = self.tail self.pointer = node 가리키는 곳을 이동하는 것은 이동하려는 칸의 수만큼 반복문을 통해 옮겨주면 된다. def move(self, pointer, v, step): for _ in range(step): if v == \u0026#39;D\u0026#39;: pointer = pointer.next else: pointer = pointer.priv return pointer 🖥 소스 코드 class Node: def __init__(self, data=None, state=1): # 노드의 정보, 값을 저장 self.value = data # 노드가 가지고 있을 전, 후를 가리키는 값은 None으로 초기화 self.next = None self.priv = None class DoubleLinkedList: def __init__(self): self.header = Node() self.tail = Node() self.header.next = self.tail self.header.priv = self.header self.tail.next = self.tail self.tail.priv = self.header self.pointer = self.header def add(self, node): self.pointer.next = node node.priv = self.pointer node.next = self.tail self.pointer = node def move(self, pointer, v, step): for _ in range(step): if v == \u0026#39;D\u0026#39;: pointer = pointer.next else: pointer = pointer.priv return pointer def delete(self, pointer): if pointer.priv == self.header: self.header.next = pointer.next pointer.next.priv = self.header return self.header.next elif pointer.next == self.tail: _pointer = pointer.priv self.tail.priv = _pointer _pointer.next = self.tail return _pointer else: _pointer = pointer.next pointer.priv.next = pointer.next pointer.next.priv = pointer.priv return _pointer def insert(self, pointer): pointer.priv.next = pointer pointer.next.priv = pointer def get_answer(n, linkedlist): # 답이 될 리스트 생성 answer = [\u0026#39;X\u0026#39; for _ in range(n)] # 연결리스트의 첫 헤더부터 포인터를 따라 순차적으로 방문하여 # answer 원소 갱신 pointer = linkedlist.header.next while pointer != linkedlist.tail: answer[pointer.value] = \u0026#39;O\u0026#39; pointer = pointer.next return \u0026#39;\u0026#39;.join(answer) def solution(n, k, cmd): # double linked list 초기화 linkedlist = DoubleLinkedList() # 포인터 설정 pointer = linkedlist.header # 삭제 요청 수행 시 삭제된 노드를 넣을 쓰레기통 stack = [] for i in range(n): # 노드를 추가함 linkedlist.add(Node(i)) # 포인터의 값이 k와 다르면 계속 반복 while pointer.value != k: # 포인터는 현재 포인터의 다음 것을 가리킨다. pointer = pointer.next # 요청 문자에 대하 수행 시작 for string in cmd: # 삭제 요청 if string == \u0026#39;C\u0026#39;: # 현재 삭제될 포인터를 쓰레기통에 넣음 stack.append(pointer) # 연결 리스트에서 노드를 삭제 pointer = linkedlist.delete(pointer) # 복구 요청 elif string == \u0026#39;Z\u0026#39;: # 쓰레기 통에 가장 마지막으로 추가된 노드 추출 # == 연결 리스트에서 가장 최근에 삭제된 노드 _pointer = stack.pop() # 연결리스트에 삽입 linkedlist.insert(_pointer) else: v, step = string.split() # 포인터 이동 pointer = linkedlist.move(pointer, v, int(step)) # 답 만들기 answer = get_answer(n, linkedlist) return answer print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;])) print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;U 1\u0026#34;, \u0026#34;C\u0026#34;])) 💾 느낀점 문제를 풀지 못해서 다른 분의 아이디어를 참고하여 연결리스트를 먼저 구현해보고자 했었다.\n자료구조를 class 형식으로 구현하는 연결리스트에 놀랬다.\n처음보는 자료구조였고, 감탄할 수밖에 없는 풀이였다.\n그 후 이중 연결 리스트를 보면서 비슷한 유형의 문제가 나온다면\n연결리스트를 구현해서 풀어보고 싶다는 생각을 했다. 단순히 stack에 삭제한 노드 번호를 넣고, 노드번호를 이분탐색으로 제자리에 복구하려는 시도를 했으나\n구현부분이 까다롭고 구현하면서도 조금씩 제한되고 구현하기에 어려운 부분이 있어 풀이를 참고 했다. 현재까지 2회 풀었는데, 아직 이전 소스를 참고하지 않고 완벽하게 이중 연결 리스트를 구현하기가 어려웠다.\n매일 볼때마다 조금은 새로운 이중 연결 리스트 구현 방법의 숙달과 관련 문제 풀이가 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%ED%91%9C-%ED%8E%B8%EC%A7%91-with-python/","summary":"📌 Programmers - 표 편집 💡 조건 및 풀이 표의 원본 행의 개수를 나타내는 변수 n\n5 ≤ n ≤ 1,000,000 처음에 선택되어 있는 행의 위치 k\n0 ≤ k \u0026lt; n 수행한 명령어들이 담긴 문자열 배열 cmd\n1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 \u0026quot;U X\u0026quot;, \u0026quot;D X\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;Z\u0026quot; 중 하나 Linked List 자료구조 문제 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않는다.","title":"[Programmers] 표 편집 with Python"},{"content":"\n📌 Programmers - 순위 검색 💡 조건 및 풀이 조건을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n를 구하는 문제\n'-' 표시는 해당 조건을 고려하지 않겠다는 의미.\n\u0026#34;cpp and - and senior and pizza 500\u0026#34; 은를 의미한다.\n\u0026quot;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026quot;\n브루트포스 알고리즘 유형의 문제에 해당한다.\n🔖 예제 및 실행결과 예제 info = [\u0026#34;java backend junior pizza 150\u0026#34;, \u0026#34;python frontend senior chicken 210\u0026#34;, \u0026#34;python frontend senior chicken 150\u0026#34;,\u0026#34;cpp backend senior pizza 260\u0026#34;, \u0026#34;java backend junior chicken 80\u0026#34;, \u0026#34;python backend senior chicken 50\u0026#34;] query = [\u0026#34;java and backend and junior and pizza 100\u0026#34;, \u0026#34;python and frontend and senior and chicken 200\u0026#34;, \u0026#34;cpp and - and senior and pizza 250\u0026#34;, \u0026#34;- and backend and senior and - 150\u0026#34;, \u0026#34;- and - and - and chicken 100\u0026#34;, \u0026#34;- and - and - and - 150\u0026#34;] 실행결과 [1,1,1,1,2,4] ⌨️ 문제 풀이 info 배열을 순회하며 얻은 데이터를 잘라 배열로 만들고, 그 배열을 각각 데이터와 점수 부분으로 나누어 준다. temp = j.split() condition = temp[:-1] score = int(temp[-1]) 지원서에 입력한 4개의 값 range(4)의 데이터를 combinations 을 이용해\n짝을 지어 각 1부터 4개까지의 경우의 수와 점수를 dict 자료구조에 넣어준다. for i in range(5): comb = list(combinations(range(4), i)) for c in comb: test_case = condition.copy() for idx in c: test_case[idx] = '-' case = ''.join(test_case) if case not in data: data[case] = [score] else: data[case].append(score) 이분탐색 라이브러리인 bisect 라이브러리를 사용해 사용을 할 것이기 때문에 dict 자료구조의 value를 정렬해준다. 파라미터로 받아온 sql을 순차적으로 돌면서 and 문자열을 \u0026lsquo;\u0026lsquo;로 바꾸어주고 split 해준다.\ntest_query 와 test_score 로 나누어주고, test_query에 해당하는 인원 중(data의 key)\ntest_score 이상의 점수를 얻은(data의 value) 인원의 수를 계산하여 answer에 입력해준다. 🖥 소스 코드 from itertools import combinations from bisect import bisect_left def solution(info, query): answer, data, sql = [], {}, [] n, m = len(info), len(query) for j in info: temp = j.split() condition = temp[:-1] score = int(temp[-1]) for i in range(5): comb = list(combinations(range(4), i)) for c in comb: test_case = condition.copy() for idx in c: test_case[idx] = \u0026#39;-\u0026#39; case = \u0026#39;\u0026#39;.join(test_case) if case not in data: data[case] = [score] else: data[case].append(score) for i in data.values(): i.sort() for i in range(m): sql = query[i].replace(\u0026#39;and\u0026#39;, \u0026#39;\u0026#39;).split() test_query = \u0026#39;\u0026#39;.join(sql[:-1]) test_score = int(sql[-1]) if test_query in data: idx = bisect_left(data[test_query], test_score) answer.append(len(data[test_query]) - idx) else: answer.append(0) return answer 💾 느낀점 모든 경우의 수를 data 에 입력하여 찾는 아이디어를 구상하는 것이 힘이 들었다. sql에 해당하는 지원자를 이분탐색으로 찾을 아이디어와 dict 자료구조를 사용할 아이디어를 떠올리니\n구현하는데에는 큰 무리가 없었던 것 같다. 포스팅 내용을 보니 아예 아이디어를 얻지 못한 분들이 보시기에 괜찮을까 라는 생각이 들면서,\n설명하는 능력이 조금 부족하다고 느낀다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%88%9C%EC%9C%84-%EA%B2%80%EC%83%89-with-python/","summary":"📌 Programmers - 순위 검색 💡 조건 및 풀이 조건을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n를 구하는 문제\n'-' 표시는 해당 조건을 고려하지 않겠다는 의미.\n\u0026#34;cpp and - and senior and pizza 500\u0026#34; 은를 의미한다.\n\u0026quot;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026quot;\n브루트포스 알고리즘 유형의 문제에 해당한다.\n🔖 예제 및 실행결과 예제 info = [\u0026#34;java backend junior pizza 150\u0026#34;, \u0026#34;python frontend senior chicken 210\u0026#34;, \u0026#34;python frontend senior chicken 150\u0026#34;,\u0026#34;cpp backend senior pizza 260\u0026#34;, \u0026#34;java backend junior chicken 80\u0026#34;, \u0026#34;python backend senior chicken 50\u0026#34;] query = [\u0026#34;java and backend and junior and pizza 100\u0026#34;, \u0026#34;python and frontend and senior and chicken 200\u0026#34;, \u0026#34;cpp and - and senior and pizza 250\u0026#34;, \u0026#34;- and backend and senior and - 150\u0026#34;, \u0026#34;- and - and - and chicken 100\u0026#34;, \u0026#34;- and - and - and - 150\u0026#34;] 실행결과 [1,1,1,1,2,4] ⌨️ 문제 풀이 info 배열을 순회하며 얻은 데이터를 잘라 배열로 만들고, 그 배열을 각각 데이터와 점수 부분으로 나누어 준다.","title":"[Programmers] 순위 검색 with Python"},{"content":"\n📌 BOJ 10775 공항 💡 조건 및 풀이 공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다. 공항에는 P개의 비행기가 순서대로 도착할 예정. i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다. Union - Find 알고리즘 유형의 문제 비행기를 최대 몇 대 도킹시킬 수 있는지 구하는 문제. 게이트의 수 G (1 ≤ G ≤ 105)\n비행기의 수 P (1 ≤ P ≤ 105)\nP개의 줄에 gi (1 ≤ gi ≤ G) 🔖 예제 및 실행결과 예제 4 3 4 1 1 실행결과 2 ⌨️ 문제 풀이 각 비행기의 번호를 입력 받을 때 1부터 시작하기 때문에 게이트 수 + 1 만큼 배열 parent 를 생성한다. 배열의 원소값은 각 인덱스 값과 동일하게 하는데, 이것을 부모를 자신으로 둔 것이라고 생각하면 좋다. 비행기의 번호 gi 를 입력 받아 gi의 부모를 찾는다. data = find_parent(parent, gi) 만약 data 가 존재하지 않는 0번 게이트에 도킹을 해야할 경우 반복문을 중단한다. 4번 이 아니라면 res += 1. gi 번 비행기가 data 번 게이트에 도킹을 했고, 그 게이트에는 다른 비행기가 도킹 할 수 없으니\ndata - 1 번호의 게이트를 가리키는 게이트가 됐다고 생각하자. union_parent(parent, data, data - 1) 순서대로 들어오는 비행기를 반복적으로 수행하다, 4번 의 조건에 걸리는 경우 반복문을 중단하고 결과를 출력한다. 🖥 소스 코드 from sys import stdin def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union_parent(parent, a, b): a = find_parent(parent,a) b = find_parent(parent,b) if a \u0026gt;b: parent[a] = b else: parent[b] = a g = int(stdin.readline()) p = int(stdin.readline()) parent = [x for x in range(g + 1)] res = 0 for i in range(p): gi = int(stdin.readline()) data = find_parent(parent, gi) if data == 0: break res += 1 union_parent(parent, data, data - 1) print(res) 💾 느낀점 내가 좋아하는 Union-Find 문제이다. 처음 풀어보는 유형이라 조금 헷갈리긴 했지만, 게이트와 비행기의 관계를 조금 파악하니\n소스코드라도 짜면서 시도해볼 수 있었다. 유파 알고리즘 문제는 find_parent, union_parent 의 로직을 외워두니 훨~씬 수월했다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-10775-%EA%B3%B5%ED%95%AD-with-python/","summary":"📌 BOJ 10775 공항 💡 조건 및 풀이 공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다. 공항에는 P개의 비행기가 순서대로 도착할 예정. i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다. Union - Find 알고리즘 유형의 문제 비행기를 최대 몇 대 도킹시킬 수 있는지 구하는 문제. 게이트의 수 G (1 ≤ G ≤ 105)","title":"[BOJ] 10775 공항 with Python"},{"content":"\n📌 Programmers - 메뉴 리뉴얼 💡 조건 및 풀이 orders 배열의 크기는 2 이상 20 이하. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열.\n각 문자열은 알파벳 대문자로만 이루어져 있으며 중복은 허용 안함. course 배열의 크기는 1 이상 10 이하.\ncourse 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return\n배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬\n만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return\n무조건 return 하는 배열의 길이가 1 이상 Python 조합(combinations) 라이브러리를 사용해 구현\ndict를 사용해도 되는 문제.\n정렬이 중요한 문제. 각 손님은 단품메뉴를 2개 이상 주문해야 한다. 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함 🔖 예제 및 실행결과 예제 print(solution([\u0026#34;ABCFG\u0026#34;, \u0026#34;AC\u0026#34;, \u0026#34;CDE\u0026#34;, \u0026#34;ACDE\u0026#34;, \u0026#34;BCFG\u0026#34;, \u0026#34;ACDEH\u0026#34;], [2, 3, 4])) 실행결과 [\u0026#34;AC\u0026#34;, \u0026#34;ACDE\u0026#34;, \u0026#34;BCFG\u0026#34;, \u0026#34;CDE\u0026#34;] ⌨️ 문제 풀이 주문을 받은 orders 배열을 순차적으로 순회할 반복문.\n순회하며 메뉴들을 리스트로 만들어 정렬.\n코스를 만들 메뉴 개수를 순회할 반복문. \u0026laquo; 여기까지 2중 반복문. j\n조합 라이브러리를 사용해 3번 반복문에서 나오는 코스의 메뉴개수만큼 메뉴를 뽑아서\n중복을 없앤 뒤 t문자열에 저장. (t는 j 개를 뽑아 만든 메뉴의 조합입니다.)\nlist(set(combinations(data, j))) # set()은 중복을 없애줍니다! t 가 점수판에 없으면 새로 등록시켜 1점 부여\nt 가 점수판에 있으면 1점 부여\n최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합 만 해당하기 때문에\nscore에 저장된 점수가 1점 이상이라면 new_score에 (메뉴, 점수) 형식으로 저장 후 점수를 기준으로 정렬\n\u0026#34;\u0026#34;\u0026#34; # lambda 설명 x 를 x[1] 기준으로 정렬할건데, -가 붙으면 역순입니다. \u0026#34;\u0026#34;\u0026#34; new_score.sort(key=lambda x: -x[1]) 마지막으로 코스요리를 구성할 메뉴 개수를 순회하면서 new_score에 넣은 코스메뉴 후보들을 검사하면서\n정답으로 반환할 배열 answer에 넣어주고, 정렬을 한 뒤 반환 시켜준다.\n🖥 소스 코드 from itertools import combinations def solution(orders, course): answer = [] score = {} n = len(orders) for i in range(n): data = sorted(list(orders[i])) for j in course: for k in list(set(combinations(data, j))): t = \u0026#39;\u0026#39;.join(k) if t in score: score[t] += 1 else: score[t] = 1 new_score = [] for menu, num in score.items(): if num \u0026gt; 1: new_score.append((menu, num)) new_score.sort(key=lambda x: -x[1]) for i in course: max_order = 0 for c, num in new_score: if len(c) == i: if max_order \u0026lt;= num: max_order = num answer.append(c) else: break answer.sort() return answer 💾 느낀점 정렬을 할 때 lambda를 많이 사용한게 도움이 되었다. combinations를 사용해서 번거로운 일이 적어서 좋았다.\n이런 간편한 라이브러리를 알고 있다는 것보다 사용할 때를 알고 있다는게 기분 좋았다. 카카오 기춟문제는 문제도 길고 조건도 자세하게 써있는데 눈에 잘 안들어온다.\n아직 문제 압축능력이 부족한 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC-with-python/","summary":"📌 Programmers - 메뉴 리뉴얼 💡 조건 및 풀이 orders 배열의 크기는 2 이상 20 이하. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열.\n각 문자열은 알파벳 대문자로만 이루어져 있으며 중복은 허용 안함. course 배열의 크기는 1 이상 10 이하.\ncourse 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return\n배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬","title":"[Programmers] 메뉴 리뉴얼 with Python"},{"content":"\n📌 BOJ 2143 두 배열의 합 💡 조건 및 풀이 (-1,000,000,000 ≤ T ≤ 1,000,000,000) (1 ≤ n ≤ 1,000) (1 ≤ m ≤ 1,000) 누적합 유형의 문제 두 배열의 부분배열을 사용하여 합을 구해 T를 만들 수 있는 개수를 구한다. 🔖 예제 및 실행결과 예제 5 4 1 3 1 2 3 1 3 2 실행결과 7 ⌨️ 문제 풀이 A 부분 배열의 합들과 B 부분 배열의 합들을 더해 T가 만들어지는 경우의 수를 구하는 문제였다.\n두 배열을 각 구간에 해당하는 누적합을 각각의 dict 자료구조에 넣고, 중복되어 나오는 경우 +1 을 해준다.\nA 배열의 키 값을 순차적으로 순회하면서\n구하고자 하는 t 값에서 A 배열의 키 값을 빼준 값이 B배열의 키값으로 있다면,\nres에 해당 B배열의 값과 A배열의 값을 곱하여 더해준다.\nfor key in Asum.keys(): if (t - key) in Bsum: res += Bsum[t - key] * Asum[key] 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(int(1e9)) t = int(stdin.readline()) n = int(stdin.readline()) A = list(map(int, stdin.readline().split())) m = int(stdin.readline()) B = list(map(int, stdin.readline().split())) Asum = {} for i in range(n): for j in range(i, n): k = sum(A[i:j + 1]) if k in Asum: Asum[k] += 1 else: Asum[k] = 1 Bsum = {} for i in range(m): for j in range(i, m): k = sum(B[i:j + 1]) if k in Bsum: Bsum[k] += 1 else: Bsum[k] = 1 res = 0 for key in Asum.keys(): if (t - key) in Bsum: res += Bsum[t - key] * Asum[key] print(res) 💾 느낀점 처음에 아이디어가 떠오르지않아 힘들어했다. 수학, DP가 제일 약한 것 같다는 생각이 들었다. Dict 자료구조를 좋아하는데 이렇게 사용을 해봐서 더 좋았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2143-%EB%91%90-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 2143 두 배열의 합 💡 조건 및 풀이 (-1,000,000,000 ≤ T ≤ 1,000,000,000) (1 ≤ n ≤ 1,000) (1 ≤ m ≤ 1,000) 누적합 유형의 문제 두 배열의 부분배열을 사용하여 합을 구해 T를 만들 수 있는 개수를 구한다. 🔖 예제 및 실행결과 예제 5 4 1 3 1 2 3 1 3 2 실행결과 7 ⌨️ 문제 풀이 A 부분 배열의 합들과 B 부분 배열의 합들을 더해 T가 만들어지는 경우의 수를 구하는 문제였다.","title":"[BOJ] 2143 두 배열의 합 with Python"},{"content":"\n📌 BOJ 1799 비숍 💡 조건 및 풀이 체스판의 크기는 10 이하의 자연수 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0 대각선 방향으로 움직이는 비숍이 이동할 수 있는 경로에 비숍을 놓을 수 없다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 1 실행결과 7 ⌨️ 문제 풀이 흑과 백을 구분할 수 있는 체스판을 True 와 False 를 사용해 다시 만든다. 비숍을 놓을 수 있는 좌표를 흑과 백으로 나누어 각각 black 과 white 리스트에 넣어준다. 비숍을 놓고, 놓을 수 없는 곳을 표시할 때 사용할 isused 리스트를 생성한다. 재귀함수를 타고 각 좌표에 해당하는 곳이 isused01, isused02 모두 사용 중이거나\n놓을 수 없는 자리라면 index를 하나 늘리고 다시 재귀. 4번에 해장하지 않으면 비숍을 놓고 놓은 비숍 개수와 index를 1씩 늘리고 재귀 재귀를 빠져나오면 직전에 놓았던 비숍의 정보를 제거하고 다음 좌표로 넘어가기 위해 index + 1 하고 재귀 index값이 흰색 혹은 검정색 비숍 좌표의 길이와 같다면 검정색의 최댓값과 흰색의 최댓값을 각각 Bcnt와 Wcnt에 저장한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) chess_map = [] black = [] white = [] color = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): color[i][j] = (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0) for i in range(n): chess_map.append(list(map(int, input().split()))) for j in range(n): # True가 검은색 if chess_map[i][j] == 1 and color[i][j] == 1: black.append((i, j)) # False가 흰색 if chess_map[i][j] == 1 and color[i][j] == 0: white.append((i, j)) # 검은색인 경우 Bcnt = 0 # 흰색인 경우 Wcnt = 0 isused01 = [0] * (n * 2 - 1) isused02 = [0] * (n * 2 - 1) def fun(bishop, index, count): global Bcnt, Wcnt if index == len(bishop): rx, ry = bishop[index - 1] # 블랙이면 Bcnt 최대값 if color[rx][ry]: Bcnt = max(Bcnt, count) # 흰색이면 Wcnt 최대값 else: Wcnt = max(Wcnt, count) return x, y = bishop[index] if isused01[x + y] or isused02[x - y + n - 1]: fun(bishop, index + 1, count) else: isused01[x + y] = 1 isused02[x - y + n - 1] = 1 fun(bishop, index + 1, count + 1) isused01[x + y] = 0 isused02[x - y + n - 1] = 0 fun(bishop, index + 1, count) if len(black) \u0026gt; 0: fun(black, 0, 0) if len(white) \u0026gt; 0: fun(white, 0, 0) print(Bcnt + Wcnt) 💾 느낀점 무지성 백트래킹으로 풀려다가 시간초과가 떴다. 백트래킹을 잘하려면 재귀를 잘 짤줄 알아야하는데 아직도 재귀함수가 약점이다. 흑, 백 칸을 구분지어 구현하는데에도 헷갈리는 부분이 있었다. 함수를 구현하고서도 이해가 안되는 부분이 있어서 별표를 많이 쳐놨다. 다시는 풀고 싶지 않은 유형이지만, 그래도 옛날보다는 나아지는 느낌을 받는다.\n다시 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1799-%EB%B9%84%EC%88%8D-with-python/","summary":"📌 BOJ 1799 비숍 💡 조건 및 풀이 체스판의 크기는 10 이하의 자연수 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0 대각선 방향으로 움직이는 비숍이 이동할 수 있는 경로에 비숍을 놓을 수 없다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 1 실행결과 7 ⌨️ 문제 풀이 흑과 백을 구분할 수 있는 체스판을 True 와 False 를 사용해 다시 만든다.","title":"[BOJ] 1799 비숍 with Python"},{"content":"\n📌 BOJ 1967 트리의 지름 💡 조건 및 풀이 노드의 개수 (1 ≤ n ≤ 10,000) 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호\n두 번째 정수는 자식 노드\n세 번째 정수는 간선의 가중치 부모 노드의 번호가 작은 것이 먼저 입력되고,\n부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. BFS 유형의 문제 루트 노드의 번호는 항상 1\n간선의 가중치는 100보다 크지 않은 양의 정수 트리에 존재하는 모든 경로들 중, 가장 긴 경로를 출력하는 문제이다. 🔖 예제 및 실행결과 예제 12 1 2 3 1 3 2 2 4 5 3 5 11 3 6 9 4 7 1 4 8 7 5 9 15 5 10 4 6 11 6 6 12 10 실행결과 45 ⌨️ 문제 풀이 BFS 문제 였지만, 트리의 길이를 구하는 문제라고 하기에 당황을 했다. BFS 를 통해 루트 노드인 1 부터 탐색을 시작해서 가중치가 가장 높은 것을\n반환받아 변수에 담는다. 변수에는 (node, cost) 형식으로 있는데, 이 node 번호를 다시 BFS에 넣어 처리한다. 3번을 통해서 반환 된 (node, cost) 에서 cost가 답이 된다. 다시 설명하자면,\n2번에서 BFS 로 가장 가중치가 많이 쌓이는 노드를 탐색한다. 이를 A-node 라고 하고,\n3번에서 A-node에서부터 가장 가중치가 많이 쌓이는 곳으로 순회를 하여 B-node라고 한다.\n문제에서 설명하듯, 이 두 노드가 가장 높은 가중치를 가지고 있는 경로 즉, 지름이 된다. 🖥 소스 코드 from sys import stdin from collections import deque n = int(stdin.readline()) tree = [[] for _ in range(n + 1)] for _ in range(n - 1): a, b, c = map(int, stdin.readline().split()) tree[a].append((b, c)) tree[b].append((a, c)) def bfs(i): visited = set() q = deque() q.append((i, 0)) visited.add(i) res = (0, 0) while q: now, cost = q.popleft() for n, c in tree[now]: if n not in visited: visited.add(n) t = c + cost q.append((n, t)) if res[1] \u0026lt; t: res = (n, t) return res a = bfs(1) b = bfs(a[0]) print(b[1]) 💾 느낀점 BFS를 응용하여 푸는 문제였다. 두번이나 돌릴 생각을 못해서 헤맸다. 문제를 해석하고 압축하는 능력을 더 키우고, 생각의 전환을 하는 습관을 길러야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1967-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84-with-python/","summary":"📌 BOJ 1967 트리의 지름 💡 조건 및 풀이 노드의 개수 (1 ≤ n ≤ 10,000) 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호\n두 번째 정수는 자식 노드\n세 번째 정수는 간선의 가중치 부모 노드의 번호가 작은 것이 먼저 입력되고,\n부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. BFS 유형의 문제 루트 노드의 번호는 항상 1\n간선의 가중치는 100보다 크지 않은 양의 정수 트리에 존재하는 모든 경로들 중, 가장 긴 경로를 출력하는 문제이다.","title":"[BOJ] 1967 트리의 지름 with Python"},{"content":"\n📌 BOJ 13305 주유소 💡 조건 및 풀이 도시의 개수 2 \u0026lt;= N \u0026lt;= 100000 도시를 연결하는 간선의 길이가 N-1개 주어진다. 그리디 알고리즘 유형 문제 제일 왼쪽에서 오른쪽으로 이동하는 최소 비용을 계산 어느 도시에서 기름을 넣어 이동하는 것이 가장 비용이 저렴한지에 대해 계산하면 된다. 서브태스크 점수가 주어진다 17점 모든 주유소의 리터당 가격은 1원 41점 2 \u0026lt;= N \u0026lt;= 1000\n제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 최대 10000,\n리터 당 가격은 최대 10000 42점 원래의 제약조건 이외에 아무 제약조건이 없다. 🔖 예제 및 실행결과 예제 4 2 3 1 5 2 4 1 실행결과 18 ⌨️ 문제 풀이 도로의 길이를 저장할 리스트 dist\n주유소의 리터당 가격을 저장할 리스트 cost 가장 왼쪽에 있는 도시의 주유소의 리터당 가격을 변수 c 에 넣어준다. k-1 반복문을 실행하여 주유소의 리터 당 가격을 순회한다. 만약 현재 계산된 c 가 i 번째 리터 당 가격보다 비싸다면 c 를 갱신한다.\n그게 아니라면, 결과값을 저장할 res에 리터 당 가격 * i번째 도로의 길이를 더해준다 🖥 소스 코드 from sys import stdin k = int(stdin.readline()) dist = list(map(int, stdin.readline().split())) cost = list(map(int, stdin.readline().split())) res = 0 c = cost[0] for i in range(k - 1): if c \u0026gt; cost[i]: c = cost[i] res += c * dist[i] print(res) 💾 느낀점 그리디 문제라고해서 얕봤다가 로직이 한순간 꼬여서 고생을 좀 했다. 리스트를 따로 처리해 사용하다가 머리가 순간 복잡해지는 것을 방지하기 위해 노력을 해야겠다. 그림을 그려 차분히 로직을 생각하고 구현하는 습관을 길러야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-13305-%EC%A3%BC%EC%9C%A0%EC%86%8C-with-python/","summary":"📌 BOJ 13305 주유소 💡 조건 및 풀이 도시의 개수 2 \u0026lt;= N \u0026lt;= 100000 도시를 연결하는 간선의 길이가 N-1개 주어진다. 그리디 알고리즘 유형 문제 제일 왼쪽에서 오른쪽으로 이동하는 최소 비용을 계산 어느 도시에서 기름을 넣어 이동하는 것이 가장 비용이 저렴한지에 대해 계산하면 된다. 서브태스크 점수가 주어진다 17점 모든 주유소의 리터당 가격은 1원 41점 2 \u0026lt;= N \u0026lt;= 1000\n제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 최대 10000,\n리터 당 가격은 최대 10000 42점 원래의 제약조건 이외에 아무 제약조건이 없다.","title":"[BOJ] 13305 주유소 with Python"},{"content":"\n📌 BOJ 6987 월드컵 💡 조건 및 풀이 6개의 국가가 있고, 총 18번의 경기를 한다. 승, 무, 패의 결과가 있으며, 승, 무, 패의 수는 6보다 작거나 같은 자연수 또는 0 백트래킹 유형의 문제 입력은 네 줄로 들어오며, 각 줄에 대해 가능한 결과 1, 불가능한 결과 0 을출력하는 문제이다 🔖 예제 및 실행결과 예제 5 0 0 3 0 2 2 0 3 0 0 5 4 0 1 1 0 4 4 1 0 3 0 2 4 1 0 1 1 3 0 0 5 1 1 3 5 0 0 4 0 1 2 2 1 2 0 3 1 0 4 0 0 5 5 0 0 3 1 1 2 1 2 2 0 3 0 0 5 1 0 4 실행결과 1 1 0 0 ⌨️ 문제 풀이 data 변수에 각 나라의 일정을 담고, res 베열에 3개씩 쪼개어 다시 넣는다. 결과를 담을 ans 변수를 0으로 초기화 시킨다. 팀끼리의 경기의 조합을 위해 itertools의 combinations를 사용.\ngame이라는 변수에 0~5번의 국가가 경기를 할 수 있는 조합을 만들어 저장한다. solution 함수에서 총 라운드를 파라미터로 입력받으며, 초기의 값은 0이다. 각 라운드를 순회하면서 res 배열의 값을 빼주면서 승, 무, 패 의 값이 남아있다면\nans = 0으로 초기화해서 불가능한 경기라고 answer 리스트에 저장하면 된다. 승에 해당하는 원소를 -1 할 때, 패에 해당하는 원소를 -1 해준다.\n무에 해당하는 원소를 -1 할 때, 무에 해당하는 다른 원소를 -1 해준다. round 값이 15라운드가 되었다면 ans의 값을 1로 변경하고 검사를 시작한다.\nres 변수에 있는 0의 값이 3개가 아니라면 ans 를 0으로 변경 🖥 소스 코드 from sys import stdin from itertools import combinations as cb def solution(round): global ans if round == 15: ans = 1 for sub in res: if sub.count(0) != 3: ans = 0 break return t1, t2 = game[round] for x, y in ((0, 2), (1, 1), (2, 0)): if res[t1][x] \u0026gt; 0 and res[t2][y] \u0026gt; 0: res[t1][x] -= 1 res[t2][y] -= 1 solution(round + 1) res[t1][x] += 1 res[t2][y] += 1 answer = [] game = list(cb(range(6), 2)) # 백트래킹 for _ in range(4): data = list(map(int, stdin.readline().split())) res = [data[i:i + 3] for i in range(0, 16, 3)] ans = 0 solution(0) answer.append(ans) print(*answer) 💾 느낀점 백트래킹을 위해 재귀함수를 구현하여 조건을 풀어내는 일련의 과정이 힘겹다.\n조금 더 백트래킹 및 재귀에 관한 문제를 풀어보아야겠다. 문제를 조금 더 내가 스스로도 납득하고 이해할 수 있게 풀어내는 방법을 생각해봐야겠다. 문제 및 로직에 대해 생각하는 시간이 너무 짧고, 문제를 풀기 위해 손부터 나가는 나쁜 습관을 고쳐야겠다. 아이디어를 떠올리지 못해 고생을 많이 했던 문제인 것 같다.\n블로그에 글을 포스팅하면서 다시 한 번 정리하니 도움이 되는 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-6987-%EC%9B%94%EB%93%9C%EC%BB%B5-with-python/","summary":"📌 BOJ 6987 월드컵 💡 조건 및 풀이 6개의 국가가 있고, 총 18번의 경기를 한다. 승, 무, 패의 결과가 있으며, 승, 무, 패의 수는 6보다 작거나 같은 자연수 또는 0 백트래킹 유형의 문제 입력은 네 줄로 들어오며, 각 줄에 대해 가능한 결과 1, 불가능한 결과 0 을출력하는 문제이다 🔖 예제 및 실행결과 예제 5 0 0 3 0 2 2 0 3 0 0 5 4 0 1 1 0 4 4 1 0 3 0 2 4 1 0 1 1 3 0 0 5 1 1 3 5 0 0 4 0 1 2 2 1 2 0 3 1 0 4 0 0 5 5 0 0 3 1 1 2 1 2 2 0 3 0 0 5 1 0 4 실행결과 1 1 0 0 ⌨️ 문제 풀이 data 변수에 각 나라의 일정을 담고, res 베열에 3개씩 쪼개어 다시 넣는다.","title":"[BOJ] 6987 월드컵 with Python"},{"content":"\n📌 BOJ 16507 어두운 건 무서워 💡 조건 및 풀이 사진 크기를 의미하는 1 \u0026lt;= R, C \u0026lt;= 1000 사진 일부분의 밝기 평균을 알아볼 개수 Q Q개의 각 줄에는 사진의 일부분을 나타내기 위한 두 꼭짓점을 의미하는 정수 r1, c1, r2, c2 가 주어진다.\n(1 ≤ r1 ≤ r2 ≤ R, 1 ≤ c1 ≤ c2 ≤ C) 누적합 문제 Q개의 각 줄에 주어진 사진에서 두 점 (r1, c1)과 (r2, c2)를 꼭짓점으로 하는 직사각형의 밝기 평균을 출력한다. 평균은 정수 나눗셈으로 몫만 취한다. 🔖 예제 및 실행결과 예제 5 6 1 4 1 3 4 9 5 1 2 8 7 5 5 8 1 2 5 3 2 1 5 3 4 2 5 5 2 1 2 3 5 2 2 4 5 실행결과 3 ⌨️ 문제 풀이 누적합 문제다.\n꼭지점을 의미하는 정수가 1부터 시작되기에 인덱스 에러를 조심해야한다.\n그래서 나는 (R + 1) * (C + 1) 크기릐 배열을 만들어 코드도 단순화 시켰다.\n입력 받은 R * C 크기의 데이터를 배열에 넣고 누적합을 구해 배열에 넣어준다.\n꼭지점 좌표를 입력받아 x좌표의 크기를 오픔차순으로 정렬시켰다.\n가장 왼쪽에 위치하고 있는 좌표를 찾으려고 했다.\n직사각형의 크기를 알아야 누적합을 이용해 찾은 밝기의 합도 나눌 수 있다.\n그래서 정렬 시킨 좌표를 사용해 직사각형의 크기를 계산했다.\n(abs(addr[0][0]-addr[1][0]) + 1) * (abs(addr[0][1]-addr[1][1]) + 1) 배열의 각 가로줄마다 따로 계산을 해주었다.\n누적합의 성질은 예를 들자면 다음과 같다.\n[4, 5, 8, 12, 21, 26] 의 배열이 있을 때, 배열의 두번째 원소부터 네번째 원소의 합을 구하려고한다.\n그렇다면 네번째 원소에서 첫번째 원소의 값을 빼주면 구하려는 값이 된다.\n🖥 소스 코드 from sys import stdin r, c, q = map(int, stdin.readline().split()) pic = [[0] * (c + 1)] for i in range(r): sum_list = [0] data = list(map(int, stdin.readline().split())) sum_list.append(data[0]) for i in range(1, c): sum_list.append(sum_list[-1] + data[i]) pic.append(sum_list) for _ in range(q): a, b, c, d = map(int, stdin.readline().split()) addr = [(a, b), (c, d)] addr.sort(key=lambda x: x[0]) res = 0 knife = (abs(addr[0][0]-addr[1][0]) + 1) * (abs(addr[0][1]-addr[1][1]) + 1) for i in range(addr[0][0], addr[1][0] + 1): res += pic[i][addr[1][1]] - pic[i][addr[0][1] - 1] print(res // knife) 💾 느낀점 누적합의 개념과 원리, 성질을 아르바이트 출근하면서 지하철에서 본 것이 큰 도움이 되었다. 인덱스 에러가 쉽게 발생할 수 있을 것 같다는 생각이 들어 다른 풀이도 생각해보았지만 큰 도움은 되지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-16507-%EC%96%B4%EB%91%90%EC%9A%B4-%EA%B1%B4-%EB%AC%B4%EC%84%9C%EC%9B%8C-with-python/","summary":"📌 BOJ 16507 어두운 건 무서워 💡 조건 및 풀이 사진 크기를 의미하는 1 \u0026lt;= R, C \u0026lt;= 1000 사진 일부분의 밝기 평균을 알아볼 개수 Q Q개의 각 줄에는 사진의 일부분을 나타내기 위한 두 꼭짓점을 의미하는 정수 r1, c1, r2, c2 가 주어진다.\n(1 ≤ r1 ≤ r2 ≤ R, 1 ≤ c1 ≤ c2 ≤ C) 누적합 문제 Q개의 각 줄에 주어진 사진에서 두 점 (r1, c1)과 (r2, c2)를 꼭짓점으로 하는 직사각형의 밝기 평균을 출력한다.","title":"[BOJ] 16507 어두운 건 무서워 with Python"},{"content":"\n📌 BOJ 17521 Byte Coin 💡 조건 및 풀이 주식 시장에서 단타를 치는 국제자본 부동산 회사를 도와 최고의 수익을 내는 문제. 일 수를 나타내는 1 \u0026lt;= n \u0026lt;= 15 초기 현금을 나타내는 W 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는\n정수 si가 주어진다(1 ≤ si ≤ 50). 단순 구현, 그리디 알고리즘 문제 🔖 예제 및 실행결과 예제 10 24 5 7 5 4 2 7 8 5 3 4 실행결과 170 ⌨️ 문제 풀이 현재 매수한 코인이 있는지의 상태를 체크할 수 있는 변수 \u0026quot;m\u0026quot; (기본값은 False)\n코인을 몇개 샀는지에 대한 정보를 넣어줄 변수 \u0026quot;coin\u0026quot; 코인이 다음 날에 가격이 상승하거나 변동이 없다?\n이미 매수한 경우, pass\n매수하지 않은 경우, 구매 코인이 다음 날에 가격이 떨어진다?\n판매 최종적으로 남아 있는 현금을 출력 🖥 소스 코드 from sys import stdin n, w = map(int, stdin.readline().split()) arr = [] for _ in range(n): arr.append(int(stdin.readline())) m = False coin = 0 for i in range(n - 1): if not m and arr[i] \u0026lt; arr[i + 1]: m = arr[i] coin = w // m w -= coin * m elif m and arr[i] \u0026gt; arr[i + 1]: w += arr[i] * coin coin, m = 0, False if m: w += coin * arr[-1] print(w) 💾 느낀점 단순 구현 및 그리디 문제였습니다. 코인을 샀는지 안샀는지에 대한 변수를 추가하여 쉽게 풀 수 있었습니다. 실제 코인 시장이나 은행처럼 x% 수익률 계산했다가 큰 코 다칠뻔했습니다. 문제를 더 확실히 읽고 압축하는 능력을 키워야겠습니다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-17521-byte-coin-with-python/","summary":"📌 BOJ 17521 Byte Coin 💡 조건 및 풀이 주식 시장에서 단타를 치는 국제자본 부동산 회사를 도와 최고의 수익을 내는 문제. 일 수를 나타내는 1 \u0026lt;= n \u0026lt;= 15 초기 현금을 나타내는 W 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는\n정수 si가 주어진다(1 ≤ si ≤ 50). 단순 구현, 그리디 알고리즘 문제 🔖 예제 및 실행결과 예제 10 24 5 7 5 4 2 7 8 5 3 4 실행결과 170 ⌨️ 문제 풀이 현재 매수한 코인이 있는지의 상태를 체크할 수 있는 변수 \u0026quot;m\u0026quot; (기본값은 False)","title":"[BOJ] 17521 Byte Coin with Python"},{"content":"\n📌 BOJ 9934 완전 이진 트리 💡 조건 및 풀이 이진 트리의 깊이를 나타내는 1\u0026lt;=K\u0026lt;=10, 깊이가 K인 이진 트리는 총 2 * K - 1 개의 노드로 이루어져 있다. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다. 이분탐색, 트리, 재귀구현 문제 모든 빌딩의 번호는 중복되지 않는다. 🔖 예제 및 실행결과 예제 3 1 6 4 3 5 2 7 실행결과 3 6 2 1 4 5 7 ⌨️ 문제 풀이 깊이가 k 인 2차원 리스트 res 를 생성하고, 이 리스트에 노드를 쌓을 것입니다. Python 리스트 자료구조의 extend() 함수를 사용했습니다.\nextend는 리스트를 리스트 안으로 넣을 때 리스트의 원소만 넣어줍니다. 입력받은 빌딩번호의 길이를 2로 나누어 값을 mid 변수에 넣어 가지고 있습니다. res에 파라미터로 받은 depth 값을 넣어줍니다.\n가장 맨 처음으로 이분탐색을 통해 뽑아낸 가운데 값이 루트 노드입니다. 가운데 값을 기준으로 양쪽을 분리해 각각 다시 이분탐색을 수행합니다. 이분 탐색을 하다가, 파라미터로 받은 arr 리스트의 길이가 1인 경우 depth 에 해당하는\n리스트에 넣어줍니다. 만들어진 트리(res)를 출력해줍니다. 파이썬으로 재귀를 구현할 때,아래의 함수를 사용해야 에러가 나지 않는 경우가 많습니다.\n쓴다고 문제될 것이 없으니, 재귀를 구현하여 문제를 푸실 때 꼭 입력하세요.\nsetrecursionlimit(int(1e9))​ 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(int(1e9)) k = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) res = [[] for _ in range(k)] def binary_separation(arr, depth): if len(arr) == 1: res[depth].extend(arr) return length = len(arr) mid = length // 2 res[depth].append(arr[mid]) binary_separation(arr[:mid], depth + 1) binary_separation(arr[mid + 1:], depth + 1) binary_separation(arr, 0) for i in range(k): if i == 0: print(res[i][0]) else: print(*res[i]) 💾 느낀점 이분탐색과 재귀를 사용하여 문제를 푸는 방식에 익숙해진 것을 느꼈다. 분할 정복 문제를 풀다가 이 문제를 푸니 훨씬 도움이 되었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-9934-%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-with-python/","summary":"📌 BOJ 9934 완전 이진 트리 💡 조건 및 풀이 이진 트리의 깊이를 나타내는 1\u0026lt;=K\u0026lt;=10, 깊이가 K인 이진 트리는 총 2 * K - 1 개의 노드로 이루어져 있다. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다. 이분탐색, 트리, 재귀구현 문제 모든 빌딩의 번호는 중복되지 않는다. 🔖 예제 및 실행결과 예제 3 1 6 4 3 5 2 7 실행결과 3 6 2 1 4 5 7 ⌨️ 문제 풀이 깊이가 k 인 2차원 리스트 res 를 생성하고, 이 리스트에 노드를 쌓을 것입니다.","title":"[BOJ] 9934 완전 이진 트리 with Python"},{"content":"\n📌 Programmers - 문자열 압축 💡 조건 및 풀이 입력 받는 의 길이는 1 \u0026lt;= s \u0026lt;= 1000, 소문자로만 이루어져 있다. 문자열을 1개 단위로 자르는 것부터 s의 길이 만큼 자르는 것까지 계산 완전탐색, 구현 문제 문자열을 자르고 숫자를 붙이는 것에서 쓸데 없는 문자가 들어가지 않도록 주의 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;aabbaccc\u0026#34;)) print(solution(\u0026#34;ababcdcdababcdcd\u0026#34;)) print(solution(\u0026#34;abcabcdede\u0026#34;)) print(solution(\u0026#34;abcabcabcabcdededededede\u0026#34;)) print(solution(\u0026#34;xababcdcdababcdcd\u0026#34;)) 실행결과 7 9 8 14 17 ⌨️ 문제 풀이 answer의 값을 s의 길이로 초기화.\ns의 길이만큼 자른것이 가장 짧을 수 있기 때문에 s의 길이로 초기화한다. 1개부터 s의 길이만큼 잘라주면서 진행을 할 것이기 때문에 1부터 s+1 까지 반복문을 진행 자른 문자열은 이미 1개만큼 잘랐기 때문에 cnt = 1 로 초기화 자른 문자열과 같은 문자열이 진행하면서 있을 경우, cnt += 1 자른 문자열과 다른 문자열이 발견되었을 경우, 검사할 문자를 교체한다\n지금까지 검사해주던 단어와 늘려온 cnt를 std에 넣어주고 다시 검사 진행. 검사가 끝난 뒤, std의 길이가 기존의 answer 보다 작다면 갱신. 🖥 소스 코드 def solution(s): k = len(s) answer = k for idx in range(1, k + 1): std = \u0026#39;\u0026#39; checker = s[0: idx] std += checker start, end = 0, idx cnt = 1 for i in range(idx, k + 1, idx): if i == k: if cnt \u0026lt;= 1: break else: std += str(cnt) break if checker == s[start + i:end + i]: cnt += 1 elif cnt \u0026lt;= 1: std += s[start + i:end + i] checker = s[start + i:end + i] continue else: std += str(cnt) cnt = 1 std += s[start + i:end + i] checker = s[start + i:end + i] answer = min(answer, len(std)) return answer 💾 느낀점 나는 구현이 매우 약하기 때문에 연습하기 굉장히 좋은 문제였던 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-with-python/","summary":"📌 Programmers - 문자열 압축 💡 조건 및 풀이 입력 받는 의 길이는 1 \u0026lt;= s \u0026lt;= 1000, 소문자로만 이루어져 있다. 문자열을 1개 단위로 자르는 것부터 s의 길이 만큼 자르는 것까지 계산 완전탐색, 구현 문제 문자열을 자르고 숫자를 붙이는 것에서 쓸데 없는 문자가 들어가지 않도록 주의 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;aabbaccc\u0026#34;)) print(solution(\u0026#34;ababcdcdababcdcd\u0026#34;)) print(solution(\u0026#34;abcabcdede\u0026#34;)) print(solution(\u0026#34;abcabcabcabcdededededede\u0026#34;)) print(solution(\u0026#34;xababcdcdababcdcd\u0026#34;)) 실행결과 7 9 8 14 17 ⌨️ 문제 풀이 answer의 값을 s의 길이로 초기화.","title":"[Programmers] 문자열 압축 with Python"},{"content":"\n📌 BOJ 2458 키 순서 💡 조건 및 풀이 1번부터 N번까지 번호가 붙여져 있는 학생들끼리 두 명씩 키를 비교했다. N명의 학생들은 모두 키가 다르다. 플로이드와샬 알고리즘으로 해결이 가능한 문제이다. 2 \u0026lt;= N \u0026lt;= 500, 0 \u0026lt;= M \u0026lt;= N(N-1)/2 M개의 줄에 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a, b가 주어진다. a, b == a가 b보다 작다 자신의 키가 몇번째인지 알 수 있는 학생의 수를 구하는 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) inf = int(1e9) graph = [[inf] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) graph[b][a] = 1 for i in range(1, n + 1): for j in range(1, n + 1): for k in range(1, n + 1): if j == k: graph[j][k] = 0 continue if graph[j][k] \u0026gt; graph[j][i] + graph[i][k]: graph[j][k] = graph[j][i] + graph[i][k] res = n for i in range(1, n + 1): checker = 1 for j in range(1, n + 1): if graph[i][j] == inf and graph[j][i] == inf: res -= 1 checker = 0 if not checker: break print(res) 🔖 예제 및 실행결과 예제 6 7 1 3 1 5 3 4 5 4 4 2 4 6 5 2 실행결과 2 ⌨️ 문제 풀이 최소 거리를 정해준다고 생각하고 플로이드 와샬을 사용하기 위해 2차원 리스트를 만들고\nINF 값을 넣어 리스트를 초기화했다. a, b 값을 입력받게 되면 a 가 b 보다 작다 라는 조건에 따라, 2차원 리스트에 graph[b].append(a) 플로이드 와샬 알고리즘 실행 자신의 키가 몇등인지 알 수있는 사람을 처음부터 N명이라고 정의한 뒤 1번 학생부터 순차적으로\n2중 반복문을 사용해 플로이드 와샬로 만든 2차원 리스트에 접근 if graph[i][j] == inf and graph[j][i] == inf:\ni번 학생이 j번 학생과의 작다, 크다의 정보가 아무것도 없다면 res -= 1 2중 반복문을 빠져나오기 위한 checker변수에 0을 넣어주고(False) 반복문 탈출 PyPy3 제출 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) inf = int(1e9) graph = [[inf] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) graph[b][a] = 1 for i in range(1, n + 1): for j in range(1, n + 1): for k in range(1, n + 1): if j == k: graph[j][k] = 0 continue if graph[j][k] \u0026gt; graph[j][i] + graph[i][k]: graph[j][k] = graph[j][i] + graph[i][k] res = n for i in range(1, n + 1): checker = 1 for j in range(1, n + 1): if graph[i][j] == inf and graph[j][i] == inf: res -= 1 checker = 0 if not checker: break print(res) 💾 느낀점 문제를 보자마자 플로이드와샬 알고리즘과 유니온-파인드가 생각났다.\n유니온-파인드로 구현을 하려다보니 절대 아닌 것 같아 플로이드와샬을 사용하기로 했다. 아는 분들의 이야기를 들어보니 BFS로 구현하셨다고 했다. 플로이드 와샬 알고리즘으로 해결했을 때, Python3 로 시간초과가 생겼으며, PyPy3 는 통과 BFS로 풀이하는 방법도 구현해봐야겠다. 문제를 풀시간은 없는데 생각할 시간이 너무 길다. 아직 숙달이 되지 못한 것이라고 생각하고 더 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-2458-%ED%82%A4-%EC%88%9C%EC%84%9C-with-python-feat.-pypy3/","summary":"📌 BOJ 2458 키 순서 💡 조건 및 풀이 1번부터 N번까지 번호가 붙여져 있는 학생들끼리 두 명씩 키를 비교했다. N명의 학생들은 모두 키가 다르다. 플로이드와샬 알고리즘으로 해결이 가능한 문제이다. 2 \u0026lt;= N \u0026lt;= 500, 0 \u0026lt;= M \u0026lt;= N(N-1)/2 M개의 줄에 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a, b가 주어진다. a, b == a가 b보다 작다 자신의 키가 몇번째인지 알 수 있는 학생의 수를 구하는 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.","title":"[BOJ] 2458 키 순서 with Python (Feat. PyPy3)"},{"content":"\n📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,\n입력받은 N이 비어있는 문자열 ''이면 break 입력받은 N이 0, -의 개수가 1이라면 print('-') (N ** 3) * '-' == 하이픈의 개수 만들어진 하이픈을 분할 정복 함수에 넣는다.\n각 파라미터는 3 ** N개의 하이픈과 인덱스 번호이다. 인덱스 번호는 세등분이 된 문자열의 각 인덱스 번호이며, 재귀를 통해 인덱스 번호가 1인\n문자열을 공백으로 만들어주면 된다. 문자열은 파라미터로 받은 문자열 길이를 3으로 나누어\n그 길이만큼 리스트를 슬라이싱해 arr 리스트에 넣는다. 반환 조건은 아래의 두가지로 만들었다. 문자열의 길이가 3이고 인덱스 번호가 1이 아닐 때에는 \u0026lsquo;- -\u0026lsquo;을 리턴 문자열의 길이가 3보다 같거나 크며, 인덱스 번호가 1일 때는 문자열의 길이만큼 공백을 반환 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) def div(s, idx): ls = len(s) if ls == 3 and idx != 1: return \u0026#39;- -\u0026#39; elif ls \u0026gt;= 3 and idx == 1: return s.replace(\u0026#39;-\u0026#39;, \u0026#39; \u0026#39;) arr = [] for i in range(0, ls, ls // 3): arr.append(string[i:i+ls//3]) k = div(arr[0], 0) + div(arr[1], 1) + div(arr[2], 2) return k while 1: k = \u0026#39;-\u0026#39; n = stdin.readline().rstrip() if n == \u0026#39;\u0026#39;: break num = (3 ** int(n)) if num == 1: print(\u0026#39;-\u0026#39;) continue string = k * num arr = div(string, 0) print(arr) 💾 느낀점 분할 정복을 사용하기로 하고 인덱스를 같이 파라미터 값으로 넣자고 생각했다.\n좋은 아이디어가 한번에 떠올라서 매우 좋았다. 성공적인 풀이였다. 재귀 사용 실력이 최악이라 사용자체가 많이 힘들었지만\n예전보다는 사용하기 매우 수월해졌다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4779-%EC%B9%B8%ED%86%A0%EC%96%B4-%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,","title":"[BOJ] 4779 칸토어 집합 with Python"},{"content":"\n📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 \u0026lt;= N \u0026lt;= 10 각 카드에 숫자가 적혀있다. 1 \u0026lt;= 숫자 \u0026lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions\npermutations라는 순열 함수를 사용했다.\n리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다. 리스트에는 같은 숫자도 존재하며, 충분히 순열로 리스트를 만들었을 때, 중복이 존재한다. 결과를 반환할 set() 자료구조를 만든 후 for 문을 사용해서 순열리스트에 차례대로 접근하면서, 문자열로 만들어주면서 합친다. 합쳐진 문자열을 set() 자료구조로 만든 변수에 추가한다. 중복으로 추가가 되지 않는다 set() 변수의 길이를 재서 출력. 🖥 소스 코드 from sys import stdin from itertools import permutations as p arr = [] n, k = int(stdin.readline()), int(stdin.readline()) for i in range(n): arr.append(int(stdin.readline())) res = set() for i in list(p(arr, k)): res.add(\u0026#39;\u0026#39;.join(list(map(str, i)))) print(len(res)) 💾 느낀점 처음엔, 순열 리스트로만 만들어서 길이를 쟀다. -\u0026gt; TLE 순열 리스트에 순차적으로 접근해서 문자열로 만들어 조합을 본 뒤\n풀어나가는 아이디어, set() 자료구조를 사용할 아이디어를 떠올린 뒤\n바로 풀었다. 비교적 실버 문제가 쉽고 개념을 쌓기에 좋은 문제들이 많은 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-5568-%EC%B9%B4%EB%93%9C-%EB%86%93%EA%B8%B0-with-python/","summary":"📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 \u0026lt;= N \u0026lt;= 10 각 카드에 숫자가 적혀있다. 1 \u0026lt;= 숫자 \u0026lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions\npermutations라는 순열 함수를 사용했다.\n리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다.","title":"[BOJ] 5568 카드 놓기 with Python"},{"content":"\n📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다. - dict 이름만 저장하는 리스트를 사용한다 - list 문자열로 입력이 들어왔을 때, dict 자료형에서 매핑된 번호를 꺼낸다. 숫자로 입력이 들어왔을 때, list 자료형에서 매핑된 이름을 꺼낸다. 🖥 소스 코드 import sys n, m = map(int, sys.stdin.readline().split()) pokemon = {} pokemon_nm = [] for i in range(n): nm = sys.stdin.readline().rstrip() pokemon[nm] = i pokemon_nm.append(nm) for _ in range(m): c = sys.stdin.readline().rstrip() if c.isnumeric(): print(pokemon_nm[int(c) - 1]) else: print(pokemon[c] + 1) 💾 느낀점 key - value 로 매핑되는 dict 자료형으로 구현하기로 결정했는데,\n문제를 보고 바로 떠올린 것에 대해서 큰 뿌듯함이 들었다. 문제를 쉽게 풀어서 그런지, 기분좋은 공부의 시작이 되었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1620-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C-with-python/","summary":"📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다.","title":"[BOJ] 1620 나는야 포켓몬 마스터 이다솜 with Python"},{"content":"\n📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다. 단방향 간선이기 때문에 graph[a].append(b) bfs(x)에서 사용하는 방문처리용 자료구조를 list가 아닌 set으로 사용했다. queue에는 현재 노드와 비용에 대해서 튜플로 만들어 넣어준다.\n단, 이미 방문했던 노드는 다시 방문하지 않는다. = visited 🖥 소스 코드 from sys import stdin from collections import deque n, m, k, x = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] for i in range(m): a, b = map(int, stdin.readline().split()) graph[a].append(b) def bfs(x): res = [] visited = set() q = deque() q.append((x, 0)) visited.add(x) while q: now, cost = q.popleft() if cost == k: res.append(now) for i in graph[now]: if i not in visited: q.append((i, cost + 1)) visited.add(i) if not res: print(-1) else: res.sort() for i in res: print(i) bfs(x) 💾 느낀점 다익스트라, BFS 문제의 유형은 더 많이 풀어봐야겠다. 개념이 조금 익혀져 있는 다익스트라 기본 문제를 풀어서 쉽게 풀 수 있었다. 플로이드 와샬로는 시도해보지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-18352-%ED%8A%B9%EC%A0%95-%EA%B1%B0%EB%A6%AC%EC%9D%98-%EB%8F%84%EC%8B%9C-%EC%B0%BE%EA%B8%B0-with-python/","summary":"📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다.","title":"[BOJ] 18352 특정 거리의 도시 찾기 with Python"},{"content":"\n📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용. list로 받은 수열을 sort()로 정렬. 정렬된 리스트에 대해 0번 인덱스부터 순차적으로 접근하며\nbisect_left, bisect_right 함수를 사용해 반환받은 값(l, r)을 비교한다. 수열의 총 개수(n)보다 bisect_left 로 반환받은 값(l)이 작을 때만 실행한다. 현재 수열의 i번째 숫자와 수열의 l번째 숫자가 같지 않으며, r과 l이 같지 않을 때 cnt += 1 따로 for문의 범위를 지정해주지 않으면, 정답에 해당하는 (A[i], A[j]) 쌍이\n두번이 나오기 때문에 cnt // 2를 해준다. 🖥 소스 코드 from sys import stdin from bisect import bisect_right, bisect_left n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() x = int(stdin.readline()) cnt = 0 for i in range(n): l, r = bisect_left(arr, x - arr[i]), bisect_right(arr, x - arr[i]) if l \u0026lt; n: if arr[i] != arr[l] and l != r: cnt += 1 print(cnt // 2) 💾 느낀점 n을 순차적으로 접근할 for문의 범위를 잘못 지정해주어서 틀렸었다. bisect 라이브러리를 사용해 찾으려고 하는 숫자의 인덱스 번호를 잘못 계산해서 틀렸었다. 이분탐색 문제를 더 많이 풀어보고, 다양한 유형을 경험해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-3273-%EB%91%90-%EC%88%98%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용.","title":"[BOJ] 3273 두 수의 합 with Python"},{"content":"\n📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ```python \u0026lt;br\u0026gt; ### ⌨️ 문제 풀이 1. 편한 계산을 위해 dp를 `n + 1`의 크기만큼 생성했다. 2. **상담을 하는데 필요한 시간을 담을 리스트** `T`를 생성 3. **상담을 하면 얻을 수 있는 이익을 담을 리스트** `P`를 생성 4. 1일째부터 상담을 진행하면 얻을 수 있는 이익을 DP 리스트에 최댓값으로 갱신 5. **상담을 시작한 날의 이익의 데이터가 DP 리스트의 상담이 끝나는 날 위치에 들어감** 6. i번째 날에 상담을 시작했으면, `i + t[i]` 가 n을 넘지 말아야한다. 즉, 7(N)일 남은 퇴사 예정자가 퇴사 하루 전 날(i = 7)에 `T[i]` 2일 걸릴 상담을 시작하면, 끝내지 못하기에(N \u0026lt; Ti + i) 이익을 취할 수 없다. 7. k 라는 변수를 만들어, `dp[i]`와 k 중 가장 큰 값을 집어넣는다. 이 값과 `dp[i + t[i]]` 이 값을 비교하여 큰 값을 `dp[i + t[i]]`에 넣는다. \u0026lt;br\u0026gt; ### 🖥 소스 코드 ```python from sys import stdin n = int(stdin.readline()) t, p = [], [] dp = [0 for _ in range(n + 1)] for _ in range(n): ti, pi = map(int, stdin.readline().split()) t.append(ti) p.append(pi) k = 0 for i in range(n): k = max(k, dp[i]) if i + t[i] \u0026gt; n: continue dp[i + t[i]] = max(k + p[i], dp[i + t[i]]) print(max(dp)) 💾 느낀점 다이나믹 프로그래밍 문제에 매우 약하다. 여러 문제를 꾸준히 풀어봐야겠다. 다이나믹 프로그래밍 부분에서는 구현 부분에서 굉장히 헤매는 것 같다.\n각 변수의 사용처, 갱신 등을 더 꼼곰히 체크해서 사고하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15486-%ED%87%B4%EC%82%AC-2-with-python/","summary":"📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ```python \u0026lt;br\u0026gt; ### ⌨️ 문제 풀이 1.","title":"[BOJ] 15486 퇴사 2 with Python"},{"content":"\n📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,\nT1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 응시자, 테이블, 파티션 = P, O, X 정확성 테스트의 시간은 10초. 🔖 예제 및 실행결과 예제 places = [[\u0026#34;POOOP\u0026#34;, \u0026#34;OXXOX\u0026#34;, \u0026#34;OPXPX\u0026#34;, \u0026#34;OOXOX\u0026#34;, \u0026#34;POXXP\u0026#34;], [\u0026#34;POOPX\u0026#34;, \u0026#34;OXPXP\u0026#34;, \u0026#34;PXXXO\u0026#34;, \u0026#34;OXXXO\u0026#34;, \u0026#34;OOOPP\u0026#34;], [\u0026#34;PXOPX\u0026#34;, \u0026#34;OXOXP\u0026#34;, \u0026#34;OXPOX\u0026#34;, \u0026#34;OXXOP\u0026#34;, \u0026#34;PXPOX\u0026#34;], [\u0026#34;OOOXX\u0026#34;, \u0026#34;XOOOX\u0026#34;, \u0026#34;OOOXX\u0026#34;, \u0026#34;OXOOX\u0026#34;, \u0026#34;OOOOO\u0026#34;], [\u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;]] 실행결과 [1, 0, 1, 1, 1] ⌨️ 문제 풀이 정확성 테스트가 있기 때문에 시간초과 및 메모리 초과에 신경을 써야한다.\n그러므로 응시자들의 좌표만 따로 배열로 받아서 맨해튼 거리를 구한 뒤 맨해튼 거리가 2 이하인 것들만 BFS를 통해\n응시자 사이가 파티션으로 막혀 있는지 확인한다.\n대기실을 BFS로 돌면서 큐에 이동 거리, 좌표, 움직인 이동 좌표를 배열로 넣어 주며,\n이동 거리가 맨해튼 거리보다 멀다면 BFS 과정을 skip 한다.\n두 응시자의 맨해튼 거리가 2 이하일 때, 사이에 파티션이 있는 경우를 처리 하지 못해서 테스트 케이스 5번이 틀렸다.\n내가 틀린 반례는 아래와 같다. 답은 1이다.\n[[\u0026#34;OPXPO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;]] 🖥 소스 코드 from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] def bfs(board, now, goal, dist): q = deque() visited = [] x, y = now q.append((0, x, y, [])) visited.append(now) check = False while q: cost, x, y, visit = q.popleft() # 움직인 거리가 맨헤튼 거리보다 많으면 넘어가기 if cost \u0026gt; dist: continue if (x, y) == goal: for i, j in visit: if board[i][j] == \u0026#39;X\u0026#39;: check = True elif board[i][j] == \u0026#39;O\u0026#39;: return False for i in range(4): nx, ny = dx[i] + x, y + dy[i] if -1 \u0026lt; nx \u0026lt; 5 and -1 \u0026lt; ny \u0026lt; 5: if (nx, ny) not in visited: # 목표 지점을 visited 에 넣지 않는다. # 가능한 많은 경로를 염두에 두어 계산한다. if (nx, ny) != goal: visited.append((nx, ny)) temp = visit[:] temp.append((nx, ny)) q.append((cost + 1, nx, ny, temp)) return check def solution(places): answer = [] for i in range(len(places)): board = [] data = places[i] ps = [] # 대기실 리스트 만들기 for j in range(5): for k in range(5): if data[j][k] == \u0026#39;P\u0026#39;: ps.append((j, k)) board.append(list(data[j])) ps.sort() check = True for j in range(len(ps)): x1, y1 = ps[j] for k in range(j + 1, len(ps)): x2, y2 = ps[k] dist = abs(x1 - x2) + abs(y1 - y2) if dist \u0026lt; 3: if not bfs(board, ps[j], ps[k], dist): check = False break if not check: break answer.append(1) if check else answer.append(0) return answer 💾 느낀점 어제 풀었던 불! 보다 쉬웠다. 반례 테스트 케이스를 찾는데 조금 어려움이 있었다. BFS는 짜기 나름인 것 같다. queue 에 넣는 정보를 다양하게 사용하는 법이 익숙해지고 있는 것 같아 좋다.\n그러나 visited 배열을 더 다양하게 사용하는 법을 연습해야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-with-python/","summary":"📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,","title":"[Programmers] 거리두기 확인하기 with Python"},{"content":"\n📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다. 입력받은 expression의 정보를 담을 변수를 하나 만들고,\n문자열에서 연산자를 구분한 뒤 숫자는 정수형 변수로 변환시켜 각각 리스트에 담는다. 연산자의 우선순위는 itertools 의 permutaions 를 사용해 순열을 만든 후\nset()을 통해 순열의 중복을 없앴다. 각 순열을 하나씩 for 문으로 꺼내고, 그 순열의 원소를 돌며 최댓값을 계산한다. 주어지는 문자열의 길이가 매우 길지 않은 점\npython 언어의 list와 문자열에 있는 index() 함수를 사용. 리스트의 index() 함수는 찾고자 하는 데이터의 가장 앞에 있는 것을 반환\n그렇기 때문에 같은 연산자인 경우 우선순위가 앞에 있다는 점을 만족한다 해당하는 인덱스의 연산자 앞 뒤의 숫자를 연산자에 맞게 계산 후,\n계산한 연산자와 피연산자를 뺀 자리에 계산값을 넣음 반복하여 1개 남은 원소 즉, 수식의 최종 계산값을 answer 와 비교해 큰 값으로 교체해주면 된다.\n뮬론 음수는 abs() 함수를 사용해 양수로 변경해주었다. 🖥 소스 코드 from itertools import permutations as pt def solution(expression): answer = -1e9 op, nums = [], [] a, b = -1, -1 new_ex = [] for i in range(len(expression)): if expression[i].isnumeric(): if a \u0026lt; 0: a = i else: b = i else: if b \u0026lt; 0: b = a op.append(expression[i]) nums.append((a, b)) new_ex.append(int(expression[a:b+1])) new_ex.append(expression[i]) a, b = -1, -1 if b \u0026gt; -1: new_ex.append(int(expression[a:b+1])) else: new_ex.append(int(expression[a])) k = list(set(op)) for case in list(set(pt(k, len(k)))): temp_new_ex = new_ex[:] for j in case: while j in temp_new_ex: idx = temp_new_ex.index(j) if j == \u0026#39;*\u0026#39;: temp = temp_new_ex[idx - 1] * temp_new_ex[idx + 1] elif j == \u0026#39;-\u0026#39;: temp = temp_new_ex[idx - 1] - temp_new_ex[idx + 1] else: temp = temp_new_ex[idx - 1] + temp_new_ex[idx + 1] temp_new_ex = temp_new_ex[:idx - 1] + [temp] + temp_new_ex[idx + 2:] answer = max(answer, abs(temp_new_ex[0])) return answer 💾 느낀점 정규표현식으로 연산자와 피연산자를 구분하여 추출해서 풀면,\n시간복잡도가 더 줄 수도 있을 것 같다. 정규표현식을 더 공부하고 연습해보아야겠다. 이보다 expression의 길이가 더 길어 시간초과가 날 때는 어떻게 할 것인지\n연산을 더 줄일 수 있는 방법을 생각해봐야겠다. 괄호를 넣어 eval() 함수를 사용하는 것도 생각해보았는데, 실행 속도에서 생각해보니\n그리 좋지 않은 풀이 방법인 것 같아 사용하지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94-with-python/","summary":"📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다.","title":"[Programmers] 수식최대화 with Python"},{"content":"\n📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산\ni에서 j로 가는 비용과 i에서 k를 경유하여 j로 가는 비용 중에 더 저렴한 것 answer를 더 저렴한 비용을 비교하기 위해 1e9로 초기화 for 문으로 1번 노드부터 n번 노드까지 아래의 내용을 검사한다.\nanswer와 출발지(s)에서 i까지 합승한 값 + i 부터 B의 목적지까지 가는 값 + i 부터 A의 목적지까지 가는 값 비교 🖥 소스 코드 from collections import deque def solution(n, s, a, b, fares): answer = int(1e9) INF = int(1e9) distance = [[INF] * (n + 1) for _ in range(n + 1)] for q, w, e in fares: distance[q][w] = e distance[w][q] = e for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if i == j: distance[i][j] = 0 else: if distance[i][j] \u0026gt; distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] for i in range(1, n + 1): if answer \u0026gt; distance[s][i] + distance[i][b] + distance[i][a]: answer = distance[s][i] + distance[i][b] + distance[i][a] return answer 💾 느낀점 BFS로 최단거리를 찾아보기 위해 이동거리 값을 저장하는 큐를 생성해 문제를 풀려고 시도했다.\n그 결과 시간을 매우 낭비하게 되었고, 플로이드 와샬을 떠올려 문제 풀이를 했다. 플로이드 와샬 구현 방법을 조금 헷갈리는 문제점이 있었다.\n플로이드 와샬이면 굳이 BFS가 없는데 위에서 말한 BFS 소스코드를 그대로 두었었다. 시간초과가 났다. 26번 테스트 케이스에서 시간초과가 났다.\n플로이드 와샬 부분과 반환할 answer를 위해 비교하는 부분에서 min() 대신\nif를 써주었더니 속도차이가 두 배 가까이 났다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%ED%95%A9%EC%8A%B9-%ED%83%9D%EC%8B%9C-%EC%9A%94%EA%B8%88-with-python/","summary":"📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산","title":"[Programmers] 합승 택시 요금 with Python"},{"content":"\n📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다. 임시 배열을 만들어 불과 지훈이가 움직일 때 이동 가능한 경로를 모두 넣어주고 while 문이 종료되었을 때 큐에 삽입 지훈이가 지나간 곳은 '$'로 변경 불은 '$' 와 '.' 를, 지훈이는 오로지 '.' 만 갈 수 있게 처리. 지훈이가 움직일 때, Queue 에서 현재 지훈이의 좌표를 뽑아, 벽에 위치하고 있다면 탈출 성공. if x == 0 or y == 0 or x == r - 1 or y == c - 1: 더 이상 지훈이가 움직일 경로가 없다면 탈출 실패 if not J: 🖥 소스 코드 from sys import stdin from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, 1, -1] r, c = map(int, stdin.readline().split()) board, res = [], 0 # 지환이와 불난 곳 저장할 변수 F, J = deque(), deque() for i in range(r): data = list(stdin.readline().rstrip()) for j in range(c): if data[j] == \u0026#39;J\u0026#39;: J.append((i, j)) if data[j] == \u0026#39;F\u0026#39;: F.append((i, j)) board.append(data) def bfs(): global F, J, res while 1: res += 1 temp = [] while F: x, y = F.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c: if board[nx][ny] == \u0026#39;.\u0026#39; or board[nx][ny] == \u0026#39;$\u0026#39;: temp.append((nx, ny)) board[nx][ny] = \u0026#39;F\u0026#39; F = deque(temp) temp = [] while J: x, y = J.popleft() if x == 0 or y == 0 or x == r - 1 or y == c - 1: return res for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c and board[nx][ny] == \u0026#39;.\u0026#39;: temp.append((nx, ny)) board[x][y] = \u0026#39;$\u0026#39; board[nx][ny] = \u0026#39;J\u0026#39; J = deque(temp) if not J: return False if bfs(): print(res) else: print(\u0026#39;IMPOSSIBLE\u0026#39;) 💾 느낀점 BFS 유형 문제에서 난이도가 실버2 ~ 골드4 로만 올라가도 헤매는 모습을 보였다. 방문처리용 배열의 다양한 사용법을 눈에 익히고 응용할 줄 알아야겠다. 방문처리용 배열을 사용하기 전, 메모리 초과가 뜰 각인지 잴 줄 알아야겠다. 문제를 나름대로 해석하고 압축하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4179-%EB%B6%88-with-python/","summary":"📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다.","title":"[BOJ] 4179 불! with Python"},{"content":"","permalink":"https://jxun-h.github.io/posts/temp/temp/","summary":"","title":""},{"content":" 안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Contact. Github : github.com/Jxun-h\nTistory : dreamtreeits.tistory.com\nEmail : its1108@kakao.com Resume. 이력과 포트폴리오를 기재한 이력서입니다. Introduction. 트레이드 오프를 고려해 균형잡힌 선택을 하려 노력합니다.\n안정적인 서비스를 만드는데 기여하고자 노력하는 백엔드 개발자입니다.\n또한 서비스가 안정적으로 운영되기 위한 방법에 대해 고민합니다. Why Post in Blog. 블로그를 처음 쓰기 시작한 것은 2021년 08월 28일 입니다.\n코딩 테스트를 위해 고민했던 내용과 해결 과정들을 오로지 머리로만 기억하는 것에 한계가 있음을 느꼈습니다.\n블로그를 제 두뇌의 외장하드로 쓰기 결심하고, 티스토리에서 포스팅을 시작했습니다.\n그 후 약 1년간 꾸준히 알고리즘 풀이를 포스팅 했고, 2023년 4월 18일 이후 공백기간이 있었습니다.\n2024년을 맞이해 블로그 작성을 통해 쌓여가는 경험과 지식을 되돌아보고 회고록도 써보려고 합니다.\n다시 시작하는 저의 블로그는 github.io 로 시작해보려 합니다. ","permalink":"https://jxun-h.github.io/about/","summary":"짤막한 소개글","title":"About"},{"content":"안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Work Experience TAPartners period 24.01 - current position Back-end Engineer project 건설사업관리 플랫폼 고도화 자세히 보기\n건설사업관리 플랫폼 고도화\n기획 중 Tech Stack\nVue3 Java Oracle SQL period 23.06 - 24.01 position Back-end Engineer project 건설사업관리 플랫폼 구축/개발 자세히 보기\n건설사업관리 플랫폼 구축/개발\nRestful API 작성 다국어 처리를 위한 Oracle Function 생성 및 Query 작성 대용량 Excel Read \u0026amp; Upload 처리 개발 Spring JDBC Batch 적용 약 80% 이상의 업로드 속도 개선\n공사 관련 청구/정산 프로세스 개발 Tech Stack\nVue3 Java Oracle SQL SAX Library POI Excel Library Toogram Systems period 19.12 - 21.01 position Python Back-end Engineer project 선박 자율운항 최적항로 알고리즘 구축/개발 자세히 보기\n선박 자율운항 최적항로 알고리즘 구축/개발\n선박 데이터 전처리 및 가공 선박 운항 데이터 전처리 및 가공 선박 운항 항로 렌더링 처리 그래프 탐색 알고리즘 기반 자율운항 항로 계산 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript period 19.07 - 20.01 position Python Back-end Engineer project 선박 데이터 기반 이상탐지 알고리즘 개발 자세히 보기\n선박 데이터 기반 이상탐지 알고리즘 개발\n선박 데이터 전처리 마할라노비스 다구찌 기반 이상탐지 알고리즘 개발 선박 데이터 시각화 개발 JS 기반 데이터 차트 오픈소스 라이브러리 적용 및 테스트 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript Other Experience Blog Author, Maintainer\n21.08.28 - 현재\n비정기적으로 새롭게 배우고 공부한 내용 등을 글로 작성해 공유합니다.\n블로그는 이전에 약 1년간 사용하던 Tistory 와 현재 보고 계신 Github Pages가 있습니다.\n현재 블로그는 Hugo + github.io 를 사용해 구현했습니다. Internship 한이음 ICT 멘토링 period 18.04 - 18.11 position Intern project 생활 법령 정보제공 챗봇 서비스 개발 자세히 보기\n생활 법령 정보제공 챗봇 서비스 개발\nSoap API 를 사용해 공공데이터포털 크롤링 자연어 처리에 사용할 형태소 분석기를 시스템에 import 자연어 처리 Seq2Seq 연구 및 적용 테스트 카카오톡 챗봇 서비스 API 연결 및 테스트 Tech Stack\nPython Django Soap API MySQL Linux (Ubuntu) 씨에스리 ICT 인턴십 period 18.03 - 18.06 position Intern project 블럭코딩 데이터 분석툴(BigZami) 개발 자세히 보기\n블럭코딩 데이터 분석툴(BigZami) 개발\nNexacro Flatform 기반 컴포넌트 개발 및 연결 SpringBoot 기반 Back-end 환경 구성 R - Java 언어 연동 및 Nexacro Flatform 연동 테스트 Plotly 오픈소스 라이브러리 적용 테스트 Tech Stack\nNexacro Flatform Java Spring Boot OpenSource Library 씨에스리 ICT 인턴십 period 17.09 - 17.12 position Intern project IT 지식 제공 챗봇 개발 자세히 보기\nIT 지식 제공 챗봇 개발\nDjango 기반 개발 서버 환경구축 카카오톡 챗봇 서버와 Restful API 연동 형태소 분석기 테스트 및 사용자 전용 단어 사전 구축 자연어 처리 방법 연구 및 분석 Tech Stack\nDjango Python2 Ubuntu MySQL Rest API Skills Overall. 안정적인 서비스 및 효율적인 구현을 좋아합니다. 최신 기술보다 상황에 따라 적절한 선택을 하는 것이 최적의 결과가 나온다고 믿습니다. 업무에 따라 능숙한 분야가 아니더라도 적극적으로 탐색해 최적의 결과를 낼 수 있도록 노력합니다. Communication. 직위 및 포지션에 관계없이 적극적인 의사소통을 시도합니다. 지적 겸손함을 유지하기 위해 노력합니다. Server. 성능향상을 위한 리팩토링을 한 경험이 있습니다. Java SpringBoot 를 비롯해, Python Django 또한 지원이 가능합니다. 필요하다면 셸스크립트를 작성해 반복되는 업무를 자동화 가능합니다. Python. Python3 환경에 익숙하고 능숙합니다. 웹프레임워크를 필요에 따라 구분해 사용할 수 있으며, 공통 로직을 적절히 모듈화해 사용합니다. Java JDBC를 능숙하게 사용하고, 속도개선을 위해 캐싱이나 배치를 적절히 활용합니다. 불필요한 API 호출을 최대한 삼가하며, 합리적인 방식으로 서비스를 분리합니다. Education Woosuk Univ. 정보보안학과\n2012.03 - 2019.02\n4.31 / 4.5\n정보보안학과에서 4년간 공부하며, 거의 모든 과목을 높은 성적으로 이수하였습니다.\n군대에 가기 전, 가고 싶은 곳에 지원하기 위한 준비를 위해 약 1년 간 휴학했습니다. certificate 정보처리기사 2018.08.17 리눅스마스터 2급 2017.06.10 ","permalink":"https://jxun-h.github.io/resume/","summary":"이력서","title":"Resume"}]