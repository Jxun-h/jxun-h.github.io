[{"content":"\n📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,\n입력받은 N이 비어있는 문자열 ''이면 break 입력받은 N이 0, -의 개수가 1이라면 print('-') (N ** 3) * '-' == 하이픈의 개수 만들어진 하이픈을 분할 정복 함수에 넣는다.\n각 파라미터는 3 ** N개의 하이픈과 인덱스 번호이다. 인덱스 번호는 세등분이 된 문자열의 각 인덱스 번호이며, 재귀를 통해 인덱스 번호가 1인\n문자열을 공백으로 만들어주면 된다. 문자열은 파라미터로 받은 문자열 길이를 3으로 나누어\n그 길이만큼 리스트를 슬라이싱해 arr 리스트에 넣는다. 반환 조건은 아래의 두가지로 만들었다. 문자열의 길이가 3이고 인덱스 번호가 1이 아닐 때에는 \u0026lsquo;- -\u0026lsquo;을 리턴 문자열의 길이가 3보다 같거나 크며, 인덱스 번호가 1일 때는 문자열의 길이만큼 공백을 반환 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) def div(s, idx): ls = len(s) if ls == 3 and idx != 1: return \u0026#39;- -\u0026#39; elif ls \u0026gt;= 3 and idx == 1: return s.replace(\u0026#39;-\u0026#39;, \u0026#39; \u0026#39;) arr = [] for i in range(0, ls, ls // 3): arr.append(string[i:i+ls//3]) k = div(arr[0], 0) + div(arr[1], 1) + div(arr[2], 2) return k while 1: k = \u0026#39;-\u0026#39; n = stdin.readline().rstrip() if n == \u0026#39;\u0026#39;: break num = (3 ** int(n)) if num == 1: print(\u0026#39;-\u0026#39;) continue string = k * num arr = div(string, 0) print(arr) 💾 느낀점 분할 정복을 사용하기로 하고 인덱스를 같이 파라미터 값으로 넣자고 생각했다.\n좋은 아이디어가 한번에 떠올라서 매우 좋았다. 성공적인 풀이였다. 재귀 사용 실력이 최악이라 사용자체가 많이 힘들었지만\n예전보다는 사용하기 매우 수월해졌다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4779-%EC%B9%B8%ED%86%A0%EC%96%B4-%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,","title":"[BOJ] 4779 칸토어 집합 with Python"},{"content":"\n📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다. - dict 이름만 저장하는 리스트를 사용한다 - list 문자열로 입력이 들어왔을 때, dict 자료형에서 매핑된 번호를 꺼낸다. 숫자로 입력이 들어왔을 때, list 자료형에서 매핑된 이름을 꺼낸다. 🖥 소스 코드 import sys n, m = map(int, sys.stdin.readline().split()) pokemon = {} pokemon_nm = [] for i in range(n): nm = sys.stdin.readline().rstrip() pokemon[nm] = i pokemon_nm.append(nm) for _ in range(m): c = sys.stdin.readline().rstrip() if c.isnumeric(): print(pokemon_nm[int(c) - 1]) else: print(pokemon[c] + 1) 💾 느낀점 key - value 로 매핑되는 dict 자료형으로 구현하기로 결정했는데,\n문제를 보고 바로 떠올린 것에 대해서 큰 뿌듯함이 들었다. 문제를 쉽게 풀어서 그런지, 기분좋은 공부의 시작이 되었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1620-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C-with-python/","summary":"📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다.","title":"[BOJ] 1620 나는야 포켓몬 마스터 이다솜 with Python"},{"content":"\n📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다. 단방향 간선이기 때문에 graph[a].append(b) bfs(x)에서 사용하는 방문처리용 자료구조를 list가 아닌 set으로 사용했다. queue에는 현재 노드와 비용에 대해서 튜플로 만들어 넣어준다.\n단, 이미 방문했던 노드는 다시 방문하지 않는다. = visited 🖥 소스 코드 from sys import stdin from collections import deque n, m, k, x = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] for i in range(m): a, b = map(int, stdin.readline().split()) graph[a].append(b) def bfs(x): res = [] visited = set() q = deque() q.append((x, 0)) visited.add(x) while q: now, cost = q.popleft() if cost == k: res.append(now) for i in graph[now]: if i not in visited: q.append((i, cost + 1)) visited.add(i) if not res: print(-1) else: res.sort() for i in res: print(i) bfs(x) 💾 느낀점 다익스트라, BFS 문제의 유형은 더 많이 풀어봐야겠다. 개념이 조금 익혀져 있는 다익스트라 기본 문제를 풀어서 쉽게 풀 수 있었다. 플로이드 와샬로는 시도해보지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-18352-%ED%8A%B9%EC%A0%95-%EA%B1%B0%EB%A6%AC%EC%9D%98-%EB%8F%84%EC%8B%9C-%EC%B0%BE%EA%B8%B0-with-python/","summary":"📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다.","title":"[BOJ] 18352 특정 거리의 도시 찾기 with Python"},{"content":"\n📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용. list로 받은 수열을 sort()로 정렬. 정렬된 리스트에 대해 0번 인덱스부터 순차적으로 접근하며\nbisect_left, bisect_right 함수를 사용해 반환받은 값(l, r)을 비교한다. 수열의 총 개수(n)보다 bisect_left 로 반환받은 값(l)이 작을 때만 실행한다. 현재 수열의 i번째 숫자와 수열의 l번째 숫자가 같지 않으며, r과 l이 같지 않을 때 cnt += 1 따로 for문의 범위를 지정해주지 않으면, 정답에 해당하는 (A[i], A[j]) 쌍이\n두번이 나오기 때문에 cnt // 2를 해준다. 🖥 소스 코드 from sys import stdin from bisect import bisect_right, bisect_left n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() x = int(stdin.readline()) cnt = 0 for i in range(n): l, r = bisect_left(arr, x - arr[i]), bisect_right(arr, x - arr[i]) if l \u0026lt; n: if arr[i] != arr[l] and l != r: cnt += 1 print(cnt // 2) 💾 느낀점 n을 순차적으로 접근할 for문의 범위를 잘못 지정해주어서 틀렸었다. bisect 라이브러리를 사용해 찾으려고 하는 숫자의 인덱스 번호를 잘못 계산해서 틀렸었다. 이분탐색 문제를 더 많이 풀어보고, 다양한 유형을 경험해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-3273-%EB%91%90-%EC%88%98%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용.","title":"[BOJ] 3273 두 수의 합 with Python"},{"content":"\n📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ⌨️ 문제 풀이 편한 계산을 위해 dp를 n + 1의 크기만큼 생성했다. 상담을 하는데 필요한 시간을 담을 리스트 T를 생성 상담을 하면 얻을 수 있는 이익을 담을 리스트 P를 생성 1일째부터 상담을 진행하면 얻을 수 있는 이익을 DP 리스트에 최댓값으로 갱신 상담을 시작한 날의 이익의 데이터가 DP 리스트의 상담이 끝나는 날 위치에 들어감 i번째 날에 상담을 시작했으면, i + t[i] 가 n을 넘지 말아야한다.\n즉, 7(N)일 남은 퇴사 예정자가 퇴사 하루 전 날(i = 7)에\nT[i] 2일 걸릴 상담을 시작하면, 끝내지 못하기에(N \u0026lt; Ti + i) 이익을 취할 수 없다. k 라는 변수를 만들어, dp[i]와 k 중 가장 큰 값을 집어넣는다.\n이 값과 dp[i + t[i]] 이 값을 비교하여 큰 값을 dp[i + t[i]]에 넣는다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) t, p = [], [] dp = [0 for _ in range(n + 1)] for _ in range(n): ti, pi = map(int, stdin.readline().split()) t.append(ti) p.append(pi) k = 0 for i in range(n): k = max(k, dp[i]) if i + t[i] \u0026gt; n: continue dp[i + t[i]] = max(k + p[i], dp[i + t[i]]) print(max(dp)) 💾 느낀점 다이나믹 프로그래밍 문제에 매우 약하다. 여러 문제를 꾸준히 풀어봐야겠다. 다이나믹 프로그래밍 부분에서는 구현 부분에서 굉장히 헤매는 것 같다.\n각 변수의 사용처, 갱신 등을 더 꼼곰히 체크해서 사고하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15486-%ED%87%B4%EC%82%AC-2-with-python/","summary":"📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ⌨️ 문제 풀이 편한 계산을 위해 dp를 n + 1의 크기만큼 생성했다.","title":"[BOJ] 15486 퇴사 2 with Python"},{"content":"\n📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,\nT1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 응시자, 테이블, 파티션 = P, O, X 정확성 테스트의 시간은 10초. 🔖 예제 및 실행결과 예제 places = [[\u0026#34;POOOP\u0026#34;, \u0026#34;OXXOX\u0026#34;, \u0026#34;OPXPX\u0026#34;, \u0026#34;OOXOX\u0026#34;, \u0026#34;POXXP\u0026#34;], [\u0026#34;POOPX\u0026#34;, \u0026#34;OXPXP\u0026#34;, \u0026#34;PXXXO\u0026#34;, \u0026#34;OXXXO\u0026#34;, \u0026#34;OOOPP\u0026#34;], [\u0026#34;PXOPX\u0026#34;, \u0026#34;OXOXP\u0026#34;, \u0026#34;OXPOX\u0026#34;, \u0026#34;OXXOP\u0026#34;, \u0026#34;PXPOX\u0026#34;], [\u0026#34;OOOXX\u0026#34;, \u0026#34;XOOOX\u0026#34;, \u0026#34;OOOXX\u0026#34;, \u0026#34;OXOOX\u0026#34;, \u0026#34;OOOOO\u0026#34;], [\u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;]] 실행결과 [1, 0, 1, 1, 1] ⌨️ 문제 풀이 정확성 테스트가 있기 때문에 시간초과 및 메모리 초과에 신경을 써야한다.\n그러므로 응시자들의 좌표만 따로 배열로 받아서 맨해튼 거리를 구한 뒤 맨해튼 거리가 2 이하인 것들만 BFS를 통해\n응시자 사이가 파티션으로 막혀 있는지 확인한다.\n대기실을 BFS로 돌면서 큐에 이동 거리, 좌표, 움직인 이동 좌표를 배열로 넣어 주며,\n이동 거리가 맨해튼 거리보다 멀다면 BFS 과정을 skip 한다.\n두 응시자의 맨해튼 거리가 2 이하일 때, 사이에 파티션이 있는 경우를 처리 하지 못해서 테스트 케이스 5번이 틀렸다.\n내가 틀린 반례는 아래와 같다. 답은 1이다.\n[[\u0026#34;OPXPO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;]] 🖥 소스 코드 from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] def bfs(board, now, goal, dist): q = deque() visited = [] x, y = now q.append((0, x, y, [])) visited.append(now) check = False while q: cost, x, y, visit = q.popleft() # 움직인 거리가 맨헤튼 거리보다 많으면 넘어가기 if cost \u0026gt; dist: continue if (x, y) == goal: for i, j in visit: if board[i][j] == \u0026#39;X\u0026#39;: check = True elif board[i][j] == \u0026#39;O\u0026#39;: return False for i in range(4): nx, ny = dx[i] + x, y + dy[i] if -1 \u0026lt; nx \u0026lt; 5 and -1 \u0026lt; ny \u0026lt; 5: if (nx, ny) not in visited: # 목표 지점을 visited 에 넣지 않는다. # 가능한 많은 경로를 염두에 두어 계산한다. if (nx, ny) != goal: visited.append((nx, ny)) temp = visit[:] temp.append((nx, ny)) q.append((cost + 1, nx, ny, temp)) return check def solution(places): answer = [] for i in range(len(places)): board = [] data = places[i] ps = [] # 대기실 리스트 만들기 for j in range(5): for k in range(5): if data[j][k] == \u0026#39;P\u0026#39;: ps.append((j, k)) board.append(list(data[j])) ps.sort() check = True for j in range(len(ps)): x1, y1 = ps[j] for k in range(j + 1, len(ps)): x2, y2 = ps[k] dist = abs(x1 - x2) + abs(y1 - y2) if dist \u0026lt; 3: if not bfs(board, ps[j], ps[k], dist): check = False break if not check: break answer.append(1) if check else answer.append(0) return answer 💾 느낀점 어제 풀었던 불! 보다 쉬웠다. 반례 테스트 케이스를 찾는데 조금 어려움이 있었다. BFS는 짜기 나름인 것 같다. queue 에 넣는 정보를 다양하게 사용하는 법이 익숙해지고 있는 것 같아 좋다.\n그러나 visited 배열을 더 다양하게 사용하는 법을 연습해야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-with-python/","summary":"📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,","title":"[Programmers] 거리두기 확인하기 with Python"},{"content":"\n📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다. 입력받은 expression의 정보를 담을 변수를 하나 만들고,\n문자열에서 연산자를 구분한 뒤 숫자는 정수형 변수로 변환시켜 각각 리스트에 담는다. 연산자의 우선순위는 itertools 의 permutaions 를 사용해 순열을 만든 후\nset()을 통해 순열의 중복을 없앴다. 각 순열을 하나씩 for 문으로 꺼내고, 그 순열의 원소를 돌며 최댓값을 계산한다. 주어지는 문자열의 길이가 매우 길지 않은 점\npython 언어의 list와 문자열에 있는 index() 함수를 사용. 리스트의 index() 함수는 찾고자 하는 데이터의 가장 앞에 있는 것을 반환\n그렇기 때문에 같은 연산자인 경우 우선순위가 앞에 있다는 점을 만족한다 해당하는 인덱스의 연산자 앞 뒤의 숫자를 연산자에 맞게 계산 후,\n계산한 연산자와 피연산자를 뺀 자리에 계산값을 넣음 반복하여 1개 남은 원소 즉, 수식의 최종 계산값을 answer 와 비교해 큰 값으로 교체해주면 된다.\n뮬론 음수는 abs() 함수를 사용해 양수로 변경해주었다. 🖥 소스 코드 from itertools import permutations as pt def solution(expression): answer = -1e9 op, nums = [], [] a, b = -1, -1 new_ex = [] for i in range(len(expression)): if expression[i].isnumeric(): if a \u0026lt; 0: a = i else: b = i else: if b \u0026lt; 0: b = a op.append(expression[i]) nums.append((a, b)) new_ex.append(int(expression[a:b+1])) new_ex.append(expression[i]) a, b = -1, -1 if b \u0026gt; -1: new_ex.append(int(expression[a:b+1])) else: new_ex.append(int(expression[a])) k = list(set(op)) for case in list(set(pt(k, len(k)))): temp_new_ex = new_ex[:] for j in case: while j in temp_new_ex: idx = temp_new_ex.index(j) if j == \u0026#39;*\u0026#39;: temp = temp_new_ex[idx - 1] * temp_new_ex[idx + 1] elif j == \u0026#39;-\u0026#39;: temp = temp_new_ex[idx - 1] - temp_new_ex[idx + 1] else: temp = temp_new_ex[idx - 1] + temp_new_ex[idx + 1] temp_new_ex = temp_new_ex[:idx - 1] + [temp] + temp_new_ex[idx + 2:] answer = max(answer, abs(temp_new_ex[0])) return answer 💾 느낀점 정규표현식으로 연산자와 피연산자를 구분하여 추출해서 풀면,\n시간복잡도가 더 줄 수도 있을 것 같다. 정규표현식을 더 공부하고 연습해보아야겠다. 이보다 expression의 길이가 더 길어 시간초과가 날 때는 어떻게 할 것인지\n연산을 더 줄일 수 있는 방법을 생각해봐야겠다. 괄호를 넣어 eval() 함수를 사용하는 것도 생각해보았는데, 실행 속도에서 생각해보니\n그리 좋지 않은 풀이 방법인 것 같아 사용하지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94-with-python/","summary":"📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다.","title":"[Programmers] 수식최대화 with Python"},{"content":"\n📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산\ni에서 j로 가는 비용과 i에서 k를 경유하여 j로 가는 비용 중에 더 저렴한 것 answer를 더 저렴한 비용을 비교하기 위해 1e9로 초기화 for 문으로 1번 노드부터 n번 노드까지 아래의 내용을 검사한다.\nanswer와 출발지(s)에서 i까지 합승한 값 + i 부터 B의 목적지까지 가는 값 + i 부터 A의 목적지까지 가는 값 비교 🖥 소스 코드 from collections import deque def solution(n, s, a, b, fares): answer = int(1e9) INF = int(1e9) distance = [[INF] * (n + 1) for _ in range(n + 1)] for q, w, e in fares: distance[q][w] = e distance[w][q] = e for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if i == j: distance[i][j] = 0 else: if distance[i][j] \u0026gt; distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] for i in range(1, n + 1): if answer \u0026gt; distance[s][i] + distance[i][b] + distance[i][a]: answer = distance[s][i] + distance[i][b] + distance[i][a] return answer 💾 느낀점 BFS로 최단거리를 찾아보기 위해 이동거리 값을 저장하는 큐를 생성해 문제를 풀려고 시도했다.\n그 결과 시간을 매우 낭비하게 되었고, 플로이드 와샬을 떠올려 문제 풀이를 했다. 플로이드 와샬 구현 방법을 조금 헷갈리는 문제점이 있었다.\n플로이드 와샬이면 굳이 BFS가 없는데 위에서 말한 BFS 소스코드를 그대로 두었었다. 시간초과가 났다. 26번 테스트 케이스에서 시간초과가 났다.\n플로이드 와샬 부분과 반환할 answer를 위해 비교하는 부분에서 min() 대신\nif를 써주었더니 속도차이가 두 배 가까이 났다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%ED%95%A9%EC%8A%B9-%ED%83%9D%EC%8B%9C-%EC%9A%94%EA%B8%88-with-python/","summary":"📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산","title":"[Programmers] 합승 택시 요금 with Python"},{"content":"\n📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다. 임시 배열을 만들어 불과 지훈이가 움직일 때 이동 가능한 경로를 모두 넣어주고 while 문이 종료되었을 때 큐에 삽입 지훈이가 지나간 곳은 '$'로 변경 불은 '$' 와 '.' 를, 지훈이는 오로지 '.' 만 갈 수 있게 처리. 지훈이가 움직일 때, Queue 에서 현재 지훈이의 좌표를 뽑아, 벽에 위치하고 있다면 탈출 성공. if x == 0 or y == 0 or x == r - 1 or y == c - 1: 더 이상 지훈이가 움직일 경로가 없다면 탈출 실패 if not J: 🖥 소스 코드 from sys import stdin from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, 1, -1] r, c = map(int, stdin.readline().split()) board, res = [], 0 # 지환이와 불난 곳 저장할 변수 F, J = deque(), deque() for i in range(r): data = list(stdin.readline().rstrip()) for j in range(c): if data[j] == \u0026#39;J\u0026#39;: J.append((i, j)) if data[j] == \u0026#39;F\u0026#39;: F.append((i, j)) board.append(data) def bfs(): global F, J, res while 1: res += 1 temp = [] while F: x, y = F.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c: if board[nx][ny] == \u0026#39;.\u0026#39; or board[nx][ny] == \u0026#39;$\u0026#39;: temp.append((nx, ny)) board[nx][ny] = \u0026#39;F\u0026#39; F = deque(temp) temp = [] while J: x, y = J.popleft() if x == 0 or y == 0 or x == r - 1 or y == c - 1: return res for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c and board[nx][ny] == \u0026#39;.\u0026#39;: temp.append((nx, ny)) board[x][y] = \u0026#39;$\u0026#39; board[nx][ny] = \u0026#39;J\u0026#39; J = deque(temp) if not J: return False if bfs(): print(res) else: print(\u0026#39;IMPOSSIBLE\u0026#39;) 💾 느낀점 BFS 유형 문제에서 난이도가 실버2 ~ 골드4 로만 올라가도 헤매는 모습을 보였다. 방문처리용 배열의 다양한 사용법을 눈에 익히고 응용할 줄 알아야겠다. 방문처리용 배열을 사용하기 전, 메모리 초과가 뜰 각인지 잴 줄 알아야겠다. 문제를 나름대로 해석하고 압축하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4179-%EB%B6%88-with-python/","summary":"📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다.","title":"[BOJ] 4179 불! with Python"},{"content":" 안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Contact. Github : github.com/Jxun-h\nTistory : dreamtreeits.tistory.com\nEmail : its1108@kakao.com Resume. 이력과 포트폴리오를 기재한 이력서입니다. Introduction. 트레이드 오프를 고려해 균형잡힌 선택을 하려 노력합니다.\n안정적인 서비스를 만드는데 기여하고자 노력하는 백엔드 개발자입니다.\n또한 서비스가 안정적으로 운영되기 위한 방법에 대해 고민합니다. Why Post in Blog. 블로그를 처음 쓰기 시작한 것은 2021년 08월 28일 입니다.\n코딩 테스트를 위해 고민했던 내용과 해결 과정들을 오로지 머리로만 기억하는 것에 한계가 있음을 느꼈습니다.\n블로그를 제 두뇌의 외장하드로 쓰기 결심하고, 티스토리에서 포스팅을 시작했습니다.\n그 후 약 1년간 꾸준히 알고리즘 풀이를 포스팅 했고, 2023년 4월 18일 이후 공백기간이 있었습니다.\n2024년을 맞이해 블로그 작성을 통해 쌓여가는 경험과 지식을 되돌아보고 회고록도 써보려고 합니다.\n다시 시작하는 저의 블로그는 github.io 로 시작해보려 합니다. ","permalink":"https://jxun-h.github.io/about/","summary":"짤막한 소개글","title":"About"},{"content":"안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Work Experience TAPartners period 24.01 - current position Back-end Engineer project 건설사업관리 플랫폼 고도화 자세히 보기\n건설사업관리 플랫폼 고도화\n기획 중 Tech Stack\nVue3 Java Oracle SQL period 23.06 - 24.01 position Back-end Engineer project 건설사업관리 플랫폼 구축/개발 자세히 보기\n건설사업관리 플랫폼 구축/개발\nRestful API 작성 다국어 처리를 위한 Oracle Function 생성 및 Query 작성 대용량 Excel Read \u0026amp; Upload 처리 개발 Spring JDBC Batch 적용 약 80% 이상의 업로드 속도 개선\n공사 관련 청구/정산 프로세스 개발 Tech Stack\nVue3 Java Oracle SQL SAX Library POI Excel Library Toogram Systems period 19.12 - 21.01 position Python Back-end Engineer project 선박 자율운항 최적항로 알고리즘 구축/개발 자세히 보기\n선박 자율운항 최적항로 알고리즘 구축/개발\n선박 데이터 전처리 및 가공 선박 운항 데이터 전처리 및 가공 선박 운항 항로 렌더링 처리 그래프 탐색 알고리즘 기반 자율운항 항로 계산 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript period 19.07 - 20.01 position Python Back-end Engineer project 선박 데이터 기반 이상탐지 알고리즘 개발 자세히 보기\n선박 데이터 기반 이상탐지 알고리즘 개발\n선박 데이터 전처리 마할라노비스 다구찌 기반 이상탐지 알고리즘 개발 선박 데이터 시각화 개발 JS 기반 데이터 차트 오픈소스 라이브러리 적용 및 테스트 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript Other Experience Blog Author, Maintainer\n21.08.28 - 현재\n비정기적으로 새롭게 배우고 공부한 내용 등을 글로 작성해 공유합니다.\n블로그는 이전에 약 1년간 사용하던 Tistory 와 현재 보고 계신 Github Pages가 있습니다.\n현재 블로그는 Hugo + github.io 를 사용해 구현했습니다. Internship 한이음 ICT 멘토링 period 18.04 - 18.11 position Intern project 생활 법령 정보제공 챗봇 서비스 개발 자세히 보기\n생활 법령 정보제공 챗봇 서비스 개발\nSoap API 를 사용해 공공데이터포털 크롤링 자연어 처리에 사용할 형태소 분석기를 시스템에 import 자연어 처리 Seq2Seq 연구 및 적용 테스트 카카오톡 챗봇 서비스 API 연결 및 테스트 Tech Stack\nPython Django Soap API MySQL Linux (Ubuntu) 씨에스리 ICT 인턴십 period 18.03 - 18.06 position Intern project 블럭코딩 데이터 분석툴(BigZami) 개발 자세히 보기\n블럭코딩 데이터 분석툴(BigZami) 개발\nNexacro Flatform 기반 컴포넌트 개발 및 연결 SpringBoot 기반 Back-end 환경 구성 R - Java 언어 연동 및 Nexacro Flatform 연동 테스트 Plotly 오픈소스 라이브러리 적용 테스트 Tech Stack\nNexacro Flatform Java Spring Boot OpenSource Library 씨에스리 ICT 인턴십 period 17.09 - 17.12 position Intern project IT 지식 제공 챗봇 개발 자세히 보기\nIT 지식 제공 챗봇 개발\nDjango 기반 개발 서버 환경구축 카카오톡 챗봇 서버와 Restful API 연동 형태소 분석기 테스트 및 사용자 전용 단어 사전 구축 자연어 처리 방법 연구 및 분석 Tech Stack\nDjango Python2 Ubuntu MySQL Rest API Skills Overall. 안정적인 서비스 및 효율적인 구현을 좋아합니다. 최신 기술보다 상황에 따라 적절한 선택을 하는 것이 최적의 결과가 나온다고 믿습니다. 업무에 따라 능숙한 분야가 아니더라도 적극적으로 탐색해 최적의 결과를 낼 수 있도록 노력합니다. Communication. 직위 및 포지션에 관계없이 적극적인 의사소통을 시도합니다. 지적 겸손함을 유지하기 위해 노력합니다. Server. 성능향상을 위한 리팩토링을 한 경험이 있습니다. Java SpringBoot 를 비롯해, Python Django 또한 지원이 가능합니다. 필요하다면 셸스크립트를 작성해 반복되는 업무를 자동화 가능합니다. Python. Python3 환경에 익숙하고 능숙합니다. 웹프레임워크를 필요에 따라 구분해 사용할 수 있으며, 공통 로직을 적절히 모듈화해 사용합니다. Java JDBC를 능숙하게 사용하고, 속도개선을 위해 캐싱이나 배치를 적절히 활용합니다. 불필요한 API 호출을 최대한 삼가하며, 합리적인 방식으로 서비스를 분리합니다. Education Woosuk Univ. 정보보안학과\n2012.03 - 2019.02\n4.31 / 4.5\n정보보안학과에서 4년간 공부하며, 거의 모든 과목을 높은 성적으로 이수하였습니다.\n군대에 가기 전, 가고 싶은 곳에 지원하기 위한 준비를 위해 약 1년 간 휴학했습니다. certificate 정보처리기사 2018.08.17 리눅스마스터 2급 2017.06.10 ","permalink":"https://jxun-h.github.io/resume/","summary":"이력서","title":"Resume"}]