[{"content":"\n📌 BOJ 1244 스위치 켜고 끄기 💡 조건 및 풀이 첫째 줄은 스위치 개수. 스위치 개수는 100 이하인 양의 정수.\n둘째 줄은 각 스위치의 상태. 켜져 있으면 1, 꺼져있으면 0이라고 표시\n셋째 줄에는 학생 수. 학생수는 100 이하인 양의 정수\n넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수. 남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. 여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서,\n그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다. 구현 \u0026amp; 시뮬레이션 유형의 문제 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 문제. 🔖 예제 및 실행결과 예제 8 0 1 0 1 0 0 0 1 2 1 3 2 3 실행결과 1 0 0 0 1 1 0 1 ⌨️ 문제 풀이 학생의 수만큼 순회하여 남자일 때와 여자일 때를 구분하여 작업을 할 수 있도록 조건문을 짠다.\n(내가 문제를 푸는 방식은 이러하다. 이렇게 큰 틀을 짜놓고 구현하면 훨씬 편하다.) 남자는 지문에 나오는 것처럼, 스위치의 상태가 1일 때 0으로, 0일 때 1로 변경해주면 된다. 여자의 경우, 좌우로 대칭하는지 찾기 전에, 현재 학생이 받은 수에 1씩 더하고 빼서 스위치로 입력받은 리스트 범위 내인지부터 확인한다.\n범위 내인 경우, 현재 번호의 양쪽 데이터가 같은지 확인하고, 일치한다면 left, right 변수에 좌측, 우측의 인덱스 번호를 넣어준다. while 반복문으로 양측의 데이터가 같지 않을 때, 리스트의 범위를 벗어날 때 break를 걸어주고\nleft와 right를 갱신한다. while 반복이 끝난 후, range(left, right + 1) 범위의 리스트 원소를 변경해준다.\n0 일때 1, 1 일때, 0 20개씩 출력하는 것은 아래와 같이 for 문에서 조절해주면 된다. for i in range(1, n, 20): print(*switch[i:i+20]) 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) switch = [0] + list(map(int, stdin.readline().split())) for i in range(int(stdin.readline())): g, num = map(int, stdin.readline().split()) if g == 1: for i in range(num, n + 1, num): switch[i] = 1 if switch[i] == 0 else 0 elif g == 2: if num + 1 \u0026gt; n or num - 1 \u0026lt; 1: switch[num] = 1 if switch[num] == 0 else 0 else: if switch[num + 1] == switch[num - 1]: left = num - 1 right = num + 1 while 1: if left - 1 \u0026lt; 1 or right + 1 \u0026gt; n: break if switch[left - 1] != switch[right + 1]: break else: left -= 1 right += 1 for i in range(left, right + 1): switch[i] = 1 if switch[i] == 0 else 0 else: switch[num] = 1 if switch[num] == 0 else 0 for i in range(1, n, 20): print(*switch[i:i+20]) 💾 느낀점 조건문만 충실히 지키면 잘 풀 수 있는 문제였다. 여학생이 바꾸는 스위치들의 조건을 구현하는데에 살짝 힘이 들뻔했다. 링크드리스트로 풀수 있을 것 같다는 생각을 했다. 다음번에는 링크드 리스트로 구현하는 연습을 해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-1244-%EC%8A%A4%EC%9C%84%EC%B9%98-%EC%BC%9C%EA%B3%A0-%EB%81%84%EA%B8%B0-with-python/","summary":"📌 BOJ 1244 스위치 켜고 끄기 💡 조건 및 풀이 첫째 줄은 스위치 개수. 스위치 개수는 100 이하인 양의 정수.\n둘째 줄은 각 스위치의 상태. 켜져 있으면 1, 꺼져있으면 0이라고 표시\n셋째 줄에는 학생 수. 학생수는 100 이하인 양의 정수\n넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수. 남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다.","title":"[BOJ] 1244 스위치 켜고 끄기 with Python"},{"content":"\n📌 Programmers - 광고 삽입 💡 조건 및 풀이 동영상에 광고를 넣어야한다. 시청자가 가장 많은 구간에 광고를 넣어야한다.\n= 시청자 수 구간합이 가장 큰 곳에 광고를 넣어야한다. 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time,\n시청자들이 해당 동영상을 재생했던 구간 정보 logs 구간합을 구해 답을 이끌어내는 유형의 문제 play_time, adv_time은 길이 8로 고정된 문자열\nplay_time, adv_time은 HH:MM:SS 형식이며,\n00:00:01 \u0026lt;= play_time, adv_time \u0026lt;= 99:59:59 공익광고 재생시간은 동영상 재생시간보다 짧거나 같다. 1 \u0026lt;= logs \u0026lt;= 300000 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;02:03:55\u0026#34;, \u0026#34;00:14:15\u0026#34;, [\u0026#34;01:20:15-01:45:14\u0026#34;, \u0026#34;00:40:31-01:00:00\u0026#34;, \u0026#34;00:25:50-00:48:29\u0026#34;, \u0026#34;01:30:59-01:53:29\u0026#34;, \u0026#34;01:37:44-02:02:30\u0026#34;])) 실행결과 \u0026#34;01:30:59\u0026#34; ⌨️ 문제 풀이 play_time, adv_time (동영상 재생 길이, 광고 재생 길이)를 각각 str 타입에서 int 타입으로 변경한다. def str_to_int(time): h, m, s = time.split(\u0026#39;:\u0026#39;) return int(h) * 3600 + int(m) * 60 + int(s) 각 구간의 시청자들의 수를 기록할 배열을 만든다. all_time = [0 for i in range(play_time + 1)] logs 를 순회하면서 시청 시작 시간에 시청자 수 + 1\n시청 종료 시간에 시청자 수 - 1 구간별 시청자 기록을 위해 all_time 배열을 순회하면서, 이전 배열의 값을 가지고 현재 배열에 더해주는 작업을 해줍니다. for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] 모든 구간의 시청자 누적 기록을 위해 다시 한번 4번의 작업을 해줍니다. 누적된 구간별 시청자 수의 정보가 저장된 배열을 순회하면서 시청자가 가장 많은 구간을 탐색합니다. # 가장 시청자 수가 많은 구간을 탐색 for i in range(adv_time - 1, play_time): # i가 공익 광고 시청 시간보다 빠를 때 if i \u0026gt;= adv_time: # 지금까지 최대 누적 시청자 수가 (총 누적 시청자 수 - 해당 구간 시청자 수) 보다 작으면? if most_view \u0026lt; all_time[i] - all_time[i - adv_time]: # 지금까지 최대 누적 시청자 수를 갱신 most_view = all_time[i] - all_time[i - adv_time] # 최대 누적 시청자 수에 해당하는 구간을 갱신 max_time = i - adv_time + 1 else: # 최대 시청자 수가 현재 탐색하는 시간대의 총 누적 시청자 수보다 적을 때 if most_view \u0026lt; all_time[i]: # 최대 시청자 수와 그에 해당하는 시간대를 갱신 most_view = all_time[i] max_time = i - adv_time + 1 최대 시청자가 있는 광고 삽입 시간을 HH:MM:SS 형식으로 변환하여 return 합니다. 🖥 소스 코드 def solution(play_time, adv_time, logs): play_time = str_to_int(play_time) adv_time = str_to_int(adv_time) all_time = [0 for i in range(play_time + 1)] for l in logs: start, end = l.split(\u0026#39;-\u0026#39;) start = str_to_int(start) end = str_to_int(end) all_time[start] += 1 all_time[end] -= 1 for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] for i in range(1, len(all_time)): all_time[i] = all_time[i] + all_time[i - 1] most_view = 0 max_time = 0 for i in range(adv_time - 1, play_time): if i \u0026gt;= adv_time: if most_view \u0026lt; all_time[i] - all_time[i - adv_time]: most_view = all_time[i] - all_time[i - adv_time] max_time = i - adv_time + 1 else: if most_view \u0026lt; all_time[i]: most_view = all_time[i] max_time = i - adv_time + 1 return int_to_str(max_time) def str_to_int(time): h, m, s = time.split(\u0026#39;:\u0026#39;) return int(h) * 3600 + int(m) * 60 + int(s) def int_to_str(time): h = time // 3600 h = \u0026#39;0\u0026#39; + str(h) if h \u0026lt; 10 else str(h) time = time % 3600 m = time // 60 m = \u0026#39;0\u0026#39; + str(m) if m \u0026lt; 10 else str(m) time = time % 60 s = \u0026#39;0\u0026#39; + str(time) if time \u0026lt; 10 else str(time) return h + \u0026#39;:\u0026#39; + m + \u0026#39;:\u0026#39; + s 💾 느낀점 문자열 타입의 시간 형식 데이터는 각 시간, 분, 초를 합쳐 숫자로 만들어 다루는 것이 편하다. 구간별 시청자 기록과 모든 구간의 시청자 누적 기록을 하는 부분에서 많은 이해가 필요했다.\n스스로 이해하지 못해 다른 블로그를 참고하여 코드를 작성했다. 모든 구간의 시청자 누적 기록을 순회하는 부분에서도 이해가 어려워 여러번 코드를 디버깅했다.\n이해를 하는 방향으로 코드를 보고 나의 방식으로 코드를 작성하는 시간이 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/temp/programmers-%EA%B4%91%EA%B3%A0-%EC%82%BD%EC%9E%85-with-python/","summary":"📌 Programmers - 광고 삽입 💡 조건 및 풀이 동영상에 광고를 넣어야한다. 시청자가 가장 많은 구간에 광고를 넣어야한다.\n= 시청자 수 구간합이 가장 큰 곳에 광고를 넣어야한다. 동영상 재생시간 길이 play_time, 공익광고의 재생시간 길이 adv_time,\n시청자들이 해당 동영상을 재생했던 구간 정보 logs 구간합을 구해 답을 이끌어내는 유형의 문제 play_time, adv_time은 길이 8로 고정된 문자열\nplay_time, adv_time은 HH:MM:SS 형식이며,\n00:00:01 \u0026lt;= play_time, adv_time \u0026lt;= 99:59:59 공익광고 재생시간은 동영상 재생시간보다 짧거나 같다.","title":"[Programmers] 광고 삽입 with Python"},{"content":"\n📌 Programmers - 표 편집 💡 조건 및 풀이 표의 원본 행의 개수를 나타내는 변수 n\n5 ≤ n ≤ 1,000,000 처음에 선택되어 있는 행의 위치 k\n0 ≤ k \u0026lt; n 수행한 명령어들이 담긴 문자열 배열 cmd\n1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 \u0026quot;U X\u0026quot;, \u0026quot;D X\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;Z\u0026quot; 중 하나 Linked List 자료구조 문제 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않는다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) \u0026ldquo;Z\u0026quot;가 명령어로 주어지는 경우는 없다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 🔖 예제 및 실행결과 예제 print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;])) print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;U 1\u0026#34;, \u0026#34;C\u0026#34;])) 실행결과 \u0026#34;OOOOXOOO\u0026#34; \u0026#34;OOXOXOOO\u0026#34; ⌨️ 문제 풀이 Double Linked List 자료구조를 알고, 구현할 수 있다면 풀이가 가능한 문제이다. Double Linked List 는 쉽게 말해 각 노드의 포인터가 다음, 혹은 이전의 노드를 가리키는 정보를 두개 담고 있다. 연결리스트를 사용해 cmd 에 있는 명령을 수행하기 전의 원본 표의 데이터를 입력한다. class Node: def __init__(self, data=None, state=1): # 노드의 정보, 값을 저장 self.value = data # 노드가 가지고 있을 전, 후를 가리키는 값은 None으로 초기화 self.next = None self.priv = None def __init__(self): self.header = Node() self.tail = Node() self.header.next = self.tail self.header.priv = self.header self.tail.next = self.tail self.tail.priv = self.header self.pointer = self.header linkedlist = DoubleLinkedList() pointer = linkedlist.header for i in range(n): # 노드를 추가함 linkedlist.add(Node(i)) 가장 처음에 가리키고 있는 포인터를 정해주어야하기 때문에 현재 연결리스트의 포인터를 k로 맞춰주는 작업을 한다. # 포인터의 값이 k와 다르면 계속 반복 while pointer.value != k: # 포인터는 현재 포인터의 다음 것을 가리킨다. pointer = pointer.next cmd를 순회하면서 요쳉에 대한 작업을 진행한다.\n삭제를 진행하고, 복구를 하는 작업은 stack(list) 을 하나 만들어, 삭제가 진행됐을 때 저장한다.\n복구를 할 때는 리스트에서 pop 을 하여 데이터를 꺼내오면 된다. 삭제의 작업은 다음과 같다.\n삭제될 노드를 미리 stack 에 넣어준 뒤,\n현재의 포인터 기준으로 이전 노드에서 자신을 가리키던 것을 다음 노드를 가리키게 해주면 된다. def delete(self, pointer): if pointer.priv == self.header: self.header.next = pointer.next pointer.next.priv = self.header return self.header.next elif pointer.next == self.tail: _pointer = pointer.priv self.tail.priv = _pointer _pointer.next = self.tail return _pointer else: _pointer = pointer.next pointer.priv.next = pointer.next pointer.next.priv = pointer.priv return _pointer 복구의 작업은 다음과 같다.\n복구될 노드를 stack에서 뽑아 변수에 저장한 뒤, 추가를 해준다. def add(self, node): self.pointer.next = node node.priv = self.pointer node.next = self.tail self.pointer = node 가리키는 곳을 이동하는 것은 이동하려는 칸의 수만큼 반복문을 통해 옮겨주면 된다. def move(self, pointer, v, step): for _ in range(step): if v == \u0026#39;D\u0026#39;: pointer = pointer.next else: pointer = pointer.priv return pointer 🖥 소스 코드 class Node: def __init__(self, data=None, state=1): # 노드의 정보, 값을 저장 self.value = data # 노드가 가지고 있을 전, 후를 가리키는 값은 None으로 초기화 self.next = None self.priv = None class DoubleLinkedList: def __init__(self): self.header = Node() self.tail = Node() self.header.next = self.tail self.header.priv = self.header self.tail.next = self.tail self.tail.priv = self.header self.pointer = self.header def add(self, node): self.pointer.next = node node.priv = self.pointer node.next = self.tail self.pointer = node def move(self, pointer, v, step): for _ in range(step): if v == \u0026#39;D\u0026#39;: pointer = pointer.next else: pointer = pointer.priv return pointer def delete(self, pointer): if pointer.priv == self.header: self.header.next = pointer.next pointer.next.priv = self.header return self.header.next elif pointer.next == self.tail: _pointer = pointer.priv self.tail.priv = _pointer _pointer.next = self.tail return _pointer else: _pointer = pointer.next pointer.priv.next = pointer.next pointer.next.priv = pointer.priv return _pointer def insert(self, pointer): pointer.priv.next = pointer pointer.next.priv = pointer def get_answer(n, linkedlist): # 답이 될 리스트 생성 answer = [\u0026#39;X\u0026#39; for _ in range(n)] # 연결리스트의 첫 헤더부터 포인터를 따라 순차적으로 방문하여 # answer 원소 갱신 pointer = linkedlist.header.next while pointer != linkedlist.tail: answer[pointer.value] = \u0026#39;O\u0026#39; pointer = pointer.next return \u0026#39;\u0026#39;.join(answer) def solution(n, k, cmd): # double linked list 초기화 linkedlist = DoubleLinkedList() # 포인터 설정 pointer = linkedlist.header # 삭제 요청 수행 시 삭제된 노드를 넣을 쓰레기통 stack = [] for i in range(n): # 노드를 추가함 linkedlist.add(Node(i)) # 포인터의 값이 k와 다르면 계속 반복 while pointer.value != k: # 포인터는 현재 포인터의 다음 것을 가리킨다. pointer = pointer.next # 요청 문자에 대하 수행 시작 for string in cmd: # 삭제 요청 if string == \u0026#39;C\u0026#39;: # 현재 삭제될 포인터를 쓰레기통에 넣음 stack.append(pointer) # 연결 리스트에서 노드를 삭제 pointer = linkedlist.delete(pointer) # 복구 요청 elif string == \u0026#39;Z\u0026#39;: # 쓰레기 통에 가장 마지막으로 추가된 노드 추출 # == 연결 리스트에서 가장 최근에 삭제된 노드 _pointer = stack.pop() # 연결리스트에 삽입 linkedlist.insert(_pointer) else: v, step = string.split() # 포인터 이동 pointer = linkedlist.move(pointer, v, int(step)) # 답 만들기 answer = get_answer(n, linkedlist) return answer print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;])) print(solution(8, 2, [\u0026#34;D 2\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 3\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D 4\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;U 2\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;Z\u0026#34;, \u0026#34;U 1\u0026#34;, \u0026#34;C\u0026#34;])) 💾 느낀점 문제를 풀지 못해서 다른 분의 아이디어를 참고하여 연결리스트를 먼저 구현해보고자 했었다.\n자료구조를 class 형식으로 구현하는 연결리스트에 놀랬다.\n처음보는 자료구조였고, 감탄할 수밖에 없는 풀이였다.\n그 후 이중 연결 리스트를 보면서 비슷한 유형의 문제가 나온다면\n연결리스트를 구현해서 풀어보고 싶다는 생각을 했다. 단순히 stack에 삭제한 노드 번호를 넣고, 노드번호를 이분탐색으로 제자리에 복구하려는 시도를 했으나\n구현부분이 까다롭고 구현하면서도 조금씩 제한되고 구현하기에 어려운 부분이 있어 풀이를 참고 했다. 현재까지 2회 풀었는데, 아직 이전 소스를 참고하지 않고 완벽하게 이중 연결 리스트를 구현하기가 어려웠다.\n매일 볼때마다 조금은 새로운 이중 연결 리스트 구현 방법의 숙달과 관련 문제 풀이가 필요할 것 같다. ","permalink":"https://jxun-h.github.io/posts/temp/programmers-%ED%91%9C-%ED%8E%B8%EC%A7%91-with-python/","summary":"📌 Programmers - 표 편집 💡 조건 및 풀이 표의 원본 행의 개수를 나타내는 변수 n\n5 ≤ n ≤ 1,000,000 처음에 선택되어 있는 행의 위치 k\n0 ≤ k \u0026lt; n 수행한 명령어들이 담긴 문자열 배열 cmd\n1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 \u0026quot;U X\u0026quot;, \u0026quot;D X\u0026quot;, \u0026quot;C\u0026quot;, \u0026quot;Z\u0026quot; 중 하나 Linked List 자료구조 문제 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않는다.","title":"[Programmers] 표 편집 with Python"},{"content":"\n📌 Programmers - 순위 검색 💡 조건 및 풀이 조건을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n를 구하는 문제\n'-' 표시는 해당 조건을 고려하지 않겠다는 의미.\n\u0026#34;cpp and - and senior and pizza 500\u0026#34; 은를 의미한다.\n\u0026quot;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026quot;\n브루트포스 알고리즘 유형의 문제에 해당한다.\n🔖 예제 및 실행결과 예제 info = [\u0026#34;java backend junior pizza 150\u0026#34;, \u0026#34;python frontend senior chicken 210\u0026#34;, \u0026#34;python frontend senior chicken 150\u0026#34;,\u0026#34;cpp backend senior pizza 260\u0026#34;, \u0026#34;java backend junior chicken 80\u0026#34;, \u0026#34;python backend senior chicken 50\u0026#34;] query = [\u0026#34;java and backend and junior and pizza 100\u0026#34;, \u0026#34;python and frontend and senior and chicken 200\u0026#34;, \u0026#34;cpp and - and senior and pizza 250\u0026#34;, \u0026#34;- and backend and senior and - 150\u0026#34;, \u0026#34;- and - and - and chicken 100\u0026#34;, \u0026#34;- and - and - and - 150\u0026#34;] 실행결과 [1,1,1,1,2,4] ⌨️ 문제 풀이 info 배열을 순회하며 얻은 데이터를 잘라 배열로 만들고, 그 배열을 각각 데이터와 점수 부분으로 나누어 준다. temp = j.split() condition = temp[:-1] score = int(temp[-1]) 지원서에 입력한 4개의 값 range(4)의 데이터를 combinations 을 이용해\n짝을 지어 각 1부터 4개까지의 경우의 수와 점수를 dict 자료구조에 넣어준다. for i in range(5): comb = list(combinations(range(4), i)) for c in comb: test_case = condition.copy() for idx in c: test_case[idx] = '-' case = ''.join(test_case) if case not in data: data[case] = [score] else: data[case].append(score) 이분탐색 라이브러리인 bisect 라이브러리를 사용해 사용을 할 것이기 때문에 dict 자료구조의 value를 정렬해준다. 파라미터로 받아온 sql을 순차적으로 돌면서 and 문자열을 \u0026lsquo;\u0026lsquo;로 바꾸어주고 split 해준다.\ntest_query 와 test_score 로 나누어주고, test_query에 해당하는 인원 중(data의 key)\ntest_score 이상의 점수를 얻은(data의 value) 인원의 수를 계산하여 answer에 입력해준다. 🖥 소스 코드 from itertools import combinations from bisect import bisect_left def solution(info, query): answer, data, sql = [], {}, [] n, m = len(info), len(query) for j in info: temp = j.split() condition = temp[:-1] score = int(temp[-1]) for i in range(5): comb = list(combinations(range(4), i)) for c in comb: test_case = condition.copy() for idx in c: test_case[idx] = \u0026#39;-\u0026#39; case = \u0026#39;\u0026#39;.join(test_case) if case not in data: data[case] = [score] else: data[case].append(score) for i in data.values(): i.sort() for i in range(m): sql = query[i].replace(\u0026#39;and\u0026#39;, \u0026#39;\u0026#39;).split() test_query = \u0026#39;\u0026#39;.join(sql[:-1]) test_score = int(sql[-1]) if test_query in data: idx = bisect_left(data[test_query], test_score) answer.append(len(data[test_query]) - idx) else: answer.append(0) return answer 💾 느낀점 모든 경우의 수를 data 에 입력하여 찾는 아이디어를 구상하는 것이 힘이 들었다. sql에 해당하는 지원자를 이분탐색으로 찾을 아이디어와 dict 자료구조를 사용할 아이디어를 떠올리니\n구현하는데에는 큰 무리가 없었던 것 같다. 포스팅 내용을 보니 아예 아이디어를 얻지 못한 분들이 보시기에 괜찮을까 라는 생각이 들면서,\n설명하는 능력이 조금 부족하다고 느낀다. ","permalink":"https://jxun-h.github.io/posts/temp/programmers-%EC%88%9C%EC%9C%84-%EA%B2%80%EC%83%89-with-python/","summary":"📌 Programmers - 순위 검색 💡 조건 및 풀이 조건을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?\n를 구하는 문제\n'-' 표시는 해당 조건을 고려하지 않겠다는 의미.\n\u0026#34;cpp and - and senior and pizza 500\u0026#34; 은를 의미한다.\n\u0026quot;cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?\u0026quot;\n브루트포스 알고리즘 유형의 문제에 해당한다.\n🔖 예제 및 실행결과 예제 info = [\u0026#34;java backend junior pizza 150\u0026#34;, \u0026#34;python frontend senior chicken 210\u0026#34;, \u0026#34;python frontend senior chicken 150\u0026#34;,\u0026#34;cpp backend senior pizza 260\u0026#34;, \u0026#34;java backend junior chicken 80\u0026#34;, \u0026#34;python backend senior chicken 50\u0026#34;] query = [\u0026#34;java and backend and junior and pizza 100\u0026#34;, \u0026#34;python and frontend and senior and chicken 200\u0026#34;, \u0026#34;cpp and - and senior and pizza 250\u0026#34;, \u0026#34;- and backend and senior and - 150\u0026#34;, \u0026#34;- and - and - and chicken 100\u0026#34;, \u0026#34;- and - and - and - 150\u0026#34;] 실행결과 [1,1,1,1,2,4] ⌨️ 문제 풀이 info 배열을 순회하며 얻은 데이터를 잘라 배열로 만들고, 그 배열을 각각 데이터와 점수 부분으로 나누어 준다.","title":"[Programmers] 순위 검색 with Python"},{"content":"\n📌 BOJ 10775 공항 💡 조건 및 풀이 공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다. 공항에는 P개의 비행기가 순서대로 도착할 예정. i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다. Union - Find 알고리즘 유형의 문제 비행기를 최대 몇 대 도킹시킬 수 있는지 구하는 문제. 게이트의 수 G (1 ≤ G ≤ 105)\n비행기의 수 P (1 ≤ P ≤ 105)\nP개의 줄에 gi (1 ≤ gi ≤ G) 🔖 예제 및 실행결과 예제 4 3 4 1 1 실행결과 2 ⌨️ 문제 풀이 각 비행기의 번호를 입력 받을 때 1부터 시작하기 때문에 게이트 수 + 1 만큼 배열 parent 를 생성한다. 배열의 원소값은 각 인덱스 값과 동일하게 하는데, 이것을 부모를 자신으로 둔 것이라고 생각하면 좋다. 비행기의 번호 gi 를 입력 받아 gi의 부모를 찾는다. data = find_parent(parent, gi) 만약 data 가 존재하지 않는 0번 게이트에 도킹을 해야할 경우 반복문을 중단한다. 4번 이 아니라면 res += 1. gi 번 비행기가 data 번 게이트에 도킹을 했고, 그 게이트에는 다른 비행기가 도킹 할 수 없으니\ndata - 1 번호의 게이트를 가리키는 게이트가 됐다고 생각하자. union_parent(parent, data, data - 1) 순서대로 들어오는 비행기를 반복적으로 수행하다, 4번 의 조건에 걸리는 경우 반복문을 중단하고 결과를 출력한다. 🖥 소스 코드 from sys import stdin def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x] def union_parent(parent, a, b): a = find_parent(parent,a) b = find_parent(parent,b) if a \u0026gt;b: parent[a] = b else: parent[b] = a g = int(stdin.readline()) p = int(stdin.readline()) parent = [x for x in range(g + 1)] res = 0 for i in range(p): gi = int(stdin.readline()) data = find_parent(parent, gi) if data == 0: break res += 1 union_parent(parent, data, data - 1) print(res) 💾 느낀점 내가 좋아하는 Union-Find 문제이다. 처음 풀어보는 유형이라 조금 헷갈리긴 했지만, 게이트와 비행기의 관계를 조금 파악하니\n소스코드라도 짜면서 시도해볼 수 있었다. 유파 알고리즘 문제는 find_parent, union_parent 의 로직을 외워두니 훨~씬 수월했다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-10775-%EA%B3%B5%ED%95%AD-with-python/","summary":"📌 BOJ 10775 공항 💡 조건 및 풀이 공항에는 G개의 게이트가 있으며 각각은 1에서 G까지의 번호를 가지고 있다. 공항에는 P개의 비행기가 순서대로 도착할 예정. i번째 비행기를 1번부터 gi (1 ≤ gi ≤ G) 번째 게이트중 하나에 영구적으로 도킹 비행기가 어느 게이트에도 도킹할 수 없다면 공항이 폐쇄되고, 이후 어떤 비행기도 도착할 수 없다. Union - Find 알고리즘 유형의 문제 비행기를 최대 몇 대 도킹시킬 수 있는지 구하는 문제. 게이트의 수 G (1 ≤ G ≤ 105)","title":"[BOJ] 10775 공항 with Python"},{"content":"\n📌 Programmers - 메뉴 리뉴얼 💡 조건 및 풀이 orders 배열의 크기는 2 이상 20 이하. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열.\n각 문자열은 알파벳 대문자로만 이루어져 있으며 중복은 허용 안함. course 배열의 크기는 1 이상 10 이하.\ncourse 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return\n배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬\n만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return\n무조건 return 하는 배열의 길이가 1 이상 Python 조합(combinations) 라이브러리를 사용해 구현\ndict를 사용해도 되는 문제.\n정렬이 중요한 문제. 각 손님은 단품메뉴를 2개 이상 주문해야 한다. 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함 🔖 예제 및 실행결과 예제 print(solution([\u0026#34;ABCFG\u0026#34;, \u0026#34;AC\u0026#34;, \u0026#34;CDE\u0026#34;, \u0026#34;ACDE\u0026#34;, \u0026#34;BCFG\u0026#34;, \u0026#34;ACDEH\u0026#34;], [2, 3, 4])) 실행결과 [\u0026#34;AC\u0026#34;, \u0026#34;ACDE\u0026#34;, \u0026#34;BCFG\u0026#34;, \u0026#34;CDE\u0026#34;] ⌨️ 문제 풀이 주문을 받은 orders 배열을 순차적으로 순회할 반복문.\n순회하며 메뉴들을 리스트로 만들어 정렬.\n코스를 만들 메뉴 개수를 순회할 반복문. \u0026laquo; 여기까지 2중 반복문. j\n조합 라이브러리를 사용해 3번 반복문에서 나오는 코스의 메뉴개수만큼 메뉴를 뽑아서\n중복을 없앤 뒤 t문자열에 저장. (t는 j 개를 뽑아 만든 메뉴의 조합입니다.)\nlist(set(combinations(data, j))) # set()은 중복을 없애줍니다! t 가 점수판에 없으면 새로 등록시켜 1점 부여\nt 가 점수판에 있으면 1점 부여\n최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합 만 해당하기 때문에\nscore에 저장된 점수가 1점 이상이라면 new_score에 (메뉴, 점수) 형식으로 저장 후 점수를 기준으로 정렬\n\u0026#34;\u0026#34;\u0026#34; # lambda 설명 x 를 x[1] 기준으로 정렬할건데, -가 붙으면 역순입니다. \u0026#34;\u0026#34;\u0026#34; new_score.sort(key=lambda x: -x[1]) 마지막으로 코스요리를 구성할 메뉴 개수를 순회하면서 new_score에 넣은 코스메뉴 후보들을 검사하면서\n정답으로 반환할 배열 answer에 넣어주고, 정렬을 한 뒤 반환 시켜준다.\n🖥 소스 코드 from itertools import combinations def solution(orders, course): answer = [] score = {} n = len(orders) for i in range(n): data = sorted(list(orders[i])) for j in course: for k in list(set(combinations(data, j))): t = \u0026#39;\u0026#39;.join(k) if t in score: score[t] += 1 else: score[t] = 1 new_score = [] for menu, num in score.items(): if num \u0026gt; 1: new_score.append((menu, num)) new_score.sort(key=lambda x: -x[1]) for i in course: max_order = 0 for c, num in new_score: if len(c) == i: if max_order \u0026lt;= num: max_order = num answer.append(c) else: break answer.sort() return answer 💾 느낀점 정렬을 할 때 lambda를 많이 사용한게 도움이 되었다. combinations를 사용해서 번거로운 일이 적어서 좋았다.\n이런 간편한 라이브러리를 알고 있다는 것보다 사용할 때를 알고 있다는게 기분 좋았다. 카카오 기춟문제는 문제도 길고 조건도 자세하게 써있는데 눈에 잘 안들어온다.\n아직 문제 압축능력이 부족한 것 같다. ","permalink":"https://jxun-h.github.io/posts/temp/programmers-%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC-with-python/","summary":"📌 Programmers - 메뉴 리뉴얼 💡 조건 및 풀이 orders 배열의 크기는 2 이상 20 이하. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열.\n각 문자열은 알파벳 대문자로만 이루어져 있으며 중복은 허용 안함. course 배열의 크기는 1 이상 10 이하.\ncourse 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return\n배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬","title":"[Programmers] 메뉴 리뉴얼 with Python"},{"content":"\n📌 BOJ 2143 두 배열의 합 💡 조건 및 풀이 (-1,000,000,000 ≤ T ≤ 1,000,000,000) (1 ≤ n ≤ 1,000) (1 ≤ m ≤ 1,000) 누적합 유형의 문제 두 배열의 부분배열을 사용하여 합을 구해 T를 만들 수 있는 개수를 구한다. 🔖 예제 및 실행결과 예제 5 4 1 3 1 2 3 1 3 2 실행결과 7 ⌨️ 문제 풀이 A 부분 배열의 합들과 B 부분 배열의 합들을 더해 T가 만들어지는 경우의 수를 구하는 문제였다.\n두 배열을 각 구간에 해당하는 누적합을 각각의 dict 자료구조에 넣고, 중복되어 나오는 경우 +1 을 해준다.\nA 배열의 키 값을 순차적으로 순회하면서\n구하고자 하는 t 값에서 A 배열의 키 값을 빼준 값이 B배열의 키값으로 있다면,\nres에 해당 B배열의 값과 A배열의 값을 곱하여 더해준다.\nfor key in Asum.keys(): if (t - key) in Bsum: res += Bsum[t - key] * Asum[key] 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(int(1e9)) t = int(stdin.readline()) n = int(stdin.readline()) A = list(map(int, stdin.readline().split())) m = int(stdin.readline()) B = list(map(int, stdin.readline().split())) Asum = {} for i in range(n): for j in range(i, n): k = sum(A[i:j + 1]) if k in Asum: Asum[k] += 1 else: Asum[k] = 1 Bsum = {} for i in range(m): for j in range(i, m): k = sum(B[i:j + 1]) if k in Bsum: Bsum[k] += 1 else: Bsum[k] = 1 res = 0 for key in Asum.keys(): if (t - key) in Bsum: res += Bsum[t - key] * Asum[key] print(res) 💾 느낀점 처음에 아이디어가 떠오르지않아 힘들어했다. 수학, DP가 제일 약한 것 같다는 생각이 들었다. Dict 자료구조를 좋아하는데 이렇게 사용을 해봐서 더 좋았다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-2143-%EB%91%90-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 2143 두 배열의 합 💡 조건 및 풀이 (-1,000,000,000 ≤ T ≤ 1,000,000,000) (1 ≤ n ≤ 1,000) (1 ≤ m ≤ 1,000) 누적합 유형의 문제 두 배열의 부분배열을 사용하여 합을 구해 T를 만들 수 있는 개수를 구한다. 🔖 예제 및 실행결과 예제 5 4 1 3 1 2 3 1 3 2 실행결과 7 ⌨️ 문제 풀이 A 부분 배열의 합들과 B 부분 배열의 합들을 더해 T가 만들어지는 경우의 수를 구하는 문제였다.","title":"[BOJ] 2143 두 배열의 합 with Python"},{"content":"\n📌 BOJ 1799 비숍 💡 조건 및 풀이 체스판의 크기는 10 이하의 자연수 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0 대각선 방향으로 움직이는 비숍이 이동할 수 있는 경로에 비숍을 놓을 수 없다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 1 실행결과 7 ⌨️ 문제 풀이 흑과 백을 구분할 수 있는 체스판을 True 와 False 를 사용해 다시 만든다. 비숍을 놓을 수 있는 좌표를 흑과 백으로 나누어 각각 black 과 white 리스트에 넣어준다. 비숍을 놓고, 놓을 수 없는 곳을 표시할 때 사용할 isused 리스트를 생성한다. 재귀함수를 타고 각 좌표에 해당하는 곳이 isused01, isused02 모두 사용 중이거나\n놓을 수 없는 자리라면 index를 하나 늘리고 다시 재귀. 4번에 해장하지 않으면 비숍을 놓고 놓은 비숍 개수와 index를 1씩 늘리고 재귀 재귀를 빠져나오면 직전에 놓았던 비숍의 정보를 제거하고 다음 좌표로 넘어가기 위해 index + 1 하고 재귀 index값이 흰색 혹은 검정색 비숍 좌표의 길이와 같다면 검정색의 최댓값과 흰색의 최댓값을 각각 Bcnt와 Wcnt에 저장한다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) chess_map = [] black = [] white = [] color = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): color[i][j] = (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0) for i in range(n): chess_map.append(list(map(int, input().split()))) for j in range(n): # True가 검은색 if chess_map[i][j] == 1 and color[i][j] == 1: black.append((i, j)) # False가 흰색 if chess_map[i][j] == 1 and color[i][j] == 0: white.append((i, j)) # 검은색인 경우 Bcnt = 0 # 흰색인 경우 Wcnt = 0 isused01 = [0] * (n * 2 - 1) isused02 = [0] * (n * 2 - 1) def fun(bishop, index, count): global Bcnt, Wcnt if index == len(bishop): rx, ry = bishop[index - 1] # 블랙이면 Bcnt 최대값 if color[rx][ry]: Bcnt = max(Bcnt, count) # 흰색이면 Wcnt 최대값 else: Wcnt = max(Wcnt, count) return x, y = bishop[index] if isused01[x + y] or isused02[x - y + n - 1]: fun(bishop, index + 1, count) else: isused01[x + y] = 1 isused02[x - y + n - 1] = 1 fun(bishop, index + 1, count + 1) isused01[x + y] = 0 isused02[x - y + n - 1] = 0 fun(bishop, index + 1, count) if len(black) \u0026gt; 0: fun(black, 0, 0) if len(white) \u0026gt; 0: fun(white, 0, 0) print(Bcnt + Wcnt) 💾 느낀점 무지성 백트래킹으로 풀려다가 시간초과가 떴다. 백트래킹을 잘하려면 재귀를 잘 짤줄 알아야하는데 아직도 재귀함수가 약점이다. 흑, 백 칸을 구분지어 구현하는데에도 헷갈리는 부분이 있었다. 함수를 구현하고서도 이해가 안되는 부분이 있어서 별표를 많이 쳐놨다. 다시는 풀고 싶지 않은 유형이지만, 그래도 옛날보다는 나아지는 느낌을 받는다.\n다시 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-1799-%EB%B9%84%EC%88%8D-with-python/","summary":"📌 BOJ 1799 비숍 💡 조건 및 풀이 체스판의 크기는 10 이하의 자연수 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0 대각선 방향으로 움직이는 비숍이 이동할 수 있는 경로에 비숍을 놓을 수 없다. 백트래킹 유형의 문제 🔖 예제 및 실행결과 예제 5 1 1 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 1 실행결과 7 ⌨️ 문제 풀이 흑과 백을 구분할 수 있는 체스판을 True 와 False 를 사용해 다시 만든다.","title":"[BOJ] 1799 비숍 with Python"},{"content":"\n📌 BOJ 1967 트리의 지름 💡 조건 및 풀이 노드의 개수 (1 ≤ n ≤ 10,000) 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호\n두 번째 정수는 자식 노드\n세 번째 정수는 간선의 가중치 부모 노드의 번호가 작은 것이 먼저 입력되고,\n부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. BFS 유형의 문제 루트 노드의 번호는 항상 1\n간선의 가중치는 100보다 크지 않은 양의 정수 트리에 존재하는 모든 경로들 중, 가장 긴 경로를 출력하는 문제이다. 🔖 예제 및 실행결과 예제 12 1 2 3 1 3 2 2 4 5 3 5 11 3 6 9 4 7 1 4 8 7 5 9 15 5 10 4 6 11 6 6 12 10 실행결과 45 ⌨️ 문제 풀이 BFS 문제 였지만, 트리의 길이를 구하는 문제라고 하기에 당황을 했다. BFS 를 통해 루트 노드인 1 부터 탐색을 시작해서 가중치가 가장 높은 것을\n반환받아 변수에 담는다. 변수에는 (node, cost) 형식으로 있는데, 이 node 번호를 다시 BFS에 넣어 처리한다. 3번을 통해서 반환 된 (node, cost) 에서 cost가 답이 된다. 다시 설명하자면,\n2번에서 BFS 로 가장 가중치가 많이 쌓이는 노드를 탐색한다. 이를 A-node 라고 하고,\n3번에서 A-node에서부터 가장 가중치가 많이 쌓이는 곳으로 순회를 하여 B-node라고 한다.\n문제에서 설명하듯, 이 두 노드가 가장 높은 가중치를 가지고 있는 경로 즉, 지름이 된다. 🖥 소스 코드 from sys import stdin from collections import deque n = int(stdin.readline()) tree = [[] for _ in range(n + 1)] for _ in range(n - 1): a, b, c = map(int, stdin.readline().split()) tree[a].append((b, c)) tree[b].append((a, c)) def bfs(i): visited = set() q = deque() q.append((i, 0)) visited.add(i) res = (0, 0) while q: now, cost = q.popleft() for n, c in tree[now]: if n not in visited: visited.add(n) t = c + cost q.append((n, t)) if res[1] \u0026lt; t: res = (n, t) return res a = bfs(1) b = bfs(a[0]) print(b[1]) 💾 느낀점 BFS를 응용하여 푸는 문제였다. 두번이나 돌릴 생각을 못해서 헤맸다. 문제를 해석하고 압축하는 능력을 더 키우고, 생각의 전환을 하는 습관을 길러야겠다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-1967-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84-with-python/","summary":"📌 BOJ 1967 트리의 지름 💡 조건 및 풀이 노드의 개수 (1 ≤ n ≤ 10,000) 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호\n두 번째 정수는 자식 노드\n세 번째 정수는 간선의 가중치 부모 노드의 번호가 작은 것이 먼저 입력되고,\n부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. BFS 유형의 문제 루트 노드의 번호는 항상 1\n간선의 가중치는 100보다 크지 않은 양의 정수 트리에 존재하는 모든 경로들 중, 가장 긴 경로를 출력하는 문제이다.","title":"[BOJ] 1967 트리의 지름 with Python"},{"content":"\n📌 BOJ 13305 주유소 💡 조건 및 풀이 도시의 개수 2 \u0026lt;= N \u0026lt;= 100000 도시를 연결하는 간선의 길이가 N-1개 주어진다. 그리디 알고리즘 유형 문제 제일 왼쪽에서 오른쪽으로 이동하는 최소 비용을 계산 어느 도시에서 기름을 넣어 이동하는 것이 가장 비용이 저렴한지에 대해 계산하면 된다. 서브태스크 점수가 주어진다 17점 모든 주유소의 리터당 가격은 1원 41점 2 \u0026lt;= N \u0026lt;= 1000\n제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 최대 10000,\n리터 당 가격은 최대 10000 42점 원래의 제약조건 이외에 아무 제약조건이 없다. 🔖 예제 및 실행결과 예제 4 2 3 1 5 2 4 1 실행결과 18 ⌨️ 문제 풀이 도로의 길이를 저장할 리스트 dist\n주유소의 리터당 가격을 저장할 리스트 cost 가장 왼쪽에 있는 도시의 주유소의 리터당 가격을 변수 c 에 넣어준다. k-1 반복문을 실행하여 주유소의 리터 당 가격을 순회한다. 만약 현재 계산된 c 가 i 번째 리터 당 가격보다 비싸다면 c 를 갱신한다.\n그게 아니라면, 결과값을 저장할 res에 리터 당 가격 * i번째 도로의 길이를 더해준다 🖥 소스 코드 from sys import stdin k = int(stdin.readline()) dist = list(map(int, stdin.readline().split())) cost = list(map(int, stdin.readline().split())) res = 0 c = cost[0] for i in range(k - 1): if c \u0026gt; cost[i]: c = cost[i] res += c * dist[i] print(res) 💾 느낀점 그리디 문제라고해서 얕봤다가 로직이 한순간 꼬여서 고생을 좀 했다. 리스트를 따로 처리해 사용하다가 머리가 순간 복잡해지는 것을 방지하기 위해 노력을 해야겠다. 그림을 그려 차분히 로직을 생각하고 구현하는 습관을 길러야겠다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-13305-%EC%A3%BC%EC%9C%A0%EC%86%8C-with-python/","summary":"📌 BOJ 13305 주유소 💡 조건 및 풀이 도시의 개수 2 \u0026lt;= N \u0026lt;= 100000 도시를 연결하는 간선의 길이가 N-1개 주어진다. 그리디 알고리즘 유형 문제 제일 왼쪽에서 오른쪽으로 이동하는 최소 비용을 계산 어느 도시에서 기름을 넣어 이동하는 것이 가장 비용이 저렴한지에 대해 계산하면 된다. 서브태스크 점수가 주어진다 17점 모든 주유소의 리터당 가격은 1원 41점 2 \u0026lt;= N \u0026lt;= 1000\n제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 최대 10000,\n리터 당 가격은 최대 10000 42점 원래의 제약조건 이외에 아무 제약조건이 없다.","title":"[BOJ] 13305 주유소 with Python"},{"content":"\n📌 BOJ 6987 월드컵 💡 조건 및 풀이 6개의 국가가 있고, 총 18번의 경기를 한다. 승, 무, 패의 결과가 있으며, 승, 무, 패의 수는 6보다 작거나 같은 자연수 또는 0 백트래킹 유형의 문제 입력은 네 줄로 들어오며, 각 줄에 대해 가능한 결과 1, 불가능한 결과 0 을출력하는 문제이다 🔖 예제 및 실행결과 예제 5 0 0 3 0 2 2 0 3 0 0 5 4 0 1 1 0 4 4 1 0 3 0 2 4 1 0 1 1 3 0 0 5 1 1 3 5 0 0 4 0 1 2 2 1 2 0 3 1 0 4 0 0 5 5 0 0 3 1 1 2 1 2 2 0 3 0 0 5 1 0 4 실행결과 1 1 0 0 ⌨️ 문제 풀이 data 변수에 각 나라의 일정을 담고, res 베열에 3개씩 쪼개어 다시 넣는다. 결과를 담을 ans 변수를 0으로 초기화 시킨다. 팀끼리의 경기의 조합을 위해 itertools의 combinations를 사용.\ngame이라는 변수에 0~5번의 국가가 경기를 할 수 있는 조합을 만들어 저장한다. solution 함수에서 총 라운드를 파라미터로 입력받으며, 초기의 값은 0이다. 각 라운드를 순회하면서 res 배열의 값을 빼주면서 승, 무, 패 의 값이 남아있다면\nans = 0으로 초기화해서 불가능한 경기라고 answer 리스트에 저장하면 된다. 승에 해당하는 원소를 -1 할 때, 패에 해당하는 원소를 -1 해준다.\n무에 해당하는 원소를 -1 할 때, 무에 해당하는 다른 원소를 -1 해준다. round 값이 15라운드가 되었다면 ans의 값을 1로 변경하고 검사를 시작한다.\nres 변수에 있는 0의 값이 3개가 아니라면 ans 를 0으로 변경 🖥 소스 코드 from sys import stdin from itertools import combinations as cb def solution(round): global ans if round == 15: ans = 1 for sub in res: if sub.count(0) != 3: ans = 0 break return t1, t2 = game[round] for x, y in ((0, 2), (1, 1), (2, 0)): if res[t1][x] \u0026gt; 0 and res[t2][y] \u0026gt; 0: res[t1][x] -= 1 res[t2][y] -= 1 solution(round + 1) res[t1][x] += 1 res[t2][y] += 1 answer = [] game = list(cb(range(6), 2)) # 백트래킹 for _ in range(4): data = list(map(int, stdin.readline().split())) res = [data[i:i + 3] for i in range(0, 16, 3)] ans = 0 solution(0) answer.append(ans) print(*answer) 💾 느낀점 백트래킹을 위해 재귀함수를 구현하여 조건을 풀어내는 일련의 과정이 힘겹다.\n조금 더 백트래킹 및 재귀에 관한 문제를 풀어보아야겠다. 문제를 조금 더 내가 스스로도 납득하고 이해할 수 있게 풀어내는 방법을 생각해봐야겠다. 문제 및 로직에 대해 생각하는 시간이 너무 짧고, 문제를 풀기 위해 손부터 나가는 나쁜 습관을 고쳐야겠다. 아이디어를 떠올리지 못해 고생을 많이 했던 문제인 것 같다.\n블로그에 글을 포스팅하면서 다시 한 번 정리하니 도움이 되는 것 같다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-6987-%EC%9B%94%EB%93%9C%EC%BB%B5-with-python/","summary":"📌 BOJ 6987 월드컵 💡 조건 및 풀이 6개의 국가가 있고, 총 18번의 경기를 한다. 승, 무, 패의 결과가 있으며, 승, 무, 패의 수는 6보다 작거나 같은 자연수 또는 0 백트래킹 유형의 문제 입력은 네 줄로 들어오며, 각 줄에 대해 가능한 결과 1, 불가능한 결과 0 을출력하는 문제이다 🔖 예제 및 실행결과 예제 5 0 0 3 0 2 2 0 3 0 0 5 4 0 1 1 0 4 4 1 0 3 0 2 4 1 0 1 1 3 0 0 5 1 1 3 5 0 0 4 0 1 2 2 1 2 0 3 1 0 4 0 0 5 5 0 0 3 1 1 2 1 2 2 0 3 0 0 5 1 0 4 실행결과 1 1 0 0 ⌨️ 문제 풀이 data 변수에 각 나라의 일정을 담고, res 베열에 3개씩 쪼개어 다시 넣는다.","title":"[BOJ] 6987 월드컵 with Python"},{"content":"\n📌 BOJ 16507 어두운 건 무서워 💡 조건 및 풀이 사진 크기를 의미하는 1 \u0026lt;= R, C \u0026lt;= 1000 사진 일부분의 밝기 평균을 알아볼 개수 Q Q개의 각 줄에는 사진의 일부분을 나타내기 위한 두 꼭짓점을 의미하는 정수 r1, c1, r2, c2 가 주어진다.\n(1 ≤ r1 ≤ r2 ≤ R, 1 ≤ c1 ≤ c2 ≤ C) 누적합 문제 Q개의 각 줄에 주어진 사진에서 두 점 (r1, c1)과 (r2, c2)를 꼭짓점으로 하는 직사각형의 밝기 평균을 출력한다. 평균은 정수 나눗셈으로 몫만 취한다. 🔖 예제 및 실행결과 예제 5 6 1 4 1 3 4 9 5 1 2 8 7 5 5 8 1 2 5 3 2 1 5 3 4 2 5 5 2 1 2 3 5 2 2 4 5 실행결과 3 ⌨️ 문제 풀이 누적합 문제다.\n꼭지점을 의미하는 정수가 1부터 시작되기에 인덱스 에러를 조심해야한다.\n그래서 나는 (R + 1) * (C + 1) 크기릐 배열을 만들어 코드도 단순화 시켰다.\n입력 받은 R * C 크기의 데이터를 배열에 넣고 누적합을 구해 배열에 넣어준다.\n꼭지점 좌표를 입력받아 x좌표의 크기를 오픔차순으로 정렬시켰다.\n가장 왼쪽에 위치하고 있는 좌표를 찾으려고 했다.\n직사각형의 크기를 알아야 누적합을 이용해 찾은 밝기의 합도 나눌 수 있다.\n그래서 정렬 시킨 좌표를 사용해 직사각형의 크기를 계산했다.\n(abs(addr[0][0]-addr[1][0]) + 1) * (abs(addr[0][1]-addr[1][1]) + 1) 배열의 각 가로줄마다 따로 계산을 해주었다.\n누적합의 성질은 예를 들자면 다음과 같다.\n[4, 5, 8, 12, 21, 26] 의 배열이 있을 때, 배열의 두번째 원소부터 네번째 원소의 합을 구하려고한다.\n그렇다면 네번째 원소에서 첫번째 원소의 값을 빼주면 구하려는 값이 된다.\n🖥 소스 코드 from sys import stdin r, c, q = map(int, stdin.readline().split()) pic = [[0] * (c + 1)] for i in range(r): sum_list = [0] data = list(map(int, stdin.readline().split())) sum_list.append(data[0]) for i in range(1, c): sum_list.append(sum_list[-1] + data[i]) pic.append(sum_list) for _ in range(q): a, b, c, d = map(int, stdin.readline().split()) addr = [(a, b), (c, d)] addr.sort(key=lambda x: x[0]) res = 0 knife = (abs(addr[0][0]-addr[1][0]) + 1) * (abs(addr[0][1]-addr[1][1]) + 1) for i in range(addr[0][0], addr[1][0] + 1): res += pic[i][addr[1][1]] - pic[i][addr[0][1] - 1] print(res // knife) 💾 느낀점 누적합의 개념과 원리, 성질을 아르바이트 출근하면서 지하철에서 본 것이 큰 도움이 되었다. 인덱스 에러가 쉽게 발생할 수 있을 것 같다는 생각이 들어 다른 풀이도 생각해보았지만 큰 도움은 되지 않았다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-16507-%EC%96%B4%EB%91%90%EC%9A%B4-%EA%B1%B4-%EB%AC%B4%EC%84%9C%EC%9B%8C-with-python/","summary":"📌 BOJ 16507 어두운 건 무서워 💡 조건 및 풀이 사진 크기를 의미하는 1 \u0026lt;= R, C \u0026lt;= 1000 사진 일부분의 밝기 평균을 알아볼 개수 Q Q개의 각 줄에는 사진의 일부분을 나타내기 위한 두 꼭짓점을 의미하는 정수 r1, c1, r2, c2 가 주어진다.\n(1 ≤ r1 ≤ r2 ≤ R, 1 ≤ c1 ≤ c2 ≤ C) 누적합 문제 Q개의 각 줄에 주어진 사진에서 두 점 (r1, c1)과 (r2, c2)를 꼭짓점으로 하는 직사각형의 밝기 평균을 출력한다.","title":"[BOJ] 16507 어두운 건 무서워 with Python"},{"content":"\n📌 BOJ 17521 Byte Coin 💡 조건 및 풀이 주식 시장에서 단타를 치는 국제자본 부동산 회사를 도와 최고의 수익을 내는 문제. 일 수를 나타내는 1 \u0026lt;= n \u0026lt;= 15 초기 현금을 나타내는 W 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는\n정수 si가 주어진다(1 ≤ si ≤ 50). 단순 구현, 그리디 알고리즘 문제 🔖 예제 및 실행결과 예제 10 24 5 7 5 4 2 7 8 5 3 4 실행결과 170 ⌨️ 문제 풀이 현재 매수한 코인이 있는지의 상태를 체크할 수 있는 변수 \u0026quot;m\u0026quot; (기본값은 False)\n코인을 몇개 샀는지에 대한 정보를 넣어줄 변수 \u0026quot;coin\u0026quot; 코인이 다음 날에 가격이 상승하거나 변동이 없다?\n이미 매수한 경우, pass\n매수하지 않은 경우, 구매 코인이 다음 날에 가격이 떨어진다?\n판매 최종적으로 남아 있는 현금을 출력 🖥 소스 코드 from sys import stdin n, w = map(int, stdin.readline().split()) arr = [] for _ in range(n): arr.append(int(stdin.readline())) m = False coin = 0 for i in range(n - 1): if not m and arr[i] \u0026lt; arr[i + 1]: m = arr[i] coin = w // m w -= coin * m elif m and arr[i] \u0026gt; arr[i + 1]: w += arr[i] * coin coin, m = 0, False if m: w += coin * arr[-1] print(w) 💾 느낀점 단순 구현 및 그리디 문제였습니다. 코인을 샀는지 안샀는지에 대한 변수를 추가하여 쉽게 풀 수 있었습니다. 실제 코인 시장이나 은행처럼 x% 수익률 계산했다가 큰 코 다칠뻔했습니다. 문제를 더 확실히 읽고 압축하는 능력을 키워야겠습니다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-17521-byte-coin-with-python/","summary":"📌 BOJ 17521 Byte Coin 💡 조건 및 풀이 주식 시장에서 단타를 치는 국제자본 부동산 회사를 도와 최고의 수익을 내는 문제. 일 수를 나타내는 1 \u0026lt;= n \u0026lt;= 15 초기 현금을 나타내는 W 다음 n 개의 줄에서, i번째 줄은 i일의 바이트 코인 가격을 나타내는\n정수 si가 주어진다(1 ≤ si ≤ 50). 단순 구현, 그리디 알고리즘 문제 🔖 예제 및 실행결과 예제 10 24 5 7 5 4 2 7 8 5 3 4 실행결과 170 ⌨️ 문제 풀이 현재 매수한 코인이 있는지의 상태를 체크할 수 있는 변수 \u0026quot;m\u0026quot; (기본값은 False)","title":"[BOJ] 17521 Byte Coin with Python"},{"content":"\n📌 BOJ 9934 완전 이진 트리 💡 조건 및 풀이 이진 트리의 깊이를 나타내는 1\u0026lt;=K\u0026lt;=10, 깊이가 K인 이진 트리는 총 2 * K - 1 개의 노드로 이루어져 있다. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다. 이분탐색, 트리, 재귀구현 문제 모든 빌딩의 번호는 중복되지 않는다. 🔖 예제 및 실행결과 예제 3 1 6 4 3 5 2 7 실행결과 3 6 2 1 4 5 7 ⌨️ 문제 풀이 깊이가 k 인 2차원 리스트 res 를 생성하고, 이 리스트에 노드를 쌓을 것입니다. Python 리스트 자료구조의 extend() 함수를 사용했습니다.\nextend는 리스트를 리스트 안으로 넣을 때 리스트의 원소만 넣어줍니다. 입력받은 빌딩번호의 길이를 2로 나누어 값을 mid 변수에 넣어 가지고 있습니다. res에 파라미터로 받은 depth 값을 넣어줍니다.\n가장 맨 처음으로 이분탐색을 통해 뽑아낸 가운데 값이 루트 노드입니다. 가운데 값을 기준으로 양쪽을 분리해 각각 다시 이분탐색을 수행합니다. 이분 탐색을 하다가, 파라미터로 받은 arr 리스트의 길이가 1인 경우 depth 에 해당하는\n리스트에 넣어줍니다. 만들어진 트리(res)를 출력해줍니다. 파이썬으로 재귀를 구현할 때,아래의 함수를 사용해야 에러가 나지 않는 경우가 많습니다.\n쓴다고 문제될 것이 없으니, 재귀를 구현하여 문제를 푸실 때 꼭 입력하세요.\nsetrecursionlimit(int(1e9))​ 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(int(1e9)) k = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) res = [[] for _ in range(k)] def binary_separation(arr, depth): if len(arr) == 1: res[depth].extend(arr) return length = len(arr) mid = length // 2 res[depth].append(arr[mid]) binary_separation(arr[:mid], depth + 1) binary_separation(arr[mid + 1:], depth + 1) binary_separation(arr, 0) for i in range(k): if i == 0: print(res[i][0]) else: print(*res[i]) 💾 느낀점 이분탐색과 재귀를 사용하여 문제를 푸는 방식에 익숙해진 것을 느꼈다. 분할 정복 문제를 풀다가 이 문제를 푸니 훨씬 도움이 되었다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-9934-%EC%99%84%EC%A0%84-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-with-python/","summary":"📌 BOJ 9934 완전 이진 트리 💡 조건 및 풀이 이진 트리의 깊이를 나타내는 1\u0026lt;=K\u0026lt;=10, 깊이가 K인 이진 트리는 총 2 * K - 1 개의 노드로 이루어져 있다. 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다. 이분탐색, 트리, 재귀구현 문제 모든 빌딩의 번호는 중복되지 않는다. 🔖 예제 및 실행결과 예제 3 1 6 4 3 5 2 7 실행결과 3 6 2 1 4 5 7 ⌨️ 문제 풀이 깊이가 k 인 2차원 리스트 res 를 생성하고, 이 리스트에 노드를 쌓을 것입니다.","title":"[BOJ] 9934 완전 이진 트리 with Python"},{"content":"\n📌 Programmers - 문자열 압축 💡 조건 및 풀이 입력 받는 의 길이는 1 \u0026lt;= s \u0026lt;= 1000, 소문자로만 이루어져 있다. 문자열을 1개 단위로 자르는 것부터 s의 길이 만큼 자르는 것까지 계산 완전탐색, 구현 문제 문자열을 자르고 숫자를 붙이는 것에서 쓸데 없는 문자가 들어가지 않도록 주의 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;aabbaccc\u0026#34;)) print(solution(\u0026#34;ababcdcdababcdcd\u0026#34;)) print(solution(\u0026#34;abcabcdede\u0026#34;)) print(solution(\u0026#34;abcabcabcabcdededededede\u0026#34;)) print(solution(\u0026#34;xababcdcdababcdcd\u0026#34;)) 실행결과 7 9 8 14 17 ⌨️ 문제 풀이 answer의 값을 s의 길이로 초기화.\ns의 길이만큼 자른것이 가장 짧을 수 있기 때문에 s의 길이로 초기화한다. 1개부터 s의 길이만큼 잘라주면서 진행을 할 것이기 때문에 1부터 s+1 까지 반복문을 진행 자른 문자열은 이미 1개만큼 잘랐기 때문에 cnt = 1 로 초기화 자른 문자열과 같은 문자열이 진행하면서 있을 경우, cnt += 1 자른 문자열과 다른 문자열이 발견되었을 경우, 검사할 문자를 교체한다\n지금까지 검사해주던 단어와 늘려온 cnt를 std에 넣어주고 다시 검사 진행. 검사가 끝난 뒤, std의 길이가 기존의 answer 보다 작다면 갱신. 🖥 소스 코드 def solution(s): k = len(s) answer = k for idx in range(1, k + 1): std = \u0026#39;\u0026#39; checker = s[0: idx] std += checker start, end = 0, idx cnt = 1 for i in range(idx, k + 1, idx): if i == k: if cnt \u0026lt;= 1: break else: std += str(cnt) break if checker == s[start + i:end + i]: cnt += 1 elif cnt \u0026lt;= 1: std += s[start + i:end + i] checker = s[start + i:end + i] continue else: std += str(cnt) cnt = 1 std += s[start + i:end + i] checker = s[start + i:end + i] answer = min(answer, len(std)) return answer 💾 느낀점 나는 구현이 매우 약하기 때문에 연습하기 굉장히 좋은 문제였던 것 같다. ","permalink":"https://jxun-h.github.io/posts/temp/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-with-python/","summary":"📌 Programmers - 문자열 압축 💡 조건 및 풀이 입력 받는 의 길이는 1 \u0026lt;= s \u0026lt;= 1000, 소문자로만 이루어져 있다. 문자열을 1개 단위로 자르는 것부터 s의 길이 만큼 자르는 것까지 계산 완전탐색, 구현 문제 문자열을 자르고 숫자를 붙이는 것에서 쓸데 없는 문자가 들어가지 않도록 주의 🔖 예제 및 실행결과 예제 print(solution(\u0026#34;aabbaccc\u0026#34;)) print(solution(\u0026#34;ababcdcdababcdcd\u0026#34;)) print(solution(\u0026#34;abcabcdede\u0026#34;)) print(solution(\u0026#34;abcabcabcabcdededededede\u0026#34;)) print(solution(\u0026#34;xababcdcdababcdcd\u0026#34;)) 실행결과 7 9 8 14 17 ⌨️ 문제 풀이 answer의 값을 s의 길이로 초기화.","title":"[Programmers] 문자열 압축 with Python"},{"content":"\n📌 BOJ 2458 키 순서 💡 조건 및 풀이 1번부터 N번까지 번호가 붙여져 있는 학생들끼리 두 명씩 키를 비교했다. N명의 학생들은 모두 키가 다르다. 플로이드와샬 알고리즘으로 해결이 가능한 문제이다. 2 \u0026lt;= N \u0026lt;= 500, 0 \u0026lt;= M \u0026lt;= N(N-1)/2 M개의 줄에 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a, b가 주어진다. a, b == a가 b보다 작다 자신의 키가 몇번째인지 알 수 있는 학생의 수를 구하는 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) inf = int(1e9) graph = [[inf] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) graph[b][a] = 1 for i in range(1, n + 1): for j in range(1, n + 1): for k in range(1, n + 1): if j == k: graph[j][k] = 0 continue if graph[j][k] \u0026gt; graph[j][i] + graph[i][k]: graph[j][k] = graph[j][i] + graph[i][k] res = n for i in range(1, n + 1): checker = 1 for j in range(1, n + 1): if graph[i][j] == inf and graph[j][i] == inf: res -= 1 checker = 0 if not checker: break print(res) 🔖 예제 및 실행결과 예제 6 7 1 3 1 5 3 4 5 4 4 2 4 6 5 2 실행결과 2 ⌨️ 문제 풀이 최소 거리를 정해준다고 생각하고 플로이드 와샬을 사용하기 위해 2차원 리스트를 만들고\nINF 값을 넣어 리스트를 초기화했다. a, b 값을 입력받게 되면 a 가 b 보다 작다 라는 조건에 따라, 2차원 리스트에 graph[b].append(a) 플로이드 와샬 알고리즘 실행 자신의 키가 몇등인지 알 수있는 사람을 처음부터 N명이라고 정의한 뒤 1번 학생부터 순차적으로\n2중 반복문을 사용해 플로이드 와샬로 만든 2차원 리스트에 접근 if graph[i][j] == inf and graph[j][i] == inf:\ni번 학생이 j번 학생과의 작다, 크다의 정보가 아무것도 없다면 res -= 1 2중 반복문을 빠져나오기 위한 checker변수에 0을 넣어주고(False) 반복문 탈출 PyPy3 제출 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.readline().split()) inf = int(1e9) graph = [[inf] * (n + 1) for _ in range(n + 1)] for _ in range(m): a, b = map(int, stdin.readline().split()) graph[b][a] = 1 for i in range(1, n + 1): for j in range(1, n + 1): for k in range(1, n + 1): if j == k: graph[j][k] = 0 continue if graph[j][k] \u0026gt; graph[j][i] + graph[i][k]: graph[j][k] = graph[j][i] + graph[i][k] res = n for i in range(1, n + 1): checker = 1 for j in range(1, n + 1): if graph[i][j] == inf and graph[j][i] == inf: res -= 1 checker = 0 if not checker: break print(res) 💾 느낀점 문제를 보자마자 플로이드와샬 알고리즘과 유니온-파인드가 생각났다.\n유니온-파인드로 구현을 하려다보니 절대 아닌 것 같아 플로이드와샬을 사용하기로 했다. 아는 분들의 이야기를 들어보니 BFS로 구현하셨다고 했다. 플로이드 와샬 알고리즘으로 해결했을 때, Python3 로 시간초과가 생겼으며, PyPy3 는 통과 BFS로 풀이하는 방법도 구현해봐야겠다. 문제를 풀시간은 없는데 생각할 시간이 너무 길다. 아직 숙달이 되지 못한 것이라고 생각하고 더 풀어봐야겠다. ","permalink":"https://jxun-h.github.io/posts/temp/boj-2458-%ED%82%A4-%EC%88%9C%EC%84%9C-with-python-feat.-pypy3/","summary":"📌 BOJ 2458 키 순서 💡 조건 및 풀이 1번부터 N번까지 번호가 붙여져 있는 학생들끼리 두 명씩 키를 비교했다. N명의 학생들은 모두 키가 다르다. 플로이드와샬 알고리즘으로 해결이 가능한 문제이다. 2 \u0026lt;= N \u0026lt;= 500, 0 \u0026lt;= M \u0026lt;= N(N-1)/2 M개의 줄에 두 학생의 키를 비교한 결과를 나타내는 두 양의 정수 a, b가 주어진다. a, b == a가 b보다 작다 자신의 키가 몇번째인지 알 수 있는 학생의 수를 구하는 문제 🖥 소스 코드 from sys import stdin n, m = map(int, stdin.","title":"[BOJ] 2458 키 순서 with Python (Feat. PyPy3)"},{"content":"\n📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,\n입력받은 N이 비어있는 문자열 ''이면 break 입력받은 N이 0, -의 개수가 1이라면 print('-') (N ** 3) * '-' == 하이픈의 개수 만들어진 하이픈을 분할 정복 함수에 넣는다.\n각 파라미터는 3 ** N개의 하이픈과 인덱스 번호이다. 인덱스 번호는 세등분이 된 문자열의 각 인덱스 번호이며, 재귀를 통해 인덱스 번호가 1인\n문자열을 공백으로 만들어주면 된다. 문자열은 파라미터로 받은 문자열 길이를 3으로 나누어\n그 길이만큼 리스트를 슬라이싱해 arr 리스트에 넣는다. 반환 조건은 아래의 두가지로 만들었다. 문자열의 길이가 3이고 인덱스 번호가 1이 아닐 때에는 \u0026lsquo;- -\u0026lsquo;을 리턴 문자열의 길이가 3보다 같거나 크며, 인덱스 번호가 1일 때는 문자열의 길이만큼 공백을 반환 🖥 소스 코드 from sys import stdin, setrecursionlimit setrecursionlimit(10 ** 6) def div(s, idx): ls = len(s) if ls == 3 and idx != 1: return \u0026#39;- -\u0026#39; elif ls \u0026gt;= 3 and idx == 1: return s.replace(\u0026#39;-\u0026#39;, \u0026#39; \u0026#39;) arr = [] for i in range(0, ls, ls // 3): arr.append(string[i:i+ls//3]) k = div(arr[0], 0) + div(arr[1], 1) + div(arr[2], 2) return k while 1: k = \u0026#39;-\u0026#39; n = stdin.readline().rstrip() if n == \u0026#39;\u0026#39;: break num = (3 ** int(n)) if num == 1: print(\u0026#39;-\u0026#39;) continue string = k * num arr = div(string, 0) print(arr) 💾 느낀점 분할 정복을 사용하기로 하고 인덱스를 같이 파라미터 값으로 넣자고 생각했다.\n좋은 아이디어가 한번에 떠올라서 매우 좋았다. 성공적인 풀이였다. 재귀 사용 실력이 최악이라 사용자체가 많이 힘들었지만\n예전보다는 사용하기 매우 수월해졌다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4779-%EC%B9%B8%ED%86%A0%EC%96%B4-%EC%A7%91%ED%95%A9-with-python/","summary":"📌 BOJ 4779 칸토어 집합 💡 조건 및 풀이 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합.\n구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다. -가 3N개 있는 문열에서 시작 == - 의 개수는 3 ** N 개 분할 정복 + 재귀 유형의 문제 0 \u0026lt;= N \u0026lt;= 12 파일의 끝에서 입력을 멈춘다 🔖 예제 및 실행결과 예제 0 1 3 2 실행결과 - - - - - - - - - - - - - - - ⌨️ 문제 풀이 칸토어 집합은 각 구간을 3등분, 반복적으로 가운데 구간을 제외하는 방식 파일의 끝에서 입력을 멈춘다 라는 말은 무한루프를 돌다가,","title":"[BOJ] 4779 칸토어 집합 with Python"},{"content":"\n📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 \u0026lt;= N \u0026lt;= 10 각 카드에 숫자가 적혀있다. 1 \u0026lt;= 숫자 \u0026lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions\npermutations라는 순열 함수를 사용했다.\n리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다. 리스트에는 같은 숫자도 존재하며, 충분히 순열로 리스트를 만들었을 때, 중복이 존재한다. 결과를 반환할 set() 자료구조를 만든 후 for 문을 사용해서 순열리스트에 차례대로 접근하면서, 문자열로 만들어주면서 합친다. 합쳐진 문자열을 set() 자료구조로 만든 변수에 추가한다. 중복으로 추가가 되지 않는다 set() 변수의 길이를 재서 출력. 🖥 소스 코드 from sys import stdin from itertools import permutations as p arr = [] n, k = int(stdin.readline()), int(stdin.readline()) for i in range(n): arr.append(int(stdin.readline())) res = set() for i in list(p(arr, k)): res.add(\u0026#39;\u0026#39;.join(list(map(str, i)))) print(len(res)) 💾 느낀점 처음엔, 순열 리스트로만 만들어서 길이를 쟀다. -\u0026gt; TLE 순열 리스트에 순차적으로 접근해서 문자열로 만들어 조합을 본 뒤\n풀어나가는 아이디어, set() 자료구조를 사용할 아이디어를 떠올린 뒤\n바로 풀었다. 비교적 실버 문제가 쉽고 개념을 쌓기에 좋은 문제들이 많은 것 같다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-5568-%EC%B9%B4%EB%93%9C-%EB%86%93%EA%B8%B0-with-python/","summary":"📌 BOJ 5568 카드 놓기 💡 조건 및 풀이 카드의 장수는 4 \u0026lt;= N \u0026lt;= 10 각 카드에 숫자가 적혀있다. 1 \u0026lt;= 숫자 \u0026lt;= 99 N개의 카드 중에서 K개의 카드를 골라서 몇 가지 수를 만들 수 있을까? 브루트포스 유형의 문제 🔖 예제 및 실행결과 예제 6 3 72 2 12 7 2 1 실행결과 68 ⌨️ 문제 풀이 from itertools import permutaions\npermutations라는 순열 함수를 사용했다.\n리스트와 값을 넣으면 리스트에서 그만큼의 개수대로 숫자를 꺼낸다.","title":"[BOJ] 5568 카드 놓기 with Python"},{"content":"\n📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다. - dict 이름만 저장하는 리스트를 사용한다 - list 문자열로 입력이 들어왔을 때, dict 자료형에서 매핑된 번호를 꺼낸다. 숫자로 입력이 들어왔을 때, list 자료형에서 매핑된 이름을 꺼낸다. 🖥 소스 코드 import sys n, m = map(int, sys.stdin.readline().split()) pokemon = {} pokemon_nm = [] for i in range(n): nm = sys.stdin.readline().rstrip() pokemon[nm] = i pokemon_nm.append(nm) for _ in range(m): c = sys.stdin.readline().rstrip() if c.isnumeric(): print(pokemon_nm[int(c) - 1]) else: print(pokemon[c] + 1) 💾 느낀점 key - value 로 매핑되는 dict 자료형으로 구현하기로 결정했는데,\n문제를 보고 바로 떠올린 것에 대해서 큰 뿌듯함이 들었다. 문제를 쉽게 풀어서 그런지, 기분좋은 공부의 시작이 되었다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-1620-%EB%82%98%EB%8A%94%EC%95%BC-%ED%8F%AC%EC%BC%93%EB%AA%AC-%EB%A7%88%EC%8A%A4%ED%84%B0-%EC%9D%B4%EB%8B%A4%EC%86%9C-with-python/","summary":"📌 BOJ 1620 나는야 포켓몬 마스터 이다솜 💡 조건 및 풀이 도감에 수록되어 있는 포켓몬의 수 N, 맞추어야할 문제의 개수 M 범위는 1 \u0026lt;= N, M \u0026lt;= 100000 이다. 자료구조를 이용하는 문제 문자열로 입력이 들어오면 도감에 수록된 포켓몬의 번호를 출력한다. 숫자로 입력이 들어오면 도감에 수록된 포켓몬의 이름을 출력한다. 🔖 예제 및 실행결과 예제 26 5 Bulbasaur Ivysaur Venusaur Charmander Charmeleon Charizard Squirtle Wartortle Blastoise Caterpie Metapod Butterfree Weedle Kakuna Beedrill Pidgey Pidgeotto Pidgeot Rattata Raticate Spearow Fearow Ekans Arbok Pikachu Raichu 25 Raichu 3 Pidgey Kakuna 실행결과 Pikachu 26 Venusaur 16 14 ⌨️ 문제 풀이 key - value 로 매핑되는 자료구조를 사용한다.","title":"[BOJ] 1620 나는야 포켓몬 마스터 이다솜 with Python"},{"content":"\n📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다. 단방향 간선이기 때문에 graph[a].append(b) bfs(x)에서 사용하는 방문처리용 자료구조를 list가 아닌 set으로 사용했다. queue에는 현재 노드와 비용에 대해서 튜플로 만들어 넣어준다.\n단, 이미 방문했던 노드는 다시 방문하지 않는다. = visited 🖥 소스 코드 from sys import stdin from collections import deque n, m, k, x = map(int, stdin.readline().split()) graph = [[] for _ in range(n + 1)] for i in range(m): a, b = map(int, stdin.readline().split()) graph[a].append(b) def bfs(x): res = [] visited = set() q = deque() q.append((x, 0)) visited.add(x) while q: now, cost = q.popleft() if cost == k: res.append(now) for i in graph[now]: if i not in visited: q.append((i, cost + 1)) visited.add(i) if not res: print(-1) else: res.sort() for i in res: print(i) bfs(x) 💾 느낀점 다익스트라, BFS 문제의 유형은 더 많이 풀어봐야겠다. 개념이 조금 익혀져 있는 다익스트라 기본 문제를 풀어서 쉽게 풀 수 있었다. 플로이드 와샬로는 시도해보지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-18352-%ED%8A%B9%EC%A0%95-%EA%B1%B0%EB%A6%AC%EC%9D%98-%EB%8F%84%EC%8B%9C-%EC%B0%BE%EA%B8%B0-with-python/","summary":"📌 BOJ 18352 특정 거리의 도시 찾기 💡 조건 및 풀이 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재. 모든 도로의 거리는 1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력. BFS 유형의 문제 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력 🔖 예제 및 실행결과 예제 4 4 2 1 1 2 1 3 2 3 2 4 실행결과 4 ⌨️ 문제 풀이 모든 도시가 1부터 시작하기 때문에 graph 리스트의 길이를 n + 1로 한다.","title":"[BOJ] 18352 특정 거리의 도시 찾기 with Python"},{"content":"\n📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용. list로 받은 수열을 sort()로 정렬. 정렬된 리스트에 대해 0번 인덱스부터 순차적으로 접근하며\nbisect_left, bisect_right 함수를 사용해 반환받은 값(l, r)을 비교한다. 수열의 총 개수(n)보다 bisect_left 로 반환받은 값(l)이 작을 때만 실행한다. 현재 수열의 i번째 숫자와 수열의 l번째 숫자가 같지 않으며, r과 l이 같지 않을 때 cnt += 1 따로 for문의 범위를 지정해주지 않으면, 정답에 해당하는 (A[i], A[j]) 쌍이\n두번이 나오기 때문에 cnt // 2를 해준다. 🖥 소스 코드 from sys import stdin from bisect import bisect_right, bisect_left n = int(stdin.readline()) arr = list(map(int, stdin.readline().split())) arr.sort() x = int(stdin.readline()) cnt = 0 for i in range(n): l, r = bisect_left(arr, x - arr[i]), bisect_right(arr, x - arr[i]) if l \u0026lt; n: if arr[i] != arr[l] and l != r: cnt += 1 print(cnt // 2) 💾 느낀점 n을 순차적으로 접근할 for문의 범위를 잘못 지정해주어서 틀렸었다. bisect 라이브러리를 사용해 찾으려고 하는 숫자의 인덱스 번호를 잘못 계산해서 틀렸었다. 이분탐색 문제를 더 많이 풀어보고, 다양한 유형을 경험해보아야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-3273-%EB%91%90-%EC%88%98%EC%9D%98-%ED%95%A9-with-python/","summary":"📌 BOJ 3273 두 수의 합 💡 조건 및 풀이 n개의 서로 다른 정수로 이루어진 수열 A가 있다. 1 \u0026lt;= A[i] \u0026lt;= 1000000 n의 크기는 1 \u0026lt;= n \u0026lt;= 100000 x의 크기는 1 \u0026lt;= x \u0026lt;= 2000000 sort + binary search 유형의 문제 자연수 x가 주어졌을 때, A[i] + A[j] = x 를 만족하는 쌍의 수를 구한다.\n(A[i], A[j]) 🔖 예제 및 실행결과 예제 9 5 12 7 10 9 1 2 3 11 13 실행결과 3 ⌨️ 문제 풀이 Python 언어의 배열 이진 분할 알고리즘을 사용할 수 있는 bisect 사용.","title":"[BOJ] 3273 두 수의 합 with Python"},{"content":"\n📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ⌨️ 문제 풀이 편한 계산을 위해 dp를 n + 1의 크기만큼 생성했다. 상담을 하는데 필요한 시간을 담을 리스트 T를 생성 상담을 하면 얻을 수 있는 이익을 담을 리스트 P를 생성 1일째부터 상담을 진행하면 얻을 수 있는 이익을 DP 리스트에 최댓값으로 갱신 상담을 시작한 날의 이익의 데이터가 DP 리스트의 상담이 끝나는 날 위치에 들어감 i번째 날에 상담을 시작했으면, i + t[i] 가 n을 넘지 말아야한다.\n즉, 7(N)일 남은 퇴사 예정자가 퇴사 하루 전 날(i = 7)에\nT[i] 2일 걸릴 상담을 시작하면, 끝내지 못하기에(N \u0026lt; Ti + i) 이익을 취할 수 없다. k 라는 변수를 만들어, dp[i]와 k 중 가장 큰 값을 집어넣는다.\n이 값과 dp[i + t[i]] 이 값을 비교하여 큰 값을 dp[i + t[i]]에 넣는다. 🖥 소스 코드 from sys import stdin n = int(stdin.readline()) t, p = [], [] dp = [0 for _ in range(n + 1)] for _ in range(n): ti, pi = map(int, stdin.readline().split()) t.append(ti) p.append(pi) k = 0 for i in range(n): k = max(k, dp[i]) if i + t[i] \u0026gt; n: continue dp[i + t[i]] = max(k + p[i], dp[i + t[i]]) print(max(dp)) 💾 느낀점 다이나믹 프로그래밍 문제에 매우 약하다. 여러 문제를 꾸준히 풀어봐야겠다. 다이나믹 프로그래밍 부분에서는 구현 부분에서 굉장히 헤매는 것 같다.\n각 변수의 사용처, 갱신 등을 더 꼼곰히 체크해서 사고하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-15486-%ED%87%B4%EC%82%AC-2-with-python/","summary":"📌 BOJ 15486 퇴사 2 💡 조건 및 풀이 퇴사가 남은 일 수 N. 1 \u0026lt;= N \u0026lt;= 1500000 T, P 의 길이는 N과 같으며, 1 \u0026lt;= Ti \u0026lt;= 50, 1 \u0026lt;= Pi \u0026lt;= 1000 N + 1 에 해당하는 날짜부터는 상담을 할 수 없다. DP 유형의 문제 상담을 통해 취한 이익 중, 가장 큰 값을 반환하는 문제. 🔖 예제 및 실행결과 예제 10 5 50 4 40 3 30 2 20 1 10 1 10 2 20 3 30 4 40 5 50 실행결과 90 ⌨️ 문제 풀이 편한 계산을 위해 dp를 n + 1의 크기만큼 생성했다.","title":"[BOJ] 15486 퇴사 2 with Python"},{"content":"\n📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,\nT1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 응시자, 테이블, 파티션 = P, O, X 정확성 테스트의 시간은 10초. 🔖 예제 및 실행결과 예제 places = [[\u0026#34;POOOP\u0026#34;, \u0026#34;OXXOX\u0026#34;, \u0026#34;OPXPX\u0026#34;, \u0026#34;OOXOX\u0026#34;, \u0026#34;POXXP\u0026#34;], [\u0026#34;POOPX\u0026#34;, \u0026#34;OXPXP\u0026#34;, \u0026#34;PXXXO\u0026#34;, \u0026#34;OXXXO\u0026#34;, \u0026#34;OOOPP\u0026#34;], [\u0026#34;PXOPX\u0026#34;, \u0026#34;OXOXP\u0026#34;, \u0026#34;OXPOX\u0026#34;, \u0026#34;OXXOP\u0026#34;, \u0026#34;PXPOX\u0026#34;], [\u0026#34;OOOXX\u0026#34;, \u0026#34;XOOOX\u0026#34;, \u0026#34;OOOXX\u0026#34;, \u0026#34;OXOOX\u0026#34;, \u0026#34;OOOOO\u0026#34;], [\u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;, \u0026#34;XPXPX\u0026#34;, \u0026#34;PXPXP\u0026#34;]] 실행결과 [1, 0, 1, 1, 1] ⌨️ 문제 풀이 정확성 테스트가 있기 때문에 시간초과 및 메모리 초과에 신경을 써야한다.\n그러므로 응시자들의 좌표만 따로 배열로 받아서 맨해튼 거리를 구한 뒤 맨해튼 거리가 2 이하인 것들만 BFS를 통해\n응시자 사이가 파티션으로 막혀 있는지 확인한다.\n대기실을 BFS로 돌면서 큐에 이동 거리, 좌표, 움직인 이동 좌표를 배열로 넣어 주며,\n이동 거리가 맨해튼 거리보다 멀다면 BFS 과정을 skip 한다.\n두 응시자의 맨해튼 거리가 2 이하일 때, 사이에 파티션이 있는 경우를 처리 하지 못해서 테스트 케이스 5번이 틀렸다.\n내가 틀린 반례는 아래와 같다. 답은 1이다.\n[[\u0026#34;OPXPO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;, \u0026#34;OOOOO\u0026#34;]] 🖥 소스 코드 from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, -1, 1] def bfs(board, now, goal, dist): q = deque() visited = [] x, y = now q.append((0, x, y, [])) visited.append(now) check = False while q: cost, x, y, visit = q.popleft() # 움직인 거리가 맨헤튼 거리보다 많으면 넘어가기 if cost \u0026gt; dist: continue if (x, y) == goal: for i, j in visit: if board[i][j] == \u0026#39;X\u0026#39;: check = True elif board[i][j] == \u0026#39;O\u0026#39;: return False for i in range(4): nx, ny = dx[i] + x, y + dy[i] if -1 \u0026lt; nx \u0026lt; 5 and -1 \u0026lt; ny \u0026lt; 5: if (nx, ny) not in visited: # 목표 지점을 visited 에 넣지 않는다. # 가능한 많은 경로를 염두에 두어 계산한다. if (nx, ny) != goal: visited.append((nx, ny)) temp = visit[:] temp.append((nx, ny)) q.append((cost + 1, nx, ny, temp)) return check def solution(places): answer = [] for i in range(len(places)): board = [] data = places[i] ps = [] # 대기실 리스트 만들기 for j in range(5): for k in range(5): if data[j][k] == \u0026#39;P\u0026#39;: ps.append((j, k)) board.append(list(data[j])) ps.sort() check = True for j in range(len(ps)): x1, y1 = ps[j] for k in range(j + 1, len(ps)): x2, y2 = ps[k] dist = abs(x1 - x2) + abs(y1 - y2) if dist \u0026lt; 3: if not bfs(board, ps[j], ps[k], dist): check = False break if not check: break answer.append(1) if check else answer.append(0) return answer 💾 느낀점 어제 풀었던 불! 보다 쉬웠다. 반례 테스트 케이스를 찾는데 조금 어려움이 있었다. BFS는 짜기 나름인 것 같다. queue 에 넣는 정보를 다양하게 사용하는 법이 익숙해지고 있는 것 같아 좋다.\n그러나 visited 배열을 더 다양하게 사용하는 법을 연습해야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-with-python/","summary":"📌 Programmers - 거리두기 확인하기 💡 조건 및 풀이 대기실에 응시자들이 면접을 위해 대기를 하고 있다. 대기실에 있는 대기자들이 거리 두기를 잘 지키고 있을까? 대기실은 5개, 각 대기실은 5 * 5의 크기입니다. 응시자들 간의 거리는 맨해튼 거리는 2 이하로 앉을 수 없으니 3 이상이어야한다. 맨해튼 거리가 2이하여도 응시자 사이에 파티션으로 막혀 있으며 지나갈 다른 방법으로 응시자로의 경로가 없다면 상관이 없다. BFS 유형의 문제 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면,","title":"[Programmers] 거리두기 확인하기 with Python"},{"content":"\n📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다. 입력받은 expression의 정보를 담을 변수를 하나 만들고,\n문자열에서 연산자를 구분한 뒤 숫자는 정수형 변수로 변환시켜 각각 리스트에 담는다. 연산자의 우선순위는 itertools 의 permutaions 를 사용해 순열을 만든 후\nset()을 통해 순열의 중복을 없앴다. 각 순열을 하나씩 for 문으로 꺼내고, 그 순열의 원소를 돌며 최댓값을 계산한다. 주어지는 문자열의 길이가 매우 길지 않은 점\npython 언어의 list와 문자열에 있는 index() 함수를 사용. 리스트의 index() 함수는 찾고자 하는 데이터의 가장 앞에 있는 것을 반환\n그렇기 때문에 같은 연산자인 경우 우선순위가 앞에 있다는 점을 만족한다 해당하는 인덱스의 연산자 앞 뒤의 숫자를 연산자에 맞게 계산 후,\n계산한 연산자와 피연산자를 뺀 자리에 계산값을 넣음 반복하여 1개 남은 원소 즉, 수식의 최종 계산값을 answer 와 비교해 큰 값으로 교체해주면 된다.\n뮬론 음수는 abs() 함수를 사용해 양수로 변경해주었다. 🖥 소스 코드 from itertools import permutations as pt def solution(expression): answer = -1e9 op, nums = [], [] a, b = -1, -1 new_ex = [] for i in range(len(expression)): if expression[i].isnumeric(): if a \u0026lt; 0: a = i else: b = i else: if b \u0026lt; 0: b = a op.append(expression[i]) nums.append((a, b)) new_ex.append(int(expression[a:b+1])) new_ex.append(expression[i]) a, b = -1, -1 if b \u0026gt; -1: new_ex.append(int(expression[a:b+1])) else: new_ex.append(int(expression[a])) k = list(set(op)) for case in list(set(pt(k, len(k)))): temp_new_ex = new_ex[:] for j in case: while j in temp_new_ex: idx = temp_new_ex.index(j) if j == \u0026#39;*\u0026#39;: temp = temp_new_ex[idx - 1] * temp_new_ex[idx + 1] elif j == \u0026#39;-\u0026#39;: temp = temp_new_ex[idx - 1] - temp_new_ex[idx + 1] else: temp = temp_new_ex[idx - 1] + temp_new_ex[idx + 1] temp_new_ex = temp_new_ex[:idx - 1] + [temp] + temp_new_ex[idx + 2:] answer = max(answer, abs(temp_new_ex[0])) return answer 💾 느낀점 정규표현식으로 연산자와 피연산자를 구분하여 추출해서 풀면,\n시간복잡도가 더 줄 수도 있을 것 같다. 정규표현식을 더 공부하고 연습해보아야겠다. 이보다 expression의 길이가 더 길어 시간초과가 날 때는 어떻게 할 것인지\n연산을 더 줄일 수 있는 방법을 생각해봐야겠다. 괄호를 넣어 eval() 함수를 사용하는 것도 생각해보았는데, 실행 속도에서 생각해보니\n그리 좋지 않은 풀이 방법인 것 같아 사용하지 않았다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94-with-python/","summary":"📌 Programmers - 수식 최대화 💡 조건 및 풀이 계산 가능한 수식이 있는 expression 이 주어지며, 길이가 3이상 100이하인 문자열. 연산자는 +, -, * 만 있다. 피연산자는 0 이상 999 이하다. 같은 연산자는 앞에 있는 것이 더 우선순위가 높다. 연산자의 우선순위를 정해서 그것 먼저 계산해주면 된다. 계산된 음수는 양수로 바꾸어서 최댓값 계산을 한다. 🔖 예제 및 실행결과 예제 expression = \u0026#34;100-200*300-500+20\u0026#34; expression = \u0026#34;50*6-3*2\u0026#34; 실행결과 60420 300 ⌨️ 문제 풀이 답으로 반환할 answer를 -1e9로 초기화한다.","title":"[Programmers] 수식최대화 with Python"},{"content":"\n📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산\ni에서 j로 가는 비용과 i에서 k를 경유하여 j로 가는 비용 중에 더 저렴한 것 answer를 더 저렴한 비용을 비교하기 위해 1e9로 초기화 for 문으로 1번 노드부터 n번 노드까지 아래의 내용을 검사한다.\nanswer와 출발지(s)에서 i까지 합승한 값 + i 부터 B의 목적지까지 가는 값 + i 부터 A의 목적지까지 가는 값 비교 🖥 소스 코드 from collections import deque def solution(n, s, a, b, fares): answer = int(1e9) INF = int(1e9) distance = [[INF] * (n + 1) for _ in range(n + 1)] for q, w, e in fares: distance[q][w] = e distance[w][q] = e for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if i == j: distance[i][j] = 0 else: if distance[i][j] \u0026gt; distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] for i in range(1, n + 1): if answer \u0026gt; distance[s][i] + distance[i][b] + distance[i][a]: answer = distance[s][i] + distance[i][b] + distance[i][a] return answer 💾 느낀점 BFS로 최단거리를 찾아보기 위해 이동거리 값을 저장하는 큐를 생성해 문제를 풀려고 시도했다.\n그 결과 시간을 매우 낭비하게 되었고, 플로이드 와샬을 떠올려 문제 풀이를 했다. 플로이드 와샬 구현 방법을 조금 헷갈리는 문제점이 있었다.\n플로이드 와샬이면 굳이 BFS가 없는데 위에서 말한 BFS 소스코드를 그대로 두었었다. 시간초과가 났다. 26번 테스트 케이스에서 시간초과가 났다.\n플로이드 와샬 부분과 반환할 answer를 위해 비교하는 부분에서 min() 대신\nif를 써주었더니 속도차이가 두 배 가까이 났다. ","permalink":"https://jxun-h.github.io/posts/ps/programmers-%ED%95%A9%EC%8A%B9-%ED%83%9D%EC%8B%9C-%EC%9A%94%EA%B8%88-with-python/","summary":"📌 Programmers - 합승 택시 요금 💡 조건 및 풀이 노드의 개수 n, 출발노드 s, A의 도착지점 a,\nB의 도착지점 b, 노드 간 이동하는데 드는 비용 fares A와 B가 서로 다른 목적지를 향하고 있다. A와 B가 따로 이동하는 것과 어느 지점까지 같이 이동하는 것 중에\n최소 비용을 구하는 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 🔖 예제 및 실행결과 예제 print(solution(6, 4, 6, 2, [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]])) print(solution(7, 3, 4, 1, [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]])) print(solution(6, 4, 5, 6, [[2, 6, 6], [6, 3, 7], [4, 6, 7], [6, 5, 11], [2, 5, 12], [5, 3, 20], [2, 4, 8], [4, 3, 9]])) 실행결과 82 14 18 ⌨️ 문제 풀이 거리 정보를 담을 graph 2중 리스트를 생성 플로이드 와샬 알고리즘을 사용하여 각각 노드끼리 얼마의 비용이 드는지 계산","title":"[Programmers] 합승 택시 요금 with Python"},{"content":"\n📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다. 임시 배열을 만들어 불과 지훈이가 움직일 때 이동 가능한 경로를 모두 넣어주고 while 문이 종료되었을 때 큐에 삽입 지훈이가 지나간 곳은 '$'로 변경 불은 '$' 와 '.' 를, 지훈이는 오로지 '.' 만 갈 수 있게 처리. 지훈이가 움직일 때, Queue 에서 현재 지훈이의 좌표를 뽑아, 벽에 위치하고 있다면 탈출 성공. if x == 0 or y == 0 or x == r - 1 or y == c - 1: 더 이상 지훈이가 움직일 경로가 없다면 탈출 실패 if not J: 🖥 소스 코드 from sys import stdin from collections import deque dx, dy = [1, -1, 0, 0], [0, 0, 1, -1] r, c = map(int, stdin.readline().split()) board, res = [], 0 # 지환이와 불난 곳 저장할 변수 F, J = deque(), deque() for i in range(r): data = list(stdin.readline().rstrip()) for j in range(c): if data[j] == \u0026#39;J\u0026#39;: J.append((i, j)) if data[j] == \u0026#39;F\u0026#39;: F.append((i, j)) board.append(data) def bfs(): global F, J, res while 1: res += 1 temp = [] while F: x, y = F.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c: if board[nx][ny] == \u0026#39;.\u0026#39; or board[nx][ny] == \u0026#39;$\u0026#39;: temp.append((nx, ny)) board[nx][ny] = \u0026#39;F\u0026#39; F = deque(temp) temp = [] while J: x, y = J.popleft() if x == 0 or y == 0 or x == r - 1 or y == c - 1: return res for i in range(4): nx, ny = dx[i] + x, dy[i] + y if -1 \u0026lt; nx \u0026lt; r and -1 \u0026lt; ny \u0026lt; c and board[nx][ny] == \u0026#39;.\u0026#39;: temp.append((nx, ny)) board[x][y] = \u0026#39;$\u0026#39; board[nx][ny] = \u0026#39;J\u0026#39; J = deque(temp) if not J: return False if bfs(): print(res) else: print(\u0026#39;IMPOSSIBLE\u0026#39;) 💾 느낀점 BFS 유형 문제에서 난이도가 실버2 ~ 골드4 로만 올라가도 헤매는 모습을 보였다. 방문처리용 배열의 다양한 사용법을 눈에 익히고 응용할 줄 알아야겠다. 방문처리용 배열을 사용하기 전, 메모리 초과가 뜰 각인지 잴 줄 알아야겠다. 문제를 나름대로 해석하고 압축하는 능력을 더 키워야겠다. ","permalink":"https://jxun-h.github.io/posts/ps/boj-4179-%EB%B6%88-with-python/","summary":"📌 BOJ 4179 불! 💡 조건 및 풀이 R * C 크기의 배열을 입력받아 지훈이가 미로에서 탈출 할 수 있는지 구하는 문제. R * C 크기의 배열은 최대 1000 * 1000 BFS 유형의 문제 미로의 벽에 붙어있으면 탈출이 가능하다. 불을 먼저 지른 후, 지훈이의 이동 가능 경로를 살핀다. 방문처리를 통해 한 번 갔던 곳은 다시 가지 않는다. 🔖 예제 및 실행결과 예제 4 4 #### #JF# #..# #..# 실행결과 3 ⌨️ 문제 풀이 과정방문처리용 리스트를 만들어 사용하니 시간초과와 메모리 초과가 떴다.","title":"[BOJ] 4179 불! with Python"},{"content":" 안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Contact. Github : github.com/Jxun-h\nTistory : dreamtreeits.tistory.com\nEmail : its1108@kakao.com Resume. 이력과 포트폴리오를 기재한 이력서입니다. Introduction. 트레이드 오프를 고려해 균형잡힌 선택을 하려 노력합니다.\n안정적인 서비스를 만드는데 기여하고자 노력하는 백엔드 개발자입니다.\n또한 서비스가 안정적으로 운영되기 위한 방법에 대해 고민합니다. Why Post in Blog. 블로그를 처음 쓰기 시작한 것은 2021년 08월 28일 입니다.\n코딩 테스트를 위해 고민했던 내용과 해결 과정들을 오로지 머리로만 기억하는 것에 한계가 있음을 느꼈습니다.\n블로그를 제 두뇌의 외장하드로 쓰기 결심하고, 티스토리에서 포스팅을 시작했습니다.\n그 후 약 1년간 꾸준히 알고리즘 풀이를 포스팅 했고, 2023년 4월 18일 이후 공백기간이 있었습니다.\n2024년을 맞이해 블로그 작성을 통해 쌓여가는 경험과 지식을 되돌아보고 회고록도 써보려고 합니다.\n다시 시작하는 저의 블로그는 github.io 로 시작해보려 합니다. ","permalink":"https://jxun-h.github.io/about/","summary":"짤막한 소개글","title":"About"},{"content":"안정적인 서비스 개발을 추구하는 Backend Developer 조형준입니다. Work Experience TAPartners period 24.01 - current position Back-end Engineer project 건설사업관리 플랫폼 고도화 자세히 보기\n건설사업관리 플랫폼 고도화\n기획 중 Tech Stack\nVue3 Java Oracle SQL period 23.06 - 24.01 position Back-end Engineer project 건설사업관리 플랫폼 구축/개발 자세히 보기\n건설사업관리 플랫폼 구축/개발\nRestful API 작성 다국어 처리를 위한 Oracle Function 생성 및 Query 작성 대용량 Excel Read \u0026amp; Upload 처리 개발 Spring JDBC Batch 적용 약 80% 이상의 업로드 속도 개선\n공사 관련 청구/정산 프로세스 개발 Tech Stack\nVue3 Java Oracle SQL SAX Library POI Excel Library Toogram Systems period 19.12 - 21.01 position Python Back-end Engineer project 선박 자율운항 최적항로 알고리즘 구축/개발 자세히 보기\n선박 자율운항 최적항로 알고리즘 구축/개발\n선박 데이터 전처리 및 가공 선박 운항 데이터 전처리 및 가공 선박 운항 항로 렌더링 처리 그래프 탐색 알고리즘 기반 자율운항 항로 계산 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript period 19.07 - 20.01 position Python Back-end Engineer project 선박 데이터 기반 이상탐지 알고리즘 개발 자세히 보기\n선박 데이터 기반 이상탐지 알고리즘 개발\n선박 데이터 전처리 마할라노비스 다구찌 기반 이상탐지 알고리즘 개발 선박 데이터 시각화 개발 JS 기반 데이터 차트 오픈소스 라이브러리 적용 및 테스트 Tech Stack\nDjango PostgreSQl Ubuntu Python3 JavaScript Other Experience Blog Author, Maintainer\n21.08.28 - 현재\n비정기적으로 새롭게 배우고 공부한 내용 등을 글로 작성해 공유합니다.\n블로그는 이전에 약 1년간 사용하던 Tistory 와 현재 보고 계신 Github Pages가 있습니다.\n현재 블로그는 Hugo + github.io 를 사용해 구현했습니다. Internship 한이음 ICT 멘토링 period 18.04 - 18.11 position Intern project 생활 법령 정보제공 챗봇 서비스 개발 자세히 보기\n생활 법령 정보제공 챗봇 서비스 개발\nSoap API 를 사용해 공공데이터포털 크롤링 자연어 처리에 사용할 형태소 분석기를 시스템에 import 자연어 처리 Seq2Seq 연구 및 적용 테스트 카카오톡 챗봇 서비스 API 연결 및 테스트 Tech Stack\nPython Django Soap API MySQL Linux (Ubuntu) 씨에스리 ICT 인턴십 period 18.03 - 18.06 position Intern project 블럭코딩 데이터 분석툴(BigZami) 개발 자세히 보기\n블럭코딩 데이터 분석툴(BigZami) 개발\nNexacro Flatform 기반 컴포넌트 개발 및 연결 SpringBoot 기반 Back-end 환경 구성 R - Java 언어 연동 및 Nexacro Flatform 연동 테스트 Plotly 오픈소스 라이브러리 적용 테스트 Tech Stack\nNexacro Flatform Java Spring Boot OpenSource Library 씨에스리 ICT 인턴십 period 17.09 - 17.12 position Intern project IT 지식 제공 챗봇 개발 자세히 보기\nIT 지식 제공 챗봇 개발\nDjango 기반 개발 서버 환경구축 카카오톡 챗봇 서버와 Restful API 연동 형태소 분석기 테스트 및 사용자 전용 단어 사전 구축 자연어 처리 방법 연구 및 분석 Tech Stack\nDjango Python2 Ubuntu MySQL Rest API Skills Overall. 안정적인 서비스 및 효율적인 구현을 좋아합니다. 최신 기술보다 상황에 따라 적절한 선택을 하는 것이 최적의 결과가 나온다고 믿습니다. 업무에 따라 능숙한 분야가 아니더라도 적극적으로 탐색해 최적의 결과를 낼 수 있도록 노력합니다. Communication. 직위 및 포지션에 관계없이 적극적인 의사소통을 시도합니다. 지적 겸손함을 유지하기 위해 노력합니다. Server. 성능향상을 위한 리팩토링을 한 경험이 있습니다. Java SpringBoot 를 비롯해, Python Django 또한 지원이 가능합니다. 필요하다면 셸스크립트를 작성해 반복되는 업무를 자동화 가능합니다. Python. Python3 환경에 익숙하고 능숙합니다. 웹프레임워크를 필요에 따라 구분해 사용할 수 있으며, 공통 로직을 적절히 모듈화해 사용합니다. Java JDBC를 능숙하게 사용하고, 속도개선을 위해 캐싱이나 배치를 적절히 활용합니다. 불필요한 API 호출을 최대한 삼가하며, 합리적인 방식으로 서비스를 분리합니다. Education Woosuk Univ. 정보보안학과\n2012.03 - 2019.02\n4.31 / 4.5\n정보보안학과에서 4년간 공부하며, 거의 모든 과목을 높은 성적으로 이수하였습니다.\n군대에 가기 전, 가고 싶은 곳에 지원하기 위한 준비를 위해 약 1년 간 휴학했습니다. certificate 정보처리기사 2018.08.17 리눅스마스터 2급 2017.06.10 ","permalink":"https://jxun-h.github.io/resume/","summary":"이력서","title":"Resume"}]